<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OLIV&#39;s BLOG</title>
    <link>https://gitplayb.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 01 Jun 2020 15:38:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>幸福</title>
      <link>https://gitplayb.github.io/passages/%E5%B9%B8%E7%A6%8F/</link>
      <guid>https://gitplayb.github.io/passages/%E5%B9%B8%E7%A6%8F/</guid>
      <pubDate>Sun, 24 May 2020 15:31:36 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>三个让我感到幸福的瞬间：</p><hr><h3 id="刷完牙后喝到的第一口纯净水"><a href="#刷完牙后喝到的第一口纯净水" class="headerlink" title="刷完牙后喝到的第一口纯净水"></a>刷完牙后喝到的第一口纯净水</h3><h3 id="洗完澡后等待头发风干的15分钟"><a href="#洗完澡后等待头发风干的15分钟" class="headerlink" title="洗完澡后等待头发风干的15分钟"></a>洗完澡后等待头发风干的15分钟</h3><h3 id="走在路上抬头看到了绝美的天空"><a href="#走在路上抬头看到了绝美的天空" class="headerlink" title="走在路上抬头看到了绝美的天空"></a>走在路上抬头看到了绝美的天空</h3><p>这周六到底干嘛去了？？？？？</p><hr><p>这个周末，买了个桌子，宜家的利蒙桌子，在淘宝上看了一些长得很像的，然后发现评论里提到了宜家有一款类似的就是稍贵。<br>后来在闲鱼上同城范围内搜索，有很多因为搬家要出的，就选了一个￥80的，附带一个架子（可以放书，也可以当鞋架），和一个宜家的小凳子，比较划算了。<br>这个桌子我非常喜欢，因为简约的设计和比较稳定的结构，尤其是那块桌面，板子很厚胳膊放上去很舒服，桌子的腿是可拆卸的，搬运也很方便，总之很满意。<br>作为我的新电脑桌，以后就要好好利用它来学习了。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E5%B9%B8%E7%A6%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>做自己</title>
      <link>https://gitplayb.github.io/passages/%E5%81%9A%E8%87%AA%E5%B7%B1/</link>
      <guid>https://gitplayb.github.io/passages/%E5%81%9A%E8%87%AA%E5%B7%B1/</guid>
      <pubDate>Sun, 24 May 2020 15:31:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;每周一篇，不见不散！&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每周一篇，不见不散！</p><a id="more"></a><h3 style="text-align:center"> 此帖为证 </h3><hr>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E5%81%9A%E8%87%AA%E5%B7%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Recent News 2020-05-17</title>
      <link>https://gitplayb.github.io/passages/Recent-News-2020-05-17/</link>
      <guid>https://gitplayb.github.io/passages/Recent-News-2020-05-17/</guid>
      <pubDate>Sun, 17 May 2020 15:01:55 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="还健身吗"><a href="#还健身吗" class="headerlink" title="还健身吗"></a>还健身吗</h2><p>最近一段时间总是觉得很累，虽然没有干什么。疫情的原因公司健身房一直没开，身边有人办了健身卡，自己想想还是算了，如果办了又不去还不如不办，关键是感觉自己需要学很多东西，就没有那么多时间留给健身。<br>于是买了个瑜伽垫。这回学聪明了，买之前专门查了一下材质。之前买过一个泡沫板一样的（好像是nbr材质），一点也不防滑，就觉得很厚很大可能也还不错吧；后面用了另一种超级防滑的就觉得下次要买这种的。这次买的是tpe材质的，查了下据说价格比较贵，然而刚好有家店在做活动，优惠下来比上次那个还便宜了，拿到后试了下，确实不错。</p><h2 id="新电脑不能吃灰"><a href="#新电脑不能吃灰" class="headerlink" title="新电脑不能吃灰"></a>新电脑不能吃灰</h2><p>新买的MacBook Pro已经到手三周了，而我竟没什么时间摸它😌。开始的那几个周末，在装一些开发用的软件，遇到一些比较难搞定的（比如Homebrew）多花了一些时间。平时工作还是用公司发的ThinkPad，手里的电脑打算刷算法题以及自己做项目用。然而，算法题到现在还没开始刷起来，一定要做到每周一刷啊，这是底线了。</p><p><strong>底线</strong></p><hr><h2 id="偶尔弹吉他"><a href="#偶尔弹吉他" class="headerlink" title="偶尔弹吉他"></a>偶尔弹吉他</h2><p>经历过一周疯狂练习每天回到宿舍就弹的日子，我再也没这么多精力去玩它了。不过，John Mayer的老师Tomo Fujita的那本<em>Accelerate Your Guitar Playing</em>确实不错，短小精悍。这种讲乐理的书基本都是长篇大论，而且还有些只有五线谱的就看的更慢了。这本书着重对弹奏Blues、Funk和Jazz的一些基本技巧的练习，如Blues的12小节和和弦变化、Funk的基本节奏以及在Blues进行中使用一些新的和弦使之变得Jazzy的手法。Tomo老师比较注重吉他演奏的节奏，他认为吉他是一个节奏型的乐器。我觉得挺对的，毕竟我口琴也是练了一半只顾着各种压音舌堵却没有在一个稳定的节奏下练习，导致听上去不那么对，好像还会即兴似的。</p><p>精准的节奏才是演奏好一门乐器的基础，不应该只有旋律。所以，老老实实练习，别想那么多有的没的。</p><h2 id="整理一下"><a href="#整理一下" class="headerlink" title="整理一下"></a>整理一下</h2><p>没事的时候，不，找时间也要整理一下自己的东西。从外到内。</p><p>什么衣服啊乱七八糟的小玩意啊，该扔的还是扔了，留着徒增烦恼。出门的时候也可以换一身行头，几百年不变的穿着是方便，可是身上的衣服经不起这么穿，柜子里的也想出来透透气啊。</p><p>每周回顾一下自己的学习进度，每天看书是好事，但是一直这样没完没了的看也不是个办法。还是要有一个进度条或者检验学习成果的东西，来看一下自己到底学到了多少。资料堆了再多，没有学到东西也是白搭。</p><p>学习做做减法，One At A Time.</p><hr><p>明天的太阳会照常升起，JUST DO IT.</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Recent-News-2020-05-17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>去他妈的世界</title>
      <link>https://gitplayb.github.io/passages/%E5%8E%BB%E4%BB%96%E5%A6%88%E7%9A%84%E4%B8%96%E7%95%8C/</link>
      <guid>https://gitplayb.github.io/passages/%E5%8E%BB%E4%BB%96%E5%A6%88%E7%9A%84%E4%B8%96%E7%95%8C/</guid>
      <pubDate>Mon, 11 May 2020 15:30:40 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前看了<em>The End Of the F###ing World</em>第一季，感觉还不错，除了剧情以及英式口音之外，配乐是最吸引我的了。不得不说，Netflix的作品质量是真的挺高的。还有前一阵子看的<em>Love,Death&amp;Robots</em>也很不错，短小精美且引人深思。什么时候国产电视剧能达到这个水准那我就乖乖的看国产剧了。</p><h2 id="两个怪人"><a href="#两个怪人" class="headerlink" title="两个怪人"></a>两个怪人</h2><p>James和Alysa是两个17岁的青少年。女主做事情不喜欢墨守成规，性格比较大大咧咧；男主有点呆萌，是个体会不到感情但其实一点也不冷血的“杀手”。</p><h2 id="欢喜冤家"><a href="#欢喜冤家" class="headerlink" title="欢喜冤家"></a>欢喜冤家</h2><p>两个人中Alysa是更强势的一方，James就是一个文若书生。</p><h2 id="是爱情吗"><a href="#是爱情吗" class="headerlink" title="是爱情吗"></a>是爱情吗</h2><p>两人在一起离家出走公路旅行的途中相互治愈，也获得了爱情。</p><p>理想中的爱情的样子，就是在合适的时间、合适的地点遇到了合适的人。两人之间的默契似乎不必建立，相视一笑便知道对方也懂得你的意思。就是这种destined的感觉让你觉得自己好像陷入了什么。</p><hr><p>剧中取景地的风景也异常优美😍</p><p><img src="/passages/去他妈的世界/woods1.png" alt="woods1"></p><p><img src="/passages/去他妈的世界/woods2.png" alt="woods2"></p><p><img src="/passages/去他妈的世界/woods3.png" alt="woods3"></p><p><img src="/passages/去他妈的世界/woods4.png" alt="woods4"></p><p><img src="/passages/去他妈的世界/holding.png" alt="hoding"></p><p><img src="/passages/去他妈的世界/dread.png" alt="dread"></p><p><img src="/passages/去他妈的世界/finishedLook.png" alt="finishedLook"></p><p><img src="/passages/去他妈的世界/outdoor1.png" alt="outdoor1"></p><p><img src="/passages/去他妈的世界/outdoor2.png" alt="outdoor2"></p><p><img src="/passages/去他妈的世界/outdoor3.png" alt="outdoor3"></p><p><img src="/passages/去他妈的世界/outdoor4.png" alt="outdoor4"></p><p><img src="/passages/去他妈的世界/outdoor5.png" alt="outdoor5"></p><p><img src="/passages/去他妈的世界/outdoor6.png" alt="outdoor6"></p><p><img src="/passages/去他妈的世界/outdoor7.png" alt="outdoor7"></p><hr><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>第二季的音乐全部由Blur乐队前吉他手Graham Coxon包办（一人创作几十首歌曲想想就…而且毕竟不是影视剧），开始就觉得剧中音乐挺好听的，尤其是到了第二季，很多片段的配乐还夹带一点Blues元素，这我就没法不爱了。总之，喜欢英/美剧那就去看它!</p><p><a href="https://www.bilibili.com/video/av23262839/" target="_blank" rel="noopener">面老师访谈</a></p><hr>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E5%8E%BB%E4%BB%96%E5%A6%88%E7%9A%84%E4%B8%96%E7%95%8C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于API Caller的一些想法</title>
      <link>https://gitplayb.github.io/passages/%E5%85%B3%E4%BA%8EAPI-Caller%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</link>
      <guid>https://gitplayb.github.io/passages/%E5%85%B3%E4%BA%8EAPI-Caller%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</guid>
      <pubDate>Tue, 21 Apr 2020 15:25:04 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>你是API Caller吗？还是你只是个API Caller   </p></blockquote><p>这有点像个直击灵魂的拷问，作为程序员的你是否问过自己呢？<br>自从开始学习计算机开始，我有时候常常在想自己作为一个coder or programmer，究竟在做些什么？第一次见到这个词–<strong>API</strong>，也叫<strong>应用程序编程接口</strong>，这个拗口的名字的英文原名就是<em>Application Programming Interface</em>，其实有点被吓到：应用程序是什么？编程是什么？接口又是什么？对于初学者来说一上来看到很多术语当然会感到手足无措，但你应该想，术语就是术语，他们只是一些定义而已，随着你对它的深入了解，它表面看起来再怎么晦涩也只不过是对行外人说的了。</p><hr><p>首先，什么是Application。这个词为广大人民所熟知大概是从2007年初代iPhone上市后，从那以后，手机相当于一个智能小电脑，也可以下载安装各种应用程序了。而且大家也乐于叫它的简称：App（以及对应的App Store）。其实这个词在计算机领域早就已经使用的很广泛了。<br>一个应用程序，就是一个小的具备某种功能的一个系统或者应用。</p><p>Programming，也就是编程，就是程序员日常在做的事情。</p><p>Interface这个词在计算机及相关行业有点被overuse了，不过最常听说的一般是这两种：<strong>硬件接口</strong>和<strong>软件接口</strong>。<br>硬件接口就是在硬件与硬件之间用的，通俗的理解，就是为了使硬件与硬件之间能够传输数据，因此硬件接口通常伴随着各种协议。其实没有学习理论知识的时候，对接口的理解就是硬件上的各种插线的接口，比如电脑上的USB接口，电视或者显示屏的HDMI接口等等。 </p><p>软件接口常说的一般有两种：</p><ol><li>编程语言相关的特性；</li><li>软件中的可以提供给其它组件（代码）调用的一个服务。</li></ol><p>许多编程语言都设计了接口这一特性，如Java、C#等。Java中接口与抽象类比较接近，与抽象类不同的是，接口中不包含属性，只有方法，并且实现接口的方法必须实现其所有方法，而且一个类可以继承多个接口；而抽象类是一个类，只能被单继承。抽象类相当于是类的一个抽象，将子类中的公共部分抽象出来方便使用；而接口相当与是“插件”，继承了某个接口相当于为这个类添加了一些新功能。</p><p>第二类涉及软件的接口就是代码中的某个服务，这也和近两年比较火的微服务有关。即，对于某个服务来说，有调用方和被调用方。调用方通过一些远程调用协议，如RPC，或者直接通过HTTP，来调用被调用方提供的接口。这个接口就是被调用方设计好的，如何传参，返回什么响应，怎么进行异常处理等等。或者如果是项目组内部，可以通过组件的方式，使用maven引入依赖的方式直接调用。</p><p>通常这些接口就是一些业务相关的实现代码，涉及到的也就是业务开发。<br>业务开发中，一般有两方面需要考虑：</p><ul><li>如何实现？</li><li>怎样更高效？</li></ul><p>而如何实现通常包括使用什么框架（项目组内部应该是确定好了的）、哪些现成代码库可以利用、怎样处理逻辑；如果复杂一点的业务可能涉及到逻辑比较复杂，或者需要一些特别的算法来实现它。<br>至于怎样更高效，那就是代码优化的问题了，通常可以包括如何优化访问速度，如何使代码具有可扩展性，如何应对高并发等。</p><p>业务开发的初级阶段，对于一些对响应速度要求不是很高、或者用户量不是很大的需求，涉及到的知识点可能也不是很多，实现功能即可。因此很多人会觉得，可能做了某个功能，实现了某个需求，但自己的知识并没有增加（比如我）。因此，我们会想看一下框架源码，看看框架的一些机制是怎么实现的，如果我们自己来实现的话会怎样做。还有关于造轮子的争论，造轮子不是不可以的，那些很好用的轮子（比如Ngnix，Redis），当初不也是一些工程师觉得现有的框架工具不好用，不能满足自己的需求然后做了吗？虽然我们可能做不到那么好，但是在造轮子的过程中一定能学到一些知识的，这些在平时的业务代码中学不到的东西。</p><p>但是，我们需要造轮子吗？或者说我们需要绞尽脑汁想我们要怎样能写出一个被大家称赞不绝的好轮子吗？我认为也不需要。因为好的轮子经历了时间的洗礼，已经被大家验证过了的，它的一些好的设计思想也是值得我们学习的，但这不意味着我们需要拿它的思想在相同的领域造一个比它更好的轮子。因为，不太可能也没什么必要。我们要做的，是要如何利用好这些轮子，来build我们自己的项目。就像盖一座房子，明明可以用更好更现代的砖块和混凝土，你非要选择用更原始的茅草和木头，显然再努力也造不出质量更好的房子。</p><p>还有一个观点就是，尽管你写的是应用层的代码，你也可以写的很精彩！首先，不可能每个人都写底层，也不是写底层的人就多么高大上，高级语言发明出来是有它的道理的。你用Java语言可以实现一个HTTP服务器，用C语言同样可以，而且还更麻烦。当然从运行效率上来说，肯定是后者要高一些，但这不妨碍你掌握学习如何写HTTP服务器，因为原理都是一样的。</p><p>综上，关于API Caller的看法，没必要觉得丢人。只要平时多思考，多学习了解底层框架原理，多动手实现一下新学到的奇怪的知识，就可以了</p><hr><p>毕竟，奇怪的知识总会增加的:)</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E5%85%B3%E4%BA%8EAPI-Caller%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>后端存储数据类型介绍</title>
      <link>https://gitplayb.github.io/passages/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/</link>
      <guid>https://gitplayb.github.io/passages/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/</guid>
      <pubDate>Sun, 19 Apr 2020 16:17:47 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我们在后台存储数据时，选择一种比较合适的数据类型往往会给后期工作带来很多便利。比如存储人名，可以使用<code>CHAR</code>或<code>VARCHAR</code>，这两者的区别顾名思义，就是VARCHAR是可变长的，而CHAR是固定长度的。<br>换句话说，如果你给CHAR设置长度为4，那么每一个数据的长度就固定为4（至于具体是4个字节还是4个字符，MySQL和PostgreSQL好像不太一样），如果不够4个字节（假设以字节为单位），就会补齐；如果设置VARCHAR为4，那么长度小于4时，数据存储在数据库的长度就是其实际长度。所以根据实际情况，如果想要存储上更省空间就用VARCHAR，如果想要每次存储时不需要额外的计算（VARCHAR由于长度不一，需要记录其实际长度）就用CHAR。</p><p>数据库存储的基本类型包括数字型、字符型、日期类型以及长文本（<strong>text</strong>）类型。</p><p>对于一些多媒体文件的存储类型，常见的做法是<strong>存储其URL路径</strong>，因为直接在数据库存储图片视频的做法想想就不可能！数据库的作用就是在我们需要查询数据时能够及时地取出，需要存储时能够比较快速地存入。如果查询一个视频类文件，需要从硬盘上加载几十分钟….想想就可怕。<br>因此，如果直接存储其URL，而它的实际内容可以在我们需要读取它时从服务器上读出来，这样就大大提高了性能，也比较符合我们的操作逻辑。</p><p>还有一种常见的数据结构是，<strong>flag</strong>或者说开关。即，在表中需要存储其值是1或0，1代表有0代表无。如果只是某个字段还好，如delete_flag。但是如果有很多，而且是同一类型的，那不可能在数据表里设置这么多字段。比如，存储房间里的家具种类，像这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"furniture": "&#123;\"bed\": 1,\"wardrobe\": 0,\"sofa\": 0,\"desksAndChairs\": 0,\"wifi\": 1,\"tv\": 0,\"airConditioner\": 1,\"washer\": 0,\"refrigerator\": 1,\"waterHeater\": 1,\"gasStoves\": 0,\"heating\": 1&#125;"</span><br></pre></td></tr></table></figure><p>这里的做法就是直接将其整体作为一个JSON字符串存储，这样的好处是既节省了空间（只需要一个字符串类型的字段）又方便后台处理。在Java代码里处理它只需要将其以JSON方式解析即可（有很多可以利用的JSON解析库，如阿里的fastjson）。</p><p>还有什么其它常见类型的存储方式，下次遇见了再追加吧。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>电吉他与我的第一次</title>
      <link>https://gitplayb.github.io/passages/Meeting-electric-guitar/</link>
      <guid>https://gitplayb.github.io/passages/Meeting-electric-guitar/</guid>
      <pubDate>Sat, 11 Apr 2020 16:36:28 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;哦，那该死的甜美，我听到第一个音符便醉了&lt;br&gt;真不敢相信这就是从我手下这把身材娇小、骨骼清奇的Strat发出的声音&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>哦，那该死的甜美，我听到第一个音符便醉了<br>真不敢相信这就是从我手下这把身材娇小、骨骼清奇的Strat发出的声音</p></blockquote><a id="more"></a><p>人生中第一次摸到电吉他，虽然此前我已经有了很多心理准备了，但还是有点小激动啊。<br>在一个不那么晴朗的午后，坐上我心爱的小公交，跑去了那家在网上看到的琴行–森迪琴行。<br>虽然网上的评价还有些比较刺耳的，但是抱着试一试的心态，就去了。<br>到店后，店家看我在看电吉他，我给他说了我从来没有碰过，然后他给我讲了一些电吉他周边的基础知识，虽然在各种测评视频论坛贴吧看过很多了，但是听到他给我说这些，感觉还不错，觉得老板还算专业。然后我让他给我示范了一下怎么弹，一共试了三把，恰巧都是我听过的型号。</p><h2 id="吉他"><a href="#吉他" class="headerlink" title="吉他"></a>吉他</h2><h3 id="Fender-Telecaster"><a href="#Fender-Telecaster" class="headerlink" title="Fender Telecaster"></a>Fender Telecaster</h3><p><img src="/passages/Meeting-electric-guitar/Tele.jpg" alt="Fender Telecaster"><br>第一把是Fender的Telecaster，这把按理来说应该音色挺亮的，刚开始接的也是Fender的音箱，看起来还不错。切换了几种效果器，Tremelo、Fuzz还有失真什么的，感觉还不错吧。</p><h3 id="Epiphone-Les-Paul"><a href="#Epiphone-Les-Paul" class="headerlink" title="Epiphone Les Paul"></a>Epiphone Les Paul</h3><p><img src="/passages/Meeting-electric-guitar/Epiphone.jpg" alt="Epiphone Les Paul"><br>Epiphone LP的音色较厚较温暖，相对Fender来说。<br>就我目前所了解的，Epiphone是Gibson一个子品牌，Gibson的各种经典型号（ES-335、Les Paul）Epiphone也有，但可能是因为定位不同，也可能是收购的子品牌当然被压制的原因，Epiphone的琴和Gibson的琴相比还是差了挺多。但是作为一把初学者入门的固定琴桥的琴还是足够的。</p><h3 id="Fender-Stratocaster"><a href="#Fender-Stratocaster" class="headerlink" title="Fender Stratocaster"></a>Fender Stratocaster</h3><p><img src="/passages/Meeting-electric-guitar/Strat.png" alt="Fender Stratocaster"><br>这是一把墨西哥产的吉他，俗称“墨芬”。因为上面两把我也没注意是什么“芬”，而且看价格上来说好像也没这么贵，而且老板看我弹了这个爱不释手的样子也一直在极力推荐这款，所以这把给我的感觉是最好的。<br>其实我就是冲着Straocaster来的。因为看了一些测评视频觉得，Strat适合的演奏风格比Tele的风格更广泛一些，毕竟有5档拾音器调节。而且从设计上来说，Strat比Tele更现代更时尚一些。就美芬、日芬、墨芬来说，个人觉得墨芬还是不错的。美芬就很贵，当然音色上应该会更有芬味；日芬外形比较漂亮，价格比墨芬稍贵，音色具有现代感但是，看了一些视频发现音色偏绵软不够有芬味；墨芬是墨西哥产，但质量也还可以，价格也没有那么贵，音色的芬味也比较浓吧，至少我弹的时候就觉得（尤其是拾音器开到最后一档，音色最亮那档），非常funky而且有一种slap的感觉，很有冲击力；拾音器调到前面档位，音色也很温暖，试着弹了一下John Mayer的几首（<em>I’m gonna find another you</em>，<em>I don’t trust myself(with loving you)</em>，<em>Slow dancing in a burning room</em>，<em>The heart of life</em>），真的是用软件调半天也很难调出这样的音色啊（可能是我不会）。<br>这把Strat的音色试弹的适合真的惊艳到我了！作为一个没有弹过电吉他的新手，我在弹的过程中还是能感受到一些音色上的差别的。Epiphone就很暖，Tele偏亮吧，因为那把我好像没有弹…Strat可暖可亮，怪不得大家都这么喜欢它。</p><h3 id="Fender-Squier"><a href="#Fender-Squier" class="headerlink" title="Fender Squier"></a>Fender Squier</h3><p>这个就不上图了，长的和Strat差不多   </p><p>弹完墨芬再来弹Squier，我的感受可想而知。关键是它的墨芬很新，无论是外形还是琴弦；但是Sq就很旧看起来，弦也生锈生的惨不忍睹，估计是放太久也没人买也没人弹过。弹起来手感无法形容，真实的烧火棍的感觉。</p><h2 id="音箱"><a href="#音箱" class="headerlink" title="音箱"></a>音箱</h2><p>音箱吉他音色的除了吉他本身，还有一个很重要的因素就是音箱，因此，我也试了两款不同的音箱。<br>用清音测试，才能看出吉他的好坏。所以我主要都是用清音测的；后来也试了一些其它音色，chorus、delay、octave、tremolo、vibrato这几个，感觉Fender的箱头还是不错的，而且Fender吉他配Fender音箱，当然也可以很好地体现出芬达的音色。</p><h3 id="Fender"><a href="#Fender" class="headerlink" title="Fender"></a>Fender</h3><p>最开始就用这个测试的。因为它是个40W的算是稍大一点的功率，并且箱头自带了很多音色，开始老板就是用这个秀了一下他的Tele。<br>前面感觉还好吧</p><h3 id="Laney"><a href="#Laney" class="headerlink" title="Laney"></a>Laney</h3><p>这款没有那么丰富的音色，应该说就没什么音色。除了清音就一个失真，增加cranch旋钮来实现。</p><p>总之，电吉他就像是一个新世界，电吉他之于木吉他就像是小女孩学会了化妆，可以实现很丰富的音色。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Meeting-electric-guitar/#disqus_thread</comments>
    </item>
    
    <item>
      <title>安迪·沃霍尔的哲学</title>
      <link>https://gitplayb.github.io/passages/Andy-Warhol/</link>
      <guid>https://gitplayb.github.io/passages/Andy-Warhol/</guid>
      <pubDate>Sun, 16 Feb 2020 06:34:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;这是一本关于波普艺术家&lt;strong&gt;&lt;a href=&quot;https://www.warhol.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安迪·沃霍尔&lt;/a&gt;&lt;/strong&gt;的传记，这个曾经创造了无数经典形象的男人–毛泽东、玛丽莲梦露、可口可乐….每个人都有自己的生活哲学，不可能看到某本“哲学”书籍就全盘拿来主义。但是，安迪确实是挺有意思的一个人，书中比较特别的一些观点值得记录一下。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是一本关于波普艺术家<strong><a href="https://www.warhol.org/" target="_blank" rel="noopener">安迪·沃霍尔</a></strong>的传记，这个曾经创造了无数经典形象的男人–毛泽东、玛丽莲梦露、可口可乐….每个人都有自己的生活哲学，不可能看到某本“哲学”书籍就全盘拿来主义。但是，安迪确实是挺有意思的一个人，书中比较特别的一些观点值得记录一下。</p><a id="more"></a><p>以序言中的一句话开始：</p><blockquote><p>事实上，学会想事情的方法比弄清楚一个事情的概念，不知道要重要多少。</p></blockquote><p>译者序里，Lou Reed在<em>Drella‘s song</em>的<em>Work</em>中唱到：</p><blockquote><p>Sometimes I can’t decide what I should do</p><p>I think what would Andy have said</p><p>He’d probably say you think too much</p><p>That’s cause there’s work that you don’t want to do</p><p>It’s work, the most important thing is work</p><p>Work, the most important thing is work</p></blockquote><h2 id="B和我"><a href="#B和我" class="headerlink" title="B和我"></a>B和我</h2><p>第一章 是他和他的朋友B(Brigid Berlin)的对话，每天早上他都会和B通话。</p><blockquote><p>People are always calling me  a mirror, and if a mirror looks into a mirror, what is there to see?</p><p>- 当我看着镜子，我只知道我看到的自己跟别人看到的不同。</p><p>- 因为我看待自己的方式，是我想看到的自己。我只为我自己做那些表情。我不会去做那些别人看得到我做的表情。我不会扭着嘴唇说：“钱呢？”</p></blockquote><p>安迪这么形容在镜子中的自己：</p><blockquote><p>那无动于衷的凝视，那流溢散发的优雅……</p><p>那百无聊赖的疲倦，那衰弱乏力的苍白……</p><p>那时髦别致的古怪，那听天由命的惊异，那隐秘诱人的知识……</p><p>那廉价庸俗的欢乐，那渴望启示的神情，那粉白淘气的面具，那有点斯拉夫人的长相……</p><p>那孩子般的、嚼着口香糖式的天真，那根源于绝望的魅力，那孤芳自赏的漫不经心，那彻头彻尾的另类，那纤弱飘忽，那朦胧的、窥探式的、暧昧的不详光晕，那孱弱、谈吐温文的奇妙风度，那皮与骨……</p><p>那…粉白皮肤，那…膝盖，那…双唇</p></blockquote><p>这段原文：</p><blockquote><p>The affectless gaze, the <strong>diffracted</strong> grace…</p><p>The bored <strong>languor</strong>, the wasted <strong>pallor</strong>…</p><p>The chick freakiness, the basically passive astonishment, the <strong>enthralling</strong> secret knowledge…</p><p>The <strong>chintzy</strong> joy, the <strong>revelatory</strong> <strong>tropisms</strong>, the <strong>chalky</strong>, <strong>puckish</strong> mask, the slightly Slavic look…</p><p>The childlike gum-chewing <strong>naivete</strong>, the glamour rooted in despair, the self-admiring carelessness, the perfected otherness, the <strong>wispiness</strong>, the shadowy, <strong>voyeuristic</strong>, vaguely <strong>sinister</strong> aura, the pale, soft spoken magical presence, the skin and bones…</p></blockquote><p>关于uniforms，他说：</p><blockquote><p>人最好永远穿着同一套衣服，这样就能知道大家喜欢你是因为真正的你，而不是衣着所造就的那个你。</p><p>Anyway, it’s more exciting to see where people live than what they wear.</p></blockquote><p>他也喜欢牛仔裤，</p><blockquote><p>I wish I could invent something like bluejeans. Something to be remembered for. Something mass.</p><p>I want to die with my bluejeans on.</p></blockquote><p>他小时候得过好几次<em>风湿性舞蹈症</em>，有点像多动症。</p><blockquote><p>一个人不化妆的时候，看起来最让人想亲吻。玛丽莲的双唇不属于令人想亲吻的唇，却非常适合拍照。</p></blockquote><p>安迪开始租房时甚至找不到一个可以谈心的室友（他们只是觉得找到了一个可以分摊房租的人），但是后来他和很多人一起合租过了，这些人反而开始追着他开始诉说了。</p><blockquote><p>As soon as you stop wanting something you get it. I’ve found that to be absolutely axiomatic.</p><p>一旦你不再想要某个东西，你就会得到它。</p></blockquote><h2 id="爱-衰老期（Senility）"><a href="#爱-衰老期（Senility）" class="headerlink" title="爱-衰老期（Senility）"></a>爱-衰老期（Senility）</h2><blockquote><p>The most exciting thing is <strong><em>not-doing-it</em></strong>. </p><p>If you fall in love with someone and never do it, it’s much more exciting.</p></blockquote><p>下面这句说的很真实，或许有点过于现实了</p><blockquote><p>Love affairs get too involved, and they’re not really worth it. But if, for some reason, you feel that they are, you should put in exactly as much time and energy as the other person. In other words, <strong><em>“I’ll pay you if you pay me”</em></strong>.</p></blockquote><blockquote><p>Fantasty love is much better than reality love. Never doing it is very exciting. </p><p>The most exciting attractions are between two opposites that never meet.</p></blockquote><p>到底什么才是爱情的样子：是双方精确计算的对等付出？还是真爱一方不计代价的给予？或许真正爱了才知道…安迪的话也不错，从一个非常聪明也非常worldly的人口中说出</p><p>关于长久的亲密关系，他说</p><blockquote><p>I wonder if it’s possible to have a love affair that lasts forever. If you’re married for thirty years and you’re “cooking breakfast for the one you love” and he walks in, does his heart really skip a beat? I mean just a regular morning. I guess it skips a beat over that breakfast and that’s nice, too. It’s nice to have a little breakfast made for you.</p></blockquote><p>关于Couples</p><blockquote><p>Couples do become like each other when they’re toghther for a long time, because you like the person and you pick up their mannerisms and their little good habits. And you eat the same food.</p></blockquote><p>好像是的，两个人在一起久了就是会有这种“夫妻相”，身体或精神上都会有。</p><p>这段描述真的很有意思：</p><blockquote><p>I get very nervous when I think someone is falling in love with me. Every time I have a “romance” I’m so nervous I bring the whole office with me. That’s usually about five or six people. They all come to pick me up and then we go to pick her up. Love me, love my office.</p><p>Everybody winds up kissing the wrong person good-night. One of my ways of thanking the office for coming with me to chapterone is to make myself available to chapterone with their dates. One or two of them like to take advantage of that service, because one or two of them are a little like me, they don’t want anything to happen. When <em>I’m</em> there, they tell me, nothing happens. <strong>I make nothing happen.</strong> Wherever I go. I can tell when one of them is glad to see me walk in the door, because something is happening and they can’t wait for me to make nothing happen. Especially when they’re <strong>stranded</strong> in Italy, because you know how the Italians like to make something happen. I’m the obvious <strong>antidote</strong>.</p></blockquote><p>Andy关于“爱”的说法：</p><blockquote><p>People should fall in love with their eyes closed. Just close your eyes. Don’t look.</p></blockquote><p>换句话说，当你不确定爱不爱一个人的时候，用心去判断，而不是眼睛。</p><p>关于美人（beauties），他这么说</p><blockquote><p>I really don’t care that much about “Beauties”. What I really like are Talkers. To me, good talkers are beautiful because good talk is what I love. The word itself shows why I like Talkers better than Beauties, why I tape more than I film. It’s not “talkies”. <strong><em>Talkers are doing something. Beauties are being something.</em></strong> Which isn’t necessarily bad, it’s just that I don’t know what it is that they’re being. It’s more fun to be with people who are doing things.</p></blockquote><p>可能也是因为他是脱口秀主持人的原因，他对Talkers更欣赏。</p><p>美与暴力</p><blockquote><p>Some people, even intelligent people, say that violence can be beautiful. I can’t understand that, because beautiful is some moments, and for me those moments are never violent.</p></blockquote><p>不同就是美（因为不同首先会被注意到）。</p><blockquote><p>Sometimes something can look beautiful just because it’s different in some way from the other things around it. One red <strong>petunia</strong> in a window box will look very beautiful if all the rest of them are white, and vice versa.</p></blockquote><h2 id="名利（Fame"><a href="#名利（Fame" class="headerlink" title="名利（Fame)"></a>名利（Fame)</h2><blockquote><p>When you just see somebody in the street, they can really have an <strong><em>aura</em></strong>. But then when they open their mouth, there goes the aura. “Aura” must be until you open your mouth.</p></blockquote><p>每个人的“光环”，都在他开口后消失（或出现）。</p><p>这个解释了安迪想出名的原因（据说他是为了出名可以不顾一切）</p><blockquote><p>A good reason to be famous, though, is so you can read all the big magazines and know everybody in all the stories. Page after page it’s just all people you’ve met. I love that kind of reading experience and that’s the best reason to be famous.</p></blockquote><p>关于TV Magic，或者说“上台不怯场”效应</p><blockquote><p>Certain people have TV magic: they fall completely apart off-camera but they are completely together on-camera. They shake and sweat before they go on, they shake and sweat during commercials, they shake and sweat when it’s all over; but while the camera is filming them, they’re <strong>poised</strong> and confident-looking. The camera turns them on and off.</p></blockquote><p>他也说了他自己并不是那种拥有TV Magic的人</p><blockquote><p>I never fall apart because I never fall together. … I can’t think about anything that’s going to come out of my mouth. “I’m going to faint”.</p></blockquote><p>这么看来安迪也不是那么神乎其神，普通人有的上台焦虑他也会有。想起了自己小时候每当到了台上（比如班里的讲台上）也会不由自主地发抖，是那种身体有轻微的发抖（可以控制的），但是语言能不能正常的说出来就由不得我了。开始以为<em>视力变差</em>会改善这个状况，因为这样就不用和台下乌压压的一片观众有眼神交流了；但是后来发现，视力真的变差了，然而自己会因为无法和台下的观众有眼神交流而变成一个arbitrary的演讲者，即不管自己讲的好坏（自认为还是好的），放飞自我了。这样产生的问题就是无法抓住观众的注意力，引导其进行思考，无法掌握一个更好的节奏感。</p><p><strong>WHAT YOU’RE WORTH</strong></p><blockquote><p>So you should always have a product that’s not just “you”. An actress should count up her plays and movies and a model should count up her photographs and a writer should count up his words and an artist should count up his pictures so you always know exactly what you’re worth, and you don’t get stuck thinking your product is you and your fame, and your aura.</p></blockquote><h2 id="工作（Work）"><a href="#工作（Work）" class="headerlink" title="工作（Work）"></a>工作（Work）</h2><blockquote><p>An actress friend told me that after she didn’t want money and jewels anymore, that’s when she got money and jewels. I guess it’s for our own good that it always happens that way, because after you stop wanting things is when having them won’t make you go crazy.</p></blockquote><p>当我们<strong><em>非常</em></strong>想要一个东西的时候（过程中），如果我们得到了它，那我们可能会疯掉（比如，突然中了五百万）；也即，如果我们能理智的想要一个东西，或者说得到那个东西我们有办法handle，那时候才是得到那个东西的最佳时机。</p><blockquote><p>Wherever it’s possible, you should try to pay people in measurements that are the most suitable for their talent or job. A writer may want to get paid by the word, by the page, by the number of times the reader breaks down crying or bursts out laughing, by the chapter, by the number of new ideas introduced, by the book, or by the year, just to name a few possible categories. A director may want to get paid by the movie or by the foot or by the number of times a Chevrolet appears in the frames.</p></blockquote><p>每个人做的事情（就工作而言）都可以用特定的尺度来衡量，确定其价值。</p><h2 id="时间（Time）"><a href="#时间（Time）" class="headerlink" title="时间（Time）"></a>时间（Time）</h2><blockquote><p>If the lines on your hands are wrinkles, it must mean your hands worry a lot. </p></blockquote><p>手就像脸一样，操心越多，皱纹越多</p><blockquote><p>They always say that time changes things, but you actually have to change them yourself.</p><p>他们总是说时间会改变一切，但事实上你得自己去改变它们。</p></blockquote><p><strong>About Time</strong></p><p><code>From time to time | Do time | Time yourself | weekends | In time | In no time | In good time | Between time | Time and again | Lifetime | Time-worn | Pass time | Mark time | Buy time | Keep time | On time | In time | Time off | Time out | Time in | Time card | Time lapse | Time zone | The beforetime | The meantime | The aftertime | The All-time</code></p><h2 id="死亡（Death）"><a href="#死亡（Death）" class="headerlink" title="死亡（Death）"></a>死亡（Death）</h2><p>每个人面对死亡的时候可能会不知所措，尤其是对于一些意外事件（废话，当然了）。</p><h2 id="环境（Atmosphere）"><a href="#环境（Atmosphere）" class="headerlink" title="环境（Atmosphere）"></a>环境（Atmosphere）</h2><blockquote><p>I‘m impressed with people who can create new spaces with the right words. I only know one language, and sometimes in a middle of a sentence I feel like a foreigner trying to talk it because I have word <strong>spasms</strong> where the parts of some words begin to sound peculiar to me and in the middle of saying the  word I’ll think, “Oh, this can’t be right–this sounds very peculiar, I don’t know if I should try to finish up this word or try to make it into something else, because if it comes out good it’ll be right, but if it comes out bad it’ll sound <strong>retarded</strong>, and so in the middle of words that are over one syllable, I sometimes get confused and try to <strong>graft</strong> other words on top of them. Sometimes this makes good jounalism and when they quote me it looks good in print, and other times it’s very embarrassing. You can never predict what will come out when the words you’re saying start to sound strange to you and you start to patch.”</p></blockquote><p>说话的时候临场发挥有可能大放异彩，也有可能尴尬收场。</p><blockquote><p>The best atmosphere I can think of is film, because it’s three-dimensional phiscally and two-dimensional emotionally.</p></blockquote><p>最好的环境是电影，因为电影实际上是三次方的立体空间，但情感上是二次方的平面空间。</p><h2 id="刺（The-Tingle）"><a href="#刺（The-Tingle）" class="headerlink" title="刺（The Tingle）"></a>刺（The Tingle）</h2><blockquote><p>My mind is like a tape recorder with one button – Erase</p><p>我的心智像一部只有单键的录音机–消除键</p></blockquote><blockquote><p>Maybe the reason my memory is so bad is that I always do at least two things at once. It’s easier to forget something you only half-did or quater-did.</p><p>也许我的记忆力坏成这样，是因为我老是一心最少二用。如果你只花一半或者四分之一的力气做事，自然比较容易忘东忘西。</p></blockquote><p>当安迪每天与他的B们打电话的时候，最常说的一句是：</p><blockquote><p>What’s new? 有啥新鲜事？</p></blockquote><h2 id="后记（Afterword）"><a href="#后记（Afterword）" class="headerlink" title="后记（Afterword）"></a>后记（Afterword）</h2><p>其实这本书给我的感觉就像是去了解一个特别的人，因为之前对安迪·沃霍尔也不太了解。所以，了解一个人的最好方式就是找到一个他最能表现出自我的媒介，比如他写的书、说的某些话、做的事情等。</p><p>读了中文版，也和原文对照着看了下，发现安迪是一个很聪明很世故对出名充满了强烈的渴望的人，他作为波普艺术的创立者，确实是有才华的。不过他也是普通人，也会在生活中遇到和普通人一样的问题，只不过他看待问题的方式确实有些特别。看到了最后几章，尤其是The Tingle，里面是他和朋友B打电话，B在收拾东西，然后接下来开始了朋友对自己正在收拾区域的描述：抽屉、桌子、壁橱、吸尘器扫地等等。真的就是通篇不分段然后一种碎碎念的感觉，很难看下去，So，That’s all.</p><p><strong><u>关于安迪的一些图片</u></strong></p><p>自画像1</p><p><img src="/passages/Andy-Warhol/Andy_Warhol.jpg" alt="Andy_Warhol"></p><p>The Rolling Stones乐队主唱Mick Jagger</p><p><img src="/passages/Andy-Warhol/1997-1-8b_pub_01-Web-Ready-475px-longest-edge-Check-Copyright-Before-Using-on-Web-475x472.jpg" alt="Mick Jagger"></p><p>可口可乐</p><p><img src="/passages/Andy-Warhol/1997-1-20_pub_01-Web-Ready-475px-longest-edge-Check-Copyright-Before-Using-on-Web-352x475.jpg" alt="Coca-Cola"></p><p><em>Edie Sedgwick</em> 伊迪·塞奇威克–工厂里的女孩，他的书里也提到过</p><p><img src="/passages/Andy-Warhol/1997-4-113-305_pub_01-PowerPoint-Ready-1000px-longest-edge-internal-use-only-475x350.jpg" alt="Edie Sedgwick"></p><p>Andy、Nico和The Velvet Underground乐队的Lou Reed</p><p><img src="/passages/Andy-Warhol/1998-3-4563_pub_02-Web-Ready-475px-longest-edge-Check-Copyright-Before-Using-on-Web-378x475.jpg" alt="The Velvet Underground"></p><p>坐着的裸体男子Torso</p><p><img src="/passages/Andy-Warhol/1998-1-1692_pub_01-Web-Ready-475px-longest-edge-Check-Copyright-Before-Using-on-Web-315x475.jpg" alt="Seated Male Nude"></p><p>投麦高文（Vote McGovern）–关于投票选总统这里书中也有提到</p><p><img src="/passages/Andy-Warhol/1998-1-2399_pub_01-Web-Ready-475px-longest-edge-Check-Copyright-Before-Using-on-Web-473x475.jpg" alt="Vote McGovern"></p><p>自画像2</p><p><img src="/passages/Andy-Warhol/1998-1-814_pub_01-Web-Ready-475px-longest-edge-Check-Copyright-Before-Using-on-Web-474x475.jpg" alt="Self-Portrait"></p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Andy-Warhol/#disqus_thread</comments>
    </item>
    
    <item>
      <title>权力的游戏（GOT）</title>
      <link>https://gitplayb.github.io/passages/The-Game-of-Throne/</link>
      <guid>https://gitplayb.github.io/passages/The-Game-of-Throne/</guid>
      <pubDate>Mon, 10 Feb 2020 14:23:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;找了个时间，终于把这部非常经典的美剧刷完了。虽然刷的比较浮躁（1.5X倍速➕快进），因为实在是太长了，但是看的还是很热血沸腾的（除了最后一季）。记录一下，不枉花费了这么多时间。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>找了个时间，终于把这部非常经典的美剧刷完了。虽然刷的比较浮躁（1.5X倍速➕快进），因为实在是太长了，但是看的还是很热血沸腾的（除了最后一季）。记录一下，不枉花费了这么多时间。</p><a id="more"></a><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="/passages/The-Game-of-Throne/image-20200207123700103.png" alt="image-20200207123700103"></p><p>原来John Ayron，也就是Sansa的Aunt Lysa，和小手指（Lord Ballish）搞在一起了，把自己丈夫毒死。。。。这女的也是个slut。</p><p>Lord Varys（瓦里斯），也就是那个太监说</p><blockquote><p>Besides, the absence of desire leaves one free to pursue other things.</p><p>此外，人若不为欲念驱使，便能放开手脚追求别的东西。</p></blockquote><p>比如，<strong>Throne</strong>，回归主题，<em>The Game of Thrones</em>。</p><p>Sansa的姨姨Lysa死的真惨，最后小手指走到她跟前跟她说，</p><blockquote><p>My sweet, silly wife, I have only loved one woman, </p><p>Only one, my entire life, your sister.</p></blockquote><p>看着Lysa脸上还傻笑着以为说的是自己呢……然后从moon door掉下去….</p><p><img src="/passages/The-Game-of-Throne/image-20200210214834715.png" alt="image-20200210214834715"></p><p>然后，更精彩的是，一直都不会撒谎的Sansa，为了这个唯一帮助过她的人（小手指），说了谎，本来我以为她要扯个大谎，没想到她说了很多真实的事情，然后顺带着把后面小手指故意推她姨妈下去直接说成了小手指过去安抚Lysa没安抚成反而她自己跳下去了….牛逼，第一次说谎都这么不露痕迹。</p><p><img src="/passages/The-Game-of-Throne/image-20200210215041574.png" alt="image-20200210215041574"></p><p><img src="/passages/The-Game-of-Throne/image-20200210215105908.png" alt="image-20200210215105908"></p><p>John Snow喜欢的这个红发女野人，死得也好惨。</p><p><img src="/passages/The-Game-of-Throne/image-20200210215139196.png" alt="image-20200210215139196"></p><p>死前还是一直说着那一句，“You know nothing, John Snow”</p><p>小恶魔出去后看到Shae，两人打斗一番又把Shae勒死了？？。。。</p><p>是Shae从小恶魔那次对她说狠话然后她以为他不爱她了，之后还在审判小恶魔的时候撒谎说他确实杀了Joffery，然后彻底变了吗？</p><p><img src="/passages/The-Game-of-Throne/image-20200210215551958.png" alt="image-20200210215551958"></p><p>噢，Imp杀了他父亲是因为他父亲和Shae，他心爱的妓女上床了。</p><p>一开始的这两个小女孩，去见女巫询问她们的未来，竟然是Cerci。</p><p><img src="/passages/The-Game-of-Throne/image-20200207112356107.png" alt="image-20200207112356107"></p><p>怪不得要回忆呢，因为上一季第十集泰温·兰尼斯特被小恶魔用箭射死了。</p><p><img src="/passages/The-Game-of-Throne/image-20200207115828381.png" alt="image-20200207115828381"></p><p>又开始爆料了，这个男的，Cerci的表弟Lancel，曾经和她有一腿，而且Robert喝醉了酒然后去打猎被野猪撞死的事情也有参与，酒可能下了毒或者让人醉的不轻的东西。</p><p><img src="/passages/The-Game-of-Throne/image-20200207114626772.png" alt="image-20200207114626772"></p><p>这个是Braavos的人都会这么说吗，而且是第一个人说<em>凡人皆有一死</em>，然后后一个人说<em>凡人必须侍奉</em>。</p><p><img src="/passages/The-Game-of-Throne/image-20200207120139712.png" alt="image-20200207120139712"></p><p>红发女巫想调戏John Snow的时候，雪诺控制住了自己的冲动。然后，梅丽珊卓竟然对他说了这句话，这句Yiggrett一直对他说的。</p><p><img src="/passages/The-Game-of-Throne/image-20200207120400140.png" alt="image-20200207120400140"></p><p>是的。</p><p><img src="/passages/The-Game-of-Throne/image-20200207120619147.png" alt="image-20200207120619147"></p><p>在和石头人打斗过程中，乔拉·莫尔蒙爵士杀了好几个，因为和他们接触了，所以染上了灰鳞病（GreyScale），看起来好恶心</p><p><img src="/passages/The-Game-of-Throne/image-20200207121126408.png" alt="image-20200207121126408"></p><p>太后Cerci原本想整治Tyrell一家，派出一个<em>独立于皇室的机构</em>（教会？），以通奸同性恋等罪名把城里的各种乱七八糟的人都抓起来，包括皮提尔开的妓院和玛格丽皇后的哥哥洛里斯，结果最后把自己给套进去了。由此可见，这真的是权力的游戏了，所以，到底什么样的人才是掌握权力的人？</p><p><img src="/passages/The-Game-of-Throne/image-20200207121946295.png" alt="image-20200207121946295"></p><p>小恶魔还真的是一个睿智的人。。说的话是最有哲理的。</p><p>Cerci忏悔</p><p><img src="/passages/The-Game-of-Throne/image-20200207122324053.png" alt="image-20200207122324053"></p><p><img src="/passages/The-Game-of-Throne/image-20200207103704947.png" alt="image-20200207103704947"></p><p>权力的游戏：民众团结起来，就没王权什么事了。关键是那种稀巴烂的王权</p><p><img src="/passages/The-Game-of-Throne/image-20200207103820358.png" alt="image-20200207103820358"></p><p>Arya到底什么时候才能变成<strong>无名之辈</strong>?</p><p><img src="/passages/The-Game-of-Throne/image-20200207103940142.png" alt="image-20200207103940142"></p><p>梅姨真的好美啊</p><p><img src="/passages/The-Game-of-Throne/image-20200207104023730.png" alt="image-20200207104023730"></p><p><img src="/passages/The-Game-of-Throne/image-20200207104151289.png" alt="image-20200207104151289"></p><p>弥桑黛还挺聪明的，小恶魔给了个眼神就知道怎么说了。</p><p><img src="/passages/The-Game-of-Throne/image-20200207104325864.png" alt="image-20200207104325864"></p><p>龙妈再次深陷多斯拉克人阵营中，用一把火解决了，不愧是龙妈。</p><p><img src="/passages/The-Game-of-Throne/image-20200207104901780.png" alt="image-20200207104901780"></p><p>这家伙（森林之子）创造了异鬼（White Walkers）？</p><p><img src="/passages/The-Game-of-Throne/image-20200207104953007.png" alt="image-20200207104953007"></p><p>Ser Jorah对龙妈的爱真的很深，自己被放逐两次又两次回到她身边，最后又救了她，还因此染上了灰鳞病，最终又不得不离开她，哎…</p><p><img src="/passages/The-Game-of-Throne/image-20200207105349439.png" alt="image-20200207105349439"></p><p>这舞台剧真的好浮夸，不过真的搞笑。</p><p><img src="/passages/The-Game-of-Throne/image-20200207105610639.png" alt="image-20200207105610639"></p><p>自从某次Cerci给托曼讲了这句话后，再加上他被玛格丽皇后以及High Sparrow洗脑后，他每次都会说这个。Faith指的就是神、教会；Crown指的就是王权。    </p><ul><li>Ramsy死的真是大快人心，被自己的猎狗撕碎。</li><li>审判Cerci，她没来，然后把囤积的野火一次全点燃，君临的宫殿被她直接炸掉了。</li><li>Arya用易容术把Walder Frey的儿子杀了，并把他们做成肉饼送给他们的爹，revengence真棒。</li></ul><p><strong>John Snow真实身份</strong></p><p>John Snow竟然不是艾德·斯塔克的私生子！他实际上是艾德的妹妹–Lynna Stark和雷加（也就是龙妈哥哥）的儿子，为了保护雪诺，艾德说他是自己的私生子。Bran通过幻视看到了这个。</p><p><img src="/passages/The-Game-of-Throne/image-20200207110820387.png" alt="image-20200207110820387"></p><p>这小女孩，Lady Morment，灰熊家族的首领，真的被圈粉了！</p><p>有个点比较好奇，东南西北各个方向的领土版图似乎不小，各个角落发生了什么大事消息传的真是挺快的，就只是通过乌鸦传信？动不动就SEND THE RAVENS:thinking:</p><p>Samwell Tarly在图书馆跟着师傅解剖人体的时候，太恶心了。</p><p><img src="/passages/The-Game-of-Throne/image-20200204213342047.png" alt="image-20200204213342047"></p><p>乱入的Ed Sheeran？？？</p><p><img src="/passages/The-Game-of-Throne/image-20200207092921034.png" alt="image-20200207092921034"></p><p>这个故事对雪诺的设定就是Brooding，老是沉思，或者说郁闷。    </p><p><img src="/passages/The-Game-of-Throne/image-20200207093050342.png" alt="image-20200207093050342"></p><p>Imp还真是上瘾了，用了一次觉得不错就每次都用这个，A wise man once said。</p><p>搞笑的是，说完就被龙妈问住了，which wise man said this?</p><p><img src="/passages/The-Game-of-Throne/image-20200207093155060.png" alt="image-20200207093155060"></p><p>Three-eyed raven，三眼乌鸦，可以看到所有事，这个真的是厉害。</p><p><img src="/passages/The-Game-of-Throne/image-20200207093820730.png" alt="image-20200207093820730"></p><p>搞得像敦煌壁画似的，这不比书本上的真实？</p><p><img src="/passages/The-Game-of-Throne/image-20200207094350225.png" alt="image-20200207094350225"></p><p>这才是<strong>真·权力的游戏</strong></p><p><img src="/passages/The-Game-of-Throne/image-20200207095519244.png" alt="image-20200207095519244"></p><p>Sam看那些大学士都不相信真的又异鬼后，觉得再待下去并没什么卵用，等到异鬼入侵该死还得死，所以他觉得不能坐视不管，还是回去微妙，走的时候带走了几本书。</p><p><img src="/passages/The-Game-of-Throne/image-20200207095617693.png" alt="image-20200207095617693"></p><p>带着一帮能打的汉子抓白鬼，太刺激了</p><p><img src="/passages/The-Game-of-Throne/image-20200207100000249.png" alt="image-20200207100000249"></p><p>妈耶夜王这一个标枪投的直接干掉一条龙…</p><h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><p>为啥雪诺被他叔叔Benjo骑马相救后，不能两人一块骑马离开？还要Benjo断后？明明可以一块走的啊？</p><p><img src="/passages/The-Game-of-Throne/image-20200207100309648.png" alt="image-20200207100309648"></p><p>雪诺和龙妈，患难见真情</p><p><img src="/passages/The-Game-of-Throne/image-20200207100626463.png" alt="image-20200207100626463"></p><p>Arya的剑术以及格斗技巧可以说是炉火纯青了，和Brinne练习的时候，不敢说Brinne使用了100%的实力，她也很认真的在和Arya打，但是Arya真的挺厉害的，几乎可以把她制服了。</p><p><img src="/passages/The-Game-of-Throne/image-20200207101006310.png" alt="image-20200207101006310"></p><p>好像有很多类似的场景是，两个人对骂垃圾话，尤其是涉及小恶魔的，因为他比较聪明，说话也富含哲理，而且也日常被喷（侏儒啊杀父啊）。</p><p><img src="/passages/The-Game-of-Throne/image-20200207101146889.png" alt="image-20200207101146889"></p><p>这就是主题呗，伟大的“国王之手”就是要做这个，不是傻傻的忠诚而是，为了国家和人民的利益。</p><p><img src="/passages/The-Game-of-Throne/image-20200207101749978.png" alt="image-20200207101749978"></p><p>Jamie这个角色塑造的真的挺好的，让人不由得喜欢，到最后因为Cerci说了要和雪诺龙妈一起打异鬼之后准备出军的时候，Cerci竟然说那只是她对她们的权宜之计，说说而已，他还是毅然决定要遵守诺言，出兵北上。</p><p><img src="/passages/The-Game-of-Throne/image-20200207103012432.png" alt="image-20200207103012432"></p><p>Cerci竟然让Boronn爵士北上，如果他的兄弟们（Jamie和小恶魔）死了就算了，没死的话搞死他们。</p><p>这个<strong>疯女人</strong>….</p><p><img src="/passages/The-Game-of-Throne/image-20200207103046985.png" alt="image-20200207103046985"></p><p>这句话也是一直出现在IronBorn铁群岛的人中。</p><p><img src="/passages/The-Game-of-Throne/image-20200207103213487.png" alt="image-20200207103213487"></p><p>龙妈这样真的好美！银发和雪白的背景</p><p><img src="/passages/The-Game-of-Throne/image-20200207103305183.png" alt="image-20200207103305183"></p><p>感觉这样龙有表情了呢</p><p><img src="/passages/The-Game-of-Throne/image-20200204202505729.png" alt="image-20200204202505729"></p><p>小恶魔说话我真是服。。</p><p><img src="/passages/The-Game-of-Throne/image-20200204202644553.png" alt="image-20200204202644553"></p><p>太帅了小熊女:sob:</p><p><img src="/passages/The-Game-of-Throne/image-20200204202727843.png" alt="image-20200204202727843"></p><p>没怎么完整听完片尾曲，为了快点追完八季。听到这一集的主题曲，真的听哭了。</p><p><img src="/passages/The-Game-of-Throne/image-20200204202856986.png" alt="image-20200204202856986"></p><p><img src="/passages/The-Game-of-Throne/image-20200204202930393.png" alt="image-20200204202930393"></p><p><img src="/passages/The-Game-of-Throne/image-20200204202930393.png" alt="image-20200204202948709"></p><p>红发女祭司梅丽珊卓又来助阵了，咒语点火牛逼。</p><p><img src="/passages/The-Game-of-Throne/image-20200204204925437.png" alt="image-20200204204925437"></p><p>看到这画面我想起个词：驯龙高手。雪诺和龙妈一人一个，太赞了。</p><p><img src="/passages/The-Game-of-Throne/image-20200204205124247.png" alt="image-20200204205124247"></p><p>夜王也是不焚之身，我佛了。</p><p>夜王被Arya一把小刀杀了，厉害:+1:</p><p><img src="/passages/The-Game-of-Throne/image-20200204205719106.png" alt="image-20200204205719106"></p><p>Bran自从变成了三眼乌鸦，就成了智者的形象，之前还是有点懵懂的小男孩。</p><p><img src="/passages/The-Game-of-Throne/image-20200204205902058.png" alt="image-20200204205902058"></p><p>小恶魔胆子真是挺大的，这就是赌啊，赌他姐姐会不会杀他。</p><p><img src="/passages/The-Game-of-Throne/image-20200204210615872.png" alt="image-20200204210656089"></p><p>整部剧尤其是到了最后，就是在一直boost人们的愤怒值。所以，尽管兰尼斯特鸣钟投降，但是龙妈继续骑龙喷火，他的Unsullied们看到了也开始杀那些已经要投降的战士们。</p><p><img src="/passages/The-Game-of-Throne/image-20200204210736357.png" alt="image-20200204210736357"></p><p>躲避战火的小女孩</p><p><img src="/passages/The-Game-of-Throne/image-20200204210836581.png" alt="image-20200204210836581"></p><p>Jamie到最后时候还去救那个疯女人，不过还好，杀了Cerci的另一个男人，和瑟曦死在了一起。</p><p><img src="/passages/The-Game-of-Throne/image-20200204211013249.png" alt="image-20200204211013249"></p><p>魔山真的是个Monster</p><p><img src="/passages/The-Game-of-Throne/image-20200204211105300.png" alt="image-20200204211105300"></p><p>女疯子瑟曦害死了多少人….我只觉得Jamie真的不值，太傻了</p><p><img src="/passages/The-Game-of-Throne/image-20200204211143698.png" alt="image-20200204211143698"></p><p>这个视角不错，就像是龙妈长了翅膀一样</p><h3 id="WORDS"><a href="#WORDS" class="headerlink" title="WORDS"></a>WORDS</h3><blockquote><p>Love is more powerful than reason.  爱比理性更强大    –小恶魔</p><p>Love is the death of duty.    –伊蒙学士说的</p></blockquote><p><img src="/passages/The-Game-of-Throne/image-20200204211300113.png" alt="image-20200204211300113"></p><p>拍到了剧中，为了寻找一个更合理的结局，导演组们就这么简单粗暴地解决了龙妈，To make a better place/world.</p><p><img src="/passages/The-Game-of-Throne/image-20200204211354085.png" alt="image-20200204211354085"></p><p>龙妈的龙孩子恨不得把雪诺吞了，可是它（知道雪诺也是塔格利安后裔？）只是把火喷向了Iron Throne，熔化了它。</p><p><img src="/passages/The-Game-of-Throne/image-20200204195459697.png" alt="image-20200204195459697"></p><p>还和历史挺吻合，从继承制变成选举制。</p><p><img src="/passages/The-Game-of-Throne/image-20200204200829240.png" alt="image-20200204200829240"></p><p>这本书，Sam虽然没有参与写作，但是他给它起了一个<em>“富有诗意”</em>的名字–<strong>冰与火之歌</strong>，也算完成了自己的心愿。</p><p><img src="/passages/The-Game-of-Throne/image-20200204201251757.png" alt="image-20200204201251757"></p><p>这个称号确实太怪了–King Bran the Broken（还挺顺口）。</p><h2 id="一点感悟"><a href="#一点感悟" class="headerlink" title="一点感悟"></a>一点感悟</h2><h3 id="权力（power）"><a href="#权力（power）" class="headerlink" title="权力（power）"></a>权力（power）</h3><h3 id="国王之手（King‘s-hand"><a href="#国王之手（King‘s-hand" class="headerlink" title="国王之手（King‘s hand)"></a>国王之手（King‘s hand)</h3><h3 id="知识（大学士）"><a href="#知识（大学士）" class="headerlink" title="知识（大学士）"></a>知识（大学士）</h3><p>最典型的应该就是Samwell Tarley了，看书治好了Jorah爵士的灰鳞病，并且找到了对付异鬼的方法。</p><h4 id="大图书馆"><a href="#大图书馆" class="headerlink" title="大图书馆"></a>大图书馆</h4><h3 id="练兵场面"><a href="#练兵场面" class="headerlink" title="练兵场面"></a>练兵场面</h3><h3 id="治理国家"><a href="#治理国家" class="headerlink" title="治理国家"></a>治理国家</h3><p>靠武力还是威信？如何建立起威信，如何让你的人民因为你带给他们自由而追随你</p><h3 id="命运-个人发展"><a href="#命运-个人发展" class="headerlink" title="命运/个人发展"></a>命运/个人发展</h3><p>John Snow其实是Aegon Targaryen（伊耿·塔格利安），原本应是铁王座继承人的他诞生在一个非一般的环境中，这也磨练了他的意志，使他成长为一个King应该有的样子。</p><h3 id="夜王和布兰"><a href="#夜王和布兰" class="headerlink" title="夜王和布兰"></a>夜王和布兰</h3><p>夜王想消灭人类，而人类之所以为人类，是因为有记忆（memories），而记得这些东西的，不只是书本，更重要的是Bran，他可以看到过去和现在正在发生的一切事情，也就是说他拥有人类的所有记忆。所以，夜王的目标其实是Bran。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/The-Game-of-Throne/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Let&#39;s play some music</title>
      <link>https://gitplayb.github.io/passages/Let-s-play-some-music/</link>
      <guid>https://gitplayb.github.io/passages/Let-s-play-some-music/</guid>
      <pubDate>Mon, 30 Dec 2019 15:59:41 GMT</pubDate>
      <description>
      
        &lt;p&gt;前两天在网上搜索&lt;em&gt;安卓 合成器 qibrd&lt;/em&gt;等关键词时，搜到了一个叫做&lt;em&gt;NSynth Super&lt;/em&gt;的一个东西，然后发现，这是一个硬件接口，就是使用NSynth算法能够生成很多奇奇怪怪的声音，相当于一个用了高级算法的合成器。由于我只是想找个软件试验一下，于是在GitHub上搜了一下，结果找到了&lt;a href=&quot;https://github.com/googlecreativelab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;Google Creative Lab&lt;/em&gt;&lt;/a&gt;这个团队的一些有趣的项目（团队竟然只有8个人！），其中包括今天要介绍的主角–&lt;em&gt;Chrome-music-lab&lt;/em&gt;，链接：&lt;a href=&quot;https://github.com/googlecreativelab/chrome-music-lab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;https://musiclab.chromeexperiments.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前两天在网上搜索<em>安卓 合成器 qibrd</em>等关键词时，搜到了一个叫做<em>NSynth Super</em>的一个东西，然后发现，这是一个硬件接口，就是使用NSynth算法能够生成很多奇奇怪怪的声音，相当于一个用了高级算法的合成器。由于我只是想找个软件试验一下，于是在GitHub上搜了一下，结果找到了<a href="https://github.com/googlecreativelab" target="_blank" rel="noopener"><em>Google Creative Lab</em></a>这个团队的一些有趣的项目（团队竟然只有8个人！），其中包括今天要介绍的主角–<em>Chrome-music-lab</em>，链接：<a href="https://github.com/googlecreativelab/chrome-music-lab" target="_blank" rel="noopener">GitHub</a> | <a href="https://musiclab.chromeexperiments.com/" target="_blank" rel="noopener">官网</a>。</p><a id="more"></a><p>这个项目据网站介绍说是主要用于教学目的，因为比较简单，所以不太可能拿来真正的做音乐；但是其可操作性和UI的美观程度，真的让人一玩就停不下来<del>啊哈哈哈</del>。</p><h2 id="用绘画🎨来创造音乐"><a href="#用绘画🎨来创造音乐" class="headerlink" title="用绘画🎨来创造音乐"></a>用绘画🎨来创造音乐</h2><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"loop":true,"screenshot":true,"video":{"url":"/passages/Let-s-play-some-music/chorus.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>不过经过我多次尝试，发现好像最多只能画9个元素（可能是考虑到手机屏幕大小的原因）</p><h2 id="我的小妖怪👾们在打鼓"><a href="#我的小妖怪👾们在打鼓" class="headerlink" title="我的小妖怪👾们在打鼓"></a>我的小妖怪👾们在打鼓</h2><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"loop":true,"screenshot":true,"video":{"url":"/passages/Let-s-play-some-music/drums.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h2 id="一个简单的DAW📟"><a href="#一个简单的DAW📟" class="headerlink" title="一个简单的DAW📟"></a>一个简单的DAW📟</h2><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"loop":true,"screenshot":true,"video":{"url":"/passages/Let-s-play-some-music/song.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>总之，如果你想用音乐来<em>have some fun</em>，推荐赶紧去官网试试。不过我试了下，好像在电脑上打不开，可能只是为了手机用户设计的。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Let-s-play-some-music/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SPMIA</title>
      <link>https://gitplayb.github.io/passages/SPMIA/</link>
      <guid>https://gitplayb.github.io/passages/SPMIA/</guid>
      <pubDate>Sun, 22 Dec 2019 14:57:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;英文版&lt;em&gt;Spring Microservices in Action&lt;/em&gt;读书笔记。英文书的特点就是篇幅很长话很多，比较容易理解，适合初学者；但不好就是如果想要消化得好就读起来太慢&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>英文版<em>Spring Microservices in Action</em>读书笔记。英文书的特点就是篇幅很长话很多，比较容易理解，适合初学者；但不好就是如果想要消化得好就读起来太慢</p><a id="more"></a><h2 id="1-欢迎来到云的世界"><a href="#1-欢迎来到云的世界" class="headerlink" title="1 欢迎来到云的世界"></a>1 欢迎来到云的世界</h2><p><strong>什么是微服务</strong></p><ul><li>应用逻辑被拆分成很多组件，组件之间（功能/职责）界限分明，合作来完成一个项目</li><li>每个组件完成某一domain的小任务，可以独立部署。一个微服务应是可重用的。</li><li>组件之间基于一些原则进行通信——HTTP、JSON来进行数据交换</li><li>不关心用什么技术来实现（因为使用的是技术无关性的”协议“–JSON）</li><li>由于其小、独立、分布式的特点，这些微服务可以有很多个小团队实现</li></ul><p><strong>为什么可以用Spring来构建微服务</strong></p><p>Spring是一个基于<strong>依赖注入</strong>的框架，不同于传统的Java应用中通过硬编码（类之间的相互调用）的方式将类进行链接（带来的坏处就是一旦编译完，类间的链接关系就不能改变了），Spring采用的是<strong>将类间的依赖/链接关系外部化（externalize）</strong>，能够更好的管理依赖。</p><p>使用Spring Boot和Spring Cloud，我们可以更方便地开发分布式的微服务，并将它们部署到云上。</p><p><strong>读这本书你可以学到</strong></p><ul><li>什么是微服务，如何设计构建一个微服务</li><li>什么时候不应该使用微服务</li><li>如何使用Spring Boot来构建微服务</li><li>构建微服务应用（基于云的）有哪些可行的pattern</li><li>怎样用Spring Cloud实现那些patterns</li><li>如何构建一个<strong>deployment pipeline</strong>，用于将服务部署到私有/公有云上</li></ul><p><strong>为什么要采用微服务架构</strong></p><p>随着技术的发展，现代社会的方方面面都被互联网连接起来了。任何一款产品都可能面向全球的竞争者，开发者也遇到了更大的挑战：</p><ul><li><strong>复杂度上升</strong>——应用不再是单打独斗，往往需要和其他的应用进行交互。比如阿里的支付宝现在绝不仅仅只是一个手机支付的app，它甚至涵盖了出行的基本需要（需要用到钱的地方）</li><li><strong>客户想要快速交付</strong>——用户没有耐心等待每一个新版本软件包的发行，他们希望每当更新了新的feature后可以很快地使用</li><li><strong>性能和可扩展性</strong>——全球化（数量级）的应用使得很难预测应用的交易量能达到多少，应用必须有能快速在多台服务器之间进行扩展（scale up）、不需要时收缩（scale down）的能力</li><li><strong>高可用性</strong>——用户希望应用是一直可用的，即不会崩溃或者出现什么bug</li></ul><p>通过将服务改造成微服务架构，我们得到的应用将会是：小的、简单的、松耦合的，即可扩展的、适应性强的、灵活的。</p><p><strong>什么是云</strong></p><p>云计算的三种基本模型：</p><ul><li><strong>Infrastructure as a Service（IaaS）</strong></li><li><strong>Platform as a Service（PaaS）</strong></li><li><strong>Software as a Service（SaaS）</strong></li></ul><p>除此之外，还有一些新兴的云平台类型，如：</p><ul><li><strong>Function as a Service（FaaS）</strong></li><li><strong>Container as a Service（CaaS）</strong></li></ul><p>FaaS使用到的技术如Amazon的Lambda技术以及Google Cloud Functions，构建出<strong>“Serverless”</strong>的应用可以完全运行在云服务提供商的计算平台。</p><p>CaaS指的就是将微服务作为便携的（portable）虚拟容器（如Docker）部署到云上。不像IaaS（你需要管理你的虚拟机器），你可以直接使用云服务提供商提供的工具来<strong>构建、发布、监测、扩展</strong>等等。Amazon的ECS（弹性容器服务）就是一例。</p><p><strong>云和微服务</strong></p><p>写好了微服务，一般来说有三种方式部署</p><ul><li><strong>物理服务器</strong>——不易扩展</li><li><strong>虚拟机器镜像</strong>——易扩展</li><li><strong>虚拟容器</strong>——易扩展，且较轻量级</li></ul><p>基于云的微服务最大的好处就是可伸缩性，即增强了它的横向扩展能力。</p><p>本书中使用Docker将微服务部署到基于IaaS的云上。</p><ul><li><strong>简化基础设施管理</strong>——通过简单的API调用，即可实现对基础设施的管理</li><li><strong>强大的横向扩展能力</strong>——可以很快地开启多个实例</li><li><strong>多地配置带来的高冗余性</strong>——通常云提供商会在多个地理位置拥有数据中心</li></ul><p><strong>为什么不使用PaaS？</strong></p><p>在这么多云服务模型中，IaaS是提供的服务最少的，只有Infrastructure，同时也是最灵活的，因为其它的部分你可以自己选择。之所以选择IaaS是因为当我们的微服务变得越来越多时，需要更大的灵活性。</p><p>使用PaaS你可以将应用作为JAR包或者WAR包部署上去。你不需要设置/修改应用服务器和相关的Java容器，这一点比较方便。</p><p>另外，基于FaaS的平台将会使你更加受限制。因为你虽然可以用自己熟悉的语言来写自己的服务，但是你需要严重依赖vendor提供的API和运行时引擎（runtime engine）（只有在那个引擎上你的应用才能正确function）。</p><h3 id="1-9-微服务不只是写代码"><a href="#1-9-微服务不只是写代码" class="headerlink" title="1.9 微服务不只是写代码"></a>1.9 微服务不只是写代码</h3><p>构建一个robust的微服务不只是写写代码。有几件事需要考虑：</p><ul><li><strong>大小适中</strong>——确保每一个微服务的职责边界大小合适，只有这样才能方便对应用做出修改并在特殊情况下降低风险</li><li><strong>定位透明（？）</strong>——怎样管理服务调用时的物理细节，多个实例可以快速启动/关闭</li><li><strong>灵活性</strong>——当服务fail时怎么通过路由（routing）保证应用的完整性，保护用户【就是错误处理吧】</li><li><strong>可复现</strong>——怎样确保服务中的每一个新的实例都有和生产环境中的实例相同的配置和code base（代码库）</li><li><strong>可扩展</strong>——怎么使用异步处理和事件来减少服务之间的直接依赖，并保证可扩展性</li></ul><p>接下来，介绍六个微服务模式：</p><ul><li>Core Development Pattern</li><li>路由模式</li><li>客户端灵活性（resiliency）模式</li><li>安全模式</li><li>日志和轨迹（trace）模式</li><li>构建和开发模式</li></ul><h4 id="1-9-1-核心开发模式"><a href="#1-9-1-核心开发模式" class="headerlink" title="1.9.1 核心开发模式"></a>1.9.1 核心开发模式</h4><ul><li><strong>服务粒度</strong>——怎样将业务（business domain）拆分成适当的微服务？若分的太粗略则职责会overlap；若分得太细则增加了应用的复杂度</li><li><strong>通信协议</strong>——JSON？XML？</li><li><strong>接口设计</strong>——怎样设计接口以供开发者调用？好的接口设计是intuitive，即让人看到你的接口就知道它是做什么的</li><li><strong>配置管理</strong>——怎样管理配置才能做到在不同云环境无需改动核心应用代码和配置</li><li><strong>事件处理</strong>——怎样通过事件处理将硬编码部分减到最少，增加应用的灵活性（resiliency）</li></ul><h4 id="1-9-2-路由模式"><a href="#1-9-2-路由模式" class="headerlink" title="1.9.2 路由模式"></a>1.9.2 路由模式</h4><p><strong>routing pattern</strong>要解决的是要使用微服务的客户端如何发现服务的location并被路由过去。</p><p>在基于云的应用中，你可能有很多微服务实例同时在运行。你应该将这些服务的物理地址抽象出来，为服务调用提供一个统一的入口，以便一直保持应用的安全性。</p><ul><li><strong>Service discovery</strong>——怎样设计（不通过硬编码service的location）使得你的服务容易被发现？怎样保证不能正确执行的微服务实例能够从可运行的服务实例中抽出？</li><li><strong>Service routing</strong>——怎样为不同服务设计统一入口？</li></ul><h4 id="1-9-3-客户端灵活性"><a href="#1-9-3-客户端灵活性" class="headerlink" title="1.9.3 客户端灵活性"></a>1.9.3 客户端灵活性</h4><p>微服务架构是高度分布式的，所以要特别注意某一服务中的问题会级联（影响）到其他的用户。为此，我们有以下四种模型：</p><ul><li><strong>客户端负载均衡</strong>——怎样在客户端缓存服务实例的地址（location）以便对某个包含多个实例的微服务的调用（请求）能被均衡的分发到所有正常运行的微服务实例中？</li><li><strong>电路断路器模式</strong>——怎样让一个客户端在请求失败或者遭遇性能问题时停止请求？当某个服务遭遇性能瓶颈，它会消耗调用它的客户端的资源。应该做到让微服务调用<strong>fail fast（死得快）</strong>来提醒客户端快速做出反应</li><li><strong>撤退模式（Fallback）</strong>——当一个微服务fail时，怎样提供一个插件机制使客户端能够通过别的方式而不是调用这个坏掉的服务的方式完成工作</li><li><strong>隔板模式（Bulkhead）</strong>——微服务使用分布式的资源来完成工作。怎样划分这些调用请求以防止某个服务失效影响到其他服务？</li></ul><h4 id="1-9-4-安全模式（Security）"><a href="#1-9-4-安全模式（Security）" class="headerlink" title="1.9.4 安全模式（Security）"></a>1.9.4 安全模式（Security）</h4><ul><li><strong>Authentication（验证）</strong>——验证客户端的身份</li><li><strong>Authorization（授权）</strong>——确定客户端有权限使用服务（确定了client的身份后）</li><li><strong>Credential management and propagation（证书管理和传播）</strong>——怎样使客户端不需要么次调用服务时都需要出示证书？可以使用基于token的安全标准，如<strong>OAuth2</strong>和<strong>JavaScript Web Tokens（JWT）</strong>，获得的token用来在服务与服务之间验证并为用户授权。</li></ul><h4 id="1-9-5-日志和追踪（tracing）模式"><a href="#1-9-5-日志和追踪（tracing）模式" class="headerlink" title="1.9.5 日志和追踪（tracing）模式"></a>1.9.5 日志和追踪（tracing）模式</h4><ul><li><strong>日志关系（correlation）</strong>——怎样将同一个用户交易（transaction）下的不同微服务的所有日志绑定在一起？可以实现一个<strong>关系ID（correlation ID）</strong>，作为一个单独的标识符，在一次事务的不同服务之间作为标识。</li><li><strong>日志聚合（aggregation）</strong>——如何将微服务产生的所有日志放到一起组成一个可查询的数据库？可以借助<strong>correlation ID</strong>。</li><li><strong>微服务轨迹（tracing）</strong>——怎么将一个客户端交易事务所涉及的所有微服务的流程可视化，并分析其中的性能</li></ul><h4 id="1-9-6-构建-发布模式"><a href="#1-9-6-构建-发布模式" class="headerlink" title="1.9.6 构建/发布模式"></a>1.9.6 构建/发布模式</h4><p>为了构建<strong>immutable infrastructure</strong>，我们需要确保一个服务的任何实例都与其他实例是不同的，并且一旦一个服务部署上去，它所在的infrastructure再也不会改变了。</p><ul><li><strong>构建/发布pipeline</strong>——怎样创造一个可重复的构建/发布过程，可以一键构建/部署到任何环境？</li><li><p><strong>Infrastructure as code</strong>——怎样做到“服务即代码”，即可以被执行，源代码被管理</p></li><li><p><strong>不变的服务器</strong>——一旦一个微服务的镜像被创建了，怎样保证在发布之后不被改变？</p></li><li><strong>Phoenix servers</strong>——服务器运行时间越长，越容易发生<strong>configuration drift（配置漂移）</strong>（配置发生变化）。怎样保证日常崩溃的服务器能由一个不变的镜像恢复重建？</li></ul><h3 id="1-10-使用Spring-Cloud构建微服务"><a href="#1-10-使用Spring-Cloud构建微服务" class="headerlink" title="1.10 使用Spring Cloud构建微服务"></a>1.10 使用Spring Cloud构建微服务</h3><p>使用Spring Cloud构建微服务的好处就是它集成了很多开发需要用到的patterns。</p><h4 id="1-10-1-Spring-Boot"><a href="#1-10-1-Spring-Boot" class="headerlink" title="1.10.1 Spring Boot"></a>1.10.1 Spring Boot</h4><p>Spring Boot极大简化了基于REST的微服务构建过程；简化了HTTP动词和URL的映射；简化了JSON协议和Java对象的序列化；简化了Java异常和HTTP异常代码的映射。</p><h4 id="1-10-2-Spring-Cloud-Config"><a href="#1-10-2-Spring-Cloud-Config" class="headerlink" title="1.10.2 Spring Cloud Config"></a>1.10.2 Spring Cloud Config</h4><p>Spring Cloud Config通过中心化的服务来处理管理应用的配置数据，使得应用的配置数据与服务分开。好处是无论新增了多少微服务实例，都可以拥有相同的配置。除了自己的property管理仓库，还集成了许多开源项目，如：</p><ul><li><strong>Git</strong>：版本控制系统</li><li><strong>Consul</strong>：开源的、服务发现工具。你可以用来注册自己的服务，客户端可以询问Consul服务的位置。Consul也包括一个key-value数据库，可以存储应用配置数据</li><li><strong>Eureka</strong>：开源的Netflix项目，与Consul类似</li></ul><h4 id="1-10-3-Spring-Cloud-Service-Discovery"><a href="#1-10-3-Spring-Cloud-Service-Discovery" class="headerlink" title="1.10.3 Spring Cloud Service Discovery"></a>1.10.3 Spring Cloud Service Discovery</h4><p>通过Spring Cloud，你可以把你服务器的物理地址抽象化，服务使用者（客户端）可以通过一个逻辑名而不是物理location来访问。Spring Cloud同样处理服务实例的注册与注销。可以使用<strong>Consul</strong>作为服务发现引擎。</p><h4 id="1-10-4-Spring-Cloud-Netflix-Hystrix-and-Ribbon"><a href="#1-10-4-Spring-Cloud-Netflix-Hystrix-and-Ribbon" class="headerlink" title="1.10.4 Spring Cloud/Netflix Hystrix and Ribbon"></a>1.10.4 Spring Cloud/Netflix Hystrix and Ribbon</h4><p>Spring Cloud集成了很多Netflix的开源项目。对于客户端灵活性模式，Spring Cloud使用Netflix Hystrix库和Ribbon项目来完成。</p><p>使用Hystrix库，你可以很快实现客户端弹性模式，如<strong>断路器模式</strong>和<strong>舱壁模式</strong></p><h4 id="1-10-5-Spring-Cloud-Netflix-Zuul"><a href="#1-10-5-Spring-Cloud-Netflix-Zuul" class="headerlink" title="1.10.5 Spring Cloud/Netflix Zuul"></a>1.10.5 Spring Cloud/Netflix Zuul</h4><p>Netflix Zuul为微服务应用提供服务路由功能。Zuul是代理服务请求的服务网关，通过集中的服务调用，开发人员可以强制执行服务策略，如安全验证、内容过滤和路由规则。</p><h4 id="1-10-6-Spring-Cloud-Stream"><a href="#1-10-6-Spring-Cloud-Stream" class="headerlink" title="1.10.6 Spring Cloud Stream"></a>1.10.6 Spring Cloud Stream</h4><p>可以通过Stream将轻量级消息处理集成到微服务中。借助它，开发人员能够构建智能的微服务，它可以使用在应用程序中出现的<strong>异步事件</strong>。此外,Stream可以将微服务与消息代理整合，如<strong>RabbitMQ</strong>和<strong>Kafka</strong>。</p><h4 id="1-10-7-Spring-Cloud-Sleuth"><a href="#1-10-7-Spring-Cloud-Sleuth" class="headerlink" title="1.10.7 Spring Cloud Sleuth"></a>1.10.7 Spring Cloud Sleuth</h4><p>Sleuth让你可以将唯一的<strong>tracking identifiers（跟踪标识符）</strong>集成到HTTP调用和消息通道中（RabbitMQ、Kafka）。这些<strong>tracking number（跟踪号码）</strong>，也叫<strong>correlation/trace Id（关联Id）</strong>可以在应用程序的不同的服务中跟踪一个事务/交易。使用Sleuth，这些trace ID会自动添加到日志中。</p><p>Sleuth真正大放异彩是和<strong>日志聚合工具如Papertrail</strong>和<strong>跟踪工具如Zipkin</strong>等结合的时候。<strong>Papertrail</strong>是一个基于云的日志平台，可以实时将不同微服务产生的日志聚合成一个可查询的数据库。<strong>Zipkin</strong>可以将Sleuth产生的数据通过可视化的方式来展示某次事务/交易中涉及的服务调用（service call）工作流（flow）。</p><h4 id="1-10-7-Spring-Cloud-Security"><a href="#1-10-7-Spring-Cloud-Security" class="headerlink" title="1.10.7 Spring Cloud Security"></a>1.10.7 Spring Cloud Security</h4><p>这是一个用于验证（authentication）和授权（authorization）的框架，可以控制访问本服务的人员和他们的权限。Spring Cloud Security是基于token的，允许服务之间通过认证服务器（authentication server）授予的token来通信。每当服务接收到调用请求，会检查HTTP请求附带的token，验证其身份和访问权限。</p><p>此外，Security支持<strong>JWT</strong>。JWT框架可以标准化一个<strong>OAuth2</strong>token的创建格式，并为<strong>创建令牌进行数字签名</strong>提供了标准。</p><h4 id="1-10-8-代码供应（provisioning）"><a href="#1-10-8-代码供应（provisioning）" class="headerlink" title="1.10.8 代码供应（provisioning）"></a>1.10.8 代码供应（provisioning）</h4><p>提到代码供应，我们需要额外的技术栈。Spring框架是一个面向应用开发的框架，并不包括构建/部署的工具。要实现一个<strong>build and development pipeline</strong>，你需要使用<strong>Travis CI</strong>作为构建工具，用<strong>Docker</strong>来构建包含微服务的服务器镜像。</p><h3 id="1-11-Spring-Cloud完整的小例子"><a href="#1-11-Spring-Cloud完整的小例子" class="headerlink" title="1.11 Spring Cloud完整的小例子"></a>1.11 Spring Cloud完整的小例子</h3><h3 id="1-12-本书要完成的项目"><a href="#1-12-本书要完成的项目" class="headerlink" title="1.12 本书要完成的项目"></a>1.12 本书要完成的项目</h3><h3 id="1-13-总结"><a href="#1-13-总结" class="headerlink" title="1.13 总结"></a>1.13 总结</h3><ul><li>微服务是很小的一个功能模块，负责特定的领域</li><li>没有行业标准，不像其他网络服务协议，微服务采用基于原则的方法，与REST和JSON相似</li><li>写微服务很容易，当将其完全用于生产（production）需要多加考虑。包含要实现的几种模式（上文讲到的）</li><li>虽然微服务与语言无关，但本书引入两个框架：Spring Boot和Spring Cloud</li><li>Spring Boot是为了简化基于REST/JSON的微服务的开发的</li><li>Spring Cloud是一系列开源技术的集合（包括Netflix下的项目）</li></ul><h2 id="2-使用Spring-Boot构建微服务"><a href="#2-使用Spring-Boot构建微服务" class="headerlink" title="2 使用Spring Boot构建微服务"></a>2 使用Spring Boot构建微服务</h2><h3 id="2-1-架构师的故事——设计微服务架构"><a href="#2-1-架构师的故事——设计微服务架构" class="headerlink" title="2.1 架构师的故事——设计微服务架构"></a>2.1 架构师的故事——设计微服务架构</h3><p>三个关键任务：</p><ol><li>分解业务问题</li><li>建立服务粒度</li><li>定义服务接口</li></ol><h4 id="2-1-1-分解业务问题"><a href="#2-1-1-分解业务问题" class="headerlink" title="2.1.1 分解业务问题"></a>2.1.1 分解业务问题</h4><ol><li>描述业务，注意<strong>名词：contracts（合同）、licenses（许可证）、assets（资产）</strong>。</li><li>注意<strong>动词：查找、更新</strong>。</li><li>寻找数据内聚（cohesion）：寻找数据之间的关系。每个微服务应该只包含自己的数据。</li></ol><p><strong>EagleEye</strong>的数据模型可以简化为四个部分：<strong>Organization、License、Contract、Assets</strong>。</p><h4 id="2-1-2-建立服务粒度（granularity）"><a href="#2-1-2-建立服务粒度（granularity）" class="headerlink" title="2.1.2 建立服务粒度（granularity）"></a>2.1.2 建立服务粒度（granularity）</h4><p>基于数据模型，我们将在以下四个元素上建立微服务：</p><ul><li><strong>Assets</strong></li><li><strong>License</strong></li><li><strong>Contract</strong></li><li><strong>Organization</strong></li></ul><p><strong>如何建立合适的粒度？</strong></p><ol><li><strong>由大到小</strong>——开始的时候先比较粗略地划分一下，之后将问题域逐渐细分，直到找到一个比较好的大小。否则，开始就划分太细会导致应用复杂度过大。</li><li><strong>注意交互</strong>——有助于建立服务的粗粒度接口，由粗到细是比较容易的</li><li><strong>服务职责会改变</strong>——当需要新的应用功能时，服务就会有新的职责。最初的微服务可能会拆分成多个微服务，原始的微服务作为这些新服务的编排层（orchestration/arrangement），负责将应用其他部分的功能封装起来。</li></ol><p><strong>“糟糕”的微服务</strong></p><ul><li><strong>服务承担过多的职责</strong>——某个服务的业务逻辑很复杂</li><li><strong>服务管理了太多的数据表</strong>——服务需要使用很多表来管理数据，每个服务应该只管理自己的数据，其他的通过交互/通信实现，一个服务最好包含<strong>3-5张表</strong></li><li><strong>太多的测试用例</strong>——每个微服务可能随着时间增长。开始就有很多测试用例，增长空间会变得很小</li><li><strong>粒度太细的微服务</strong>：<ul><li><strong>Everything都是一个微服务</strong>，每个服务只和一个数据库表打交道</li><li><strong>服务之间互相依赖严重</strong>——为了完成一个用户请求，一个服务需要来来回回调用其他的服务</li><li><strong>微服务成为简单CRUD的集合</strong>——<em>微服务是业务逻辑的表达，而不只是数据源的抽象层</em></li></ul></li></ul><h4 id="2-1-3-交互：定义服务接口"><a href="#2-1-3-交互：定义服务接口" class="headerlink" title="2.1.3 交互：定义服务接口"></a>2.1.3 交互：定义服务接口</h4><ol><li><strong>拥抱REST理念</strong></li><li><strong>使用URI来传递意图（intent）</strong>——作为服务端点的URI描述问题域中的不同资源，并能表示出资源之间的关系</li><li><strong>请求和响应使用JSON</strong>——轻量级的数据序列化协议</li><li><strong>使用HTTP状态码表示结果</strong>——用HTTP状态码表示服务的成功/失败</li></ol><h3 id="2-2-什么时候不使用微服务"><a href="#2-2-什么时候不使用微服务" class="headerlink" title="2.2 什么时候不使用微服务"></a>2.2 什么时候不使用微服务</h3><ol><li><strong>构建分布式系统的复杂性</strong></li><li><strong>虚拟服务器/容器散乱</strong></li><li><strong>应用类型</strong></li><li><strong>数据事务和一致性</strong></li></ol><h4 id="2-2-1-构建分布式系统的复杂性"><a href="#2-2-1-构建分布式系统的复杂性" class="headerlink" title="2.2.1 构建分布式系统的复杂性"></a>2.2.1 构建分布式系统的复杂性</h4><p>由于微服务是分布式的且细粒度的，构建起来往往比构建单体应用程序更复杂。微服务架构需要一个很高的运维成熟度（operational maturity）。除非部门愿意投入高分布式应用程序所需要的自动化以及运维工作（监控，scale up/down），否则不要考虑使用微服务。</p><h4 id="2-2-2-服务器散乱"><a href="#2-2-2-服务器散乱" class="headerlink" title="2.2.2 服务器散乱"></a>2.2.2 服务器散乱</h4><p>微服务最常用的部署方式就是<strong>一个服务器上部署一个微服务实例</strong>。在一个基于微服务的大型应用中，最终可能需要建设和维护50~100台服务器。即使在云上运行这些服务成本比较低，管理和监控这些机器的复杂度也是巨大的。</p><p><strong>注意</strong><br><strong>必须对微服务的灵活性和运行多台机器的成本（复杂性）进行权衡。</strong></p><h4 id="2-2-3-应用程序的类型"><a href="#2-2-3-应用程序的类型" class="headerlink" title="2.2.3 应用程序的类型"></a>2.2.3 应用程序的类型</h4><p>微服务的一个特点是<strong>提高可重用性</strong>，对构建需要高度弹性（resilient）和可伸缩性（scalable）的大型应用非常有用。这也是很多基于云的公司采用微服务架构的原因。如果构建一个小型的、部门级的应用或者只有很小的用户群</p><p>，构建分布式的模型（如微服务）将会成本太高，不值得。</p><h4 id="2-2-4-数据事务和一致性"><a href="#2-2-4-数据事务和一致性" class="headerlink" title="2.2.4 数据事务和一致性"></a>2.2.4 数据事务和一致性</h4><p>当你观察微服务时，你需要注意的是<strong>服务的数据使用模式</strong>和<strong>消费者如何使用它们</strong>。微服务包装并抽象出少量的表，作为执行“操作型”任务的机制，如针对存储的创建、增加和简单查询。</p><p>如果应用程序需要对多个数据源做一些复杂的数据聚合或者转换，微服务的分布式特点将会使这个过程变得很困难。你的微服务将会承担太多的职责，也很容易受性能问题的影响。</p><p>记住，在微服务间执行事务没有统一标准。如果需要事务处理，那就得自己构建这个逻辑。从第七章可以看到，微服务间可以通过消息进行通信，消息传递在更新过程中就带来了延迟。你的应用需要处理最终的<strong>一致性</strong>（数据的更新可能不会立即出现）。</p><h3 id="2-3-开发者故事：使用Spring-Boot和Java构建一个微服务"><a href="#2-3-开发者故事：使用Spring-Boot和Java构建一个微服务" class="headerlink" title="2.3 开发者故事：使用Spring Boot和Java构建一个微服务"></a>2.3 开发者故事：使用Spring Boot和Java构建一个微服务</h3><p>在本部分，我们将实现构建EagleEye应用的<strong>许可证（licensing）</strong>微服务。接下来几节将要：</p><ol><li>搭建微服务框架，构建应用程序的Maven脚本</li><li>实现一个Spring的启动类，用于启动装载微服务的容器并启动所有类的初始化工作</li><li>实现一个Spring Boot控制器类（controller）来映射服务请求的端点</li></ol><p>在本例中，实现了简单的get、put、post、delete方法，与HTTP动作对应。但是，目前只是简单实现了get，可以通过url中的变量来改变get到的结果。</p><p><strong> <em>@RestController</em>与<em>@Controller</em>的不同点：</strong></p><p><em>@RestController</em>实现了REST风格的controller，返回JSON类型的数据，并且不需要增加<em>@ResponseBody</em>的注解；</p><p><em>@Controller</em>只是返回一个普通的Response对象（当然要加上<em>@ResponseBody</em>注解），并且可以返回正确的jsp、html页面，由配置好的<strong>视图解析器（InternalResourceViewResolver）</strong>完成。</p><p><strong> <em>@RequestMapping</em>的level</strong></p><p>可以用来修饰<strong>类</strong>，也可以用来修饰<strong>方法</strong>。</p><p><strong>Endpoint命名很重要！</strong></p><p>Endpoint的名字就是每一个微服务的URL路径。命名时注意三点：</p><ol><li><strong>使用清晰的命名方式</strong>——尽量使命名一致且易读，能够一眼就看出来代表的什么资源</li><li>建立资源之间的关系——资源之间通常存在层级关系，如<code>spring-boot/docs/hello-world.html</code>。因此一个孩子不能单独地存在于父节点之外。若你的URL太长了（嵌套太多层），可能你的微服务需要重写（服务范围太大了）。</li><li><strong>在URL中标识版本号</strong>——URL代表了服务提供者和消费者之间的一种契约关系。最好将一个版本号放在所有端点前面。如<code>v1/organizations/e254f8c</code></li></ol><h3 id="2-4-开发者故事：构建运行时的严谨性"><a href="#2-4-开发者故事：构建运行时的严谨性" class="headerlink" title="2.4 开发者故事：构建运行时的严谨性"></a>2.4 开发者故事：构建运行时的严谨性</h3><p>从开发者的角度，要遵循四个原则：</p><ol><li>每个微服务应该自包含、可独立部署，并且在一个软件构件（artifact）中包含多个服务的实例（instances of service）</li><li>每个微服务应是可配置的。当服务启动时，它应该自动读取需要的配置数据（从central location或是从环境变量中），无需人工干预。</li><li>每个微服务实例应该对客户端是透明的。客户端不知道服务的确切位置（物理地址），客户端永远和代理（agent）打交道。</li><li>每个微服务可以报告它的health情况。这是云架构的关键部分。一旦某个实例无法正常运行，客户端需要被路由到正常的服务实例。</li></ol><p>从运维（DevOps）的角度，这四条原则可以映射到以下的运维生命周期：</p><ul><li>服务装配——怎样打包部署微服务来保证其可重复性与一致性，使得相同的服务代码和运行时环境以相同方式部署</li><li>服务引导/启动（bootstraping）——<strong>怎样将应用代码和与特定环境相关的配置代码分离</strong>，使得每次部署到新环境能够快速启动/发布，无需人工干预配置</li><li>服务注册/发现——当一个微服务实例被发布，怎样使其更容易被其他应用发现（discoverable）？</li><li>服务监控——微服务开发中，为了保证高可用性，通常一个服务有多个实例在运行。运维需要负责任何运行故障的监控与处理，并且将失效的服务拆卸掉。</li></ul><p><strong>构建12-factor微服务应用程序</strong></p><p>一个成功的微服务架构需要很多的开发与运维实践经验。有一个<strong>12因素应用宣言</strong>，所谓<strong>最佳实践（Best Practices）</strong>，原文可以在<a href="https://12factor.net" target="_blank" rel="noopener">https://12factor.net</a>找到，总结如下：</p><p><strong>代码库</strong>——所有应用代码和服务器供应信息都应处于版本控制中。每个微服务在版本控制系统中应该有独立的代码仓库。</p><p><strong>依赖</strong>——通过构建工具（如Maven）显式地（explicitly）声明依赖。第三发jar依赖应该明确其版本号。这样能够保证微服务始终用同样的版本库来构。</p><p><strong>配置</strong>——将配置代码和应用程序源代码分开。</p><p><strong>后端服务</strong>——微服务通过网络与数据库或消息系统进行通信。应该保证，任何时候都可以将本地管理的服务换成第三方服务。第10章，我们将从本地的Postgres数据库迁移到Amazon管理的数据库。</p><p><strong>构建、发布和运行</strong>——保持应用程序的构建、发布和运行过程分离。一旦代码构建完成，在运行时就不要再改动代码。一旦改动，就要重新构建发布。一个已构建服务是不可变的（immutable）。</p><p><strong>进程</strong>——微服务始终是无状态的。它们可以在任何时候被撤销和替换，不用担心服务实例的丢失会导致数据丢失。</p><p><strong>端口绑定</strong>——一个微服务在打包时是完全独立的，其中包含了运行时引擎。因此，运行微服务不需要额外的web或应用服务器，服务可以在命令行自启动，通过暴露的HTTP端口访问。</p><p><strong>并发</strong>——当你需要扩展（scale），不要依赖于单一服务的线程模型，而是创建更多服务实例来横向扩展。相对来说，单一服务的线程模型（scale up）量级不够大，多服务实例（scale out）更加易扩展。</p><p><strong>可处理性（disposability）</strong>——微服务是可以任意处置的，可以随时被启动和停止。应最小化启动时间，当被kill时应能够正常退出。</p><p><strong>开发/生产环境同等对待</strong>——减小服务在不同环境中运行的差异。开发者在本地开发时的基础设施（infrastructure）应与服务发布后运行时的相同 。这也意味着服务能够快速部署，代码被提交后，应该被测试，然后尽快从测试环境一直promote到生产环境。</p><p><strong>日志</strong>——日志是一个事件流。当日志被写出时，应该可以流式传输到<strong>Splunk</strong>或<strong>Fluentd</strong>这样的工具，通过校对整理将它们写到中央位置。微服务不需要关心这种情况发生的机制，开发者可以通过STDOUT查看日志。</p><p><strong>管理进程</strong>——开发人员经常需要对所写的服务进行管理工作（数据迁移、转换等）。应当用脚本来完成这些工作。脚本应该是可重复的，并且在每个运行的环境中是不可变的（不需要针对每个环境进行修改）。</p><h4 id="2-4-1-服务装配——打包部署你的微服务"><a href="#2-4-1-服务装配——打包部署你的微服务" class="headerlink" title="2.4.1 服务装配——打包部署你的微服务"></a>2.4.1 服务装配——打包部署你的微服务</h4><p>通常，基于Java的微服务框架都包含一个运行时引擎，如Spring Boot。可以从命令行运行，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package &amp;&amp; java -jar target/licensing-service-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>传统的J2EE开发中。应用是被部署到一个应用服务器上的。这样的应用只包含应用实体，需要被系统管理员团队根据不同的部署运行环境管理不同的配置。</p><p>这种做法——将应用服务器的配置和应用程序分离，在部署过程中引入了更多故障点（failure points），因为很多组织的应用服务器的配置不受源控制（source control），而是通过用户界面（UI）和本地管理脚本组合的方式来控制。这很容易在服务环境中发生configuration drift，并突然导致服务中断（outage）。</p><p>将运行时引擎嵌入应用的做法减少了配置漂移的可能性（因为统一位于源代码控制），这样也允许开发团队更好地思考他们的app是如何构建/部署的。</p><h4 id="2-4-2-服务引导：配置管理"><a href="#2-4-2-服务引导：配置管理" class="headerlink" title="2.4.2 服务引导：配置管理"></a>2.4.2 服务引导：配置管理</h4><p>当应用程序启动时，需要先从配置文件或者数据存储仓库（如数据库）读取配置数据，微服务也不例外。但是，对于成百上千的微服务实例，<strong>每当配置数据更新了后重新部署微服务似乎不太可行</strong>。</p><p>把配置数据存储在服务外部通常是个解决方法，但是基于云的微服务还需要考虑以下几点：</p><ol><li><strong>配置数据数据结构要简单，经常读取不常写入</strong>。最好不要用关系型数据库，因为关系型数据库的数据类型很复杂，大材小用。</li><li>数据定期访问，但是很少更改，因此<strong>读数据要做到低延迟</strong>。</li><li><strong>数据仓库应是高可用的</strong>，且靠近（地理上）需要读数据的服务。配置数据仓库不能完全关闭，否则会导致单点故障。</li></ol><h4 id="2-4-3-服务注册与发现：客户端如何与微服务通信"><a href="#2-4-3-服务注册与发现：客户端如何与微服务通信" class="headerlink" title="2.4.3 服务注册与发现：客户端如何与微服务通信"></a>2.4.3 服务注册与发现：客户端如何与微服务通信</h4><p>从微服务consumer的角度来看，一个微服务应当是地理位置透明的（不关心地理位置）。在基于云的环境中，服务器是短暂的（不固定的），不同于传统的位于企业数据中心的服务器。服务可以很快地启动/停止，被分配新的IP。</p><p>由于微服务的“短暂性”特征，它因此获得了高度的可扩展性、可用性以及灵活性。同时带来了一个问题——手工管理大量的短暂服务很容易造成运行中断（还话费大量人力）。</p><p>一个微服务，一个成熟的微服务（没错，<strong><em>你已经是个成熟的微服务了</em></strong>），应该会自己找到第三方代理并把自己注册上，这个过程也叫服务发现（service discovery）。</p><p>所谓的<strong>把自己注册到服务发现的代理</strong>，是指将两个东西告诉服务发现代理：</p><ol><li><strong>物理IP地址</strong>，或者服务实例的<strong>域名地址</strong>（domain address）</li><li>应用可以用来查看服务的<strong>逻辑名</strong></li></ol><p>某些服务发现代理还需要一个URL（注册代理的那个服务的），以便于代理进行健康检查（检查服务实例的运行情况）。然后，服务客户端就可以通过代理来查看服务的位置。</p><h4 id="2-4-4-报告微服务的健康状况"><a href="#2-4-4-报告微服务的健康状况" class="headerlink" title="2.4.4 报告微服务的健康状况"></a>2.4.4 报告微服务的健康状况</h4><p><strong>服务发现代理</strong>的任务不仅是像一个交通警察一样将客户端带到相应服务的位置，还要持续监视每一个微服务实例的运行情况，以确保客户端不会将请求发送到一个无效的服务实例上。</p><p>微服务开始运行后，服务发现代理会持续地监视并向<strong>健康检查接口（health check interface）</strong>发送ping报文，以确保服务可用。</p><p>通过构建一个一致的接口，可以使用基于云的监视工具来检测问题并反馈（如检测到异常后关闭服务等等）。</p><p>如果使用REST风格构建微服务，通常暴露一个HTTP端点，<strong>返回一个JSON类型的payload和HTTP状态码</strong>。如果没有使用类似Spring Boot的框架，则需要开发者自己手动实现端点；但是有了Spring Boot提供的<strong>开箱即用（out-of-the-box）的Spring Actuator</strong>组件，可以快速实现健康检查的接口。</p><p>在pom.xml中添加了依赖后，在地址栏输入<em><a href="http://localhost:8080/health" target="_blank" rel="noopener">http://localhost:8080/health</a></em>可以看到返回的健康数据。</p><h3 id="2-5-以上帝视角看问题"><a href="#2-5-以上帝视角看问题" class="headerlink" title="2.5 以上帝视角看问题"></a>2.5 以上帝视角看问题</h3><ol><li><strong>架构师</strong>——专注于业务问题的轮廓，分析出备选的微服务。记住，要从粗到细，一开始就把服务划分的过细不是个好习惯。</li><li><strong>软件工程师</strong>——尽管（每个）微服务很小，这并不意味着将良好的设计原则抛之脑后。服务中的每一层都有明确的职责。避免在代码中构建框架，尝试使每个微服务完全独立。不成熟的框架设计只会带来生命周期的后期巨大的维护代价。</li><li><strong>运维工程师</strong>——服务的存在需要介质，要尽早的建立服务的生命周期。运维不止要关注如何自动化构建和发布过程，更要关注如何监视服务的运行状况以及服务出现问题时怎么办。</li></ol><h2 id="3-使用Spring-Cloud配置服务器"><a href="#3-使用Spring-Cloud配置服务器" class="headerlink" title="3 使用Spring Cloud配置服务器"></a>3 使用Spring Cloud配置服务器</h2><p>开发人员需要注意的一点是，尽量把<strong>应用代码</strong>和<strong>配置信息</strong>分离开，即在应用程序中应不包含关于配置的任何信息。这样的一个好处是，由于应用代码部分没有关于配置的硬编码信息，每当配置发生了改变，<strong>不需要重新编译/部署</strong>。同时带来了一个问题，<strong>配置部分要作为一个单独的artifact进行管理和发布</strong>。</p><p>许多开发者会将配置信息放到低层级的属性（配置）文件（如YAML、JSON或XML）中。它放在服务器上，包含数据库或者中间件的连接信息，以及关于此应用的一些元数据（metadata）用来引导应用程序的行为。此种方式比较简单，大多数开发者也都是这么做的——将配置文件放到源代码控制，作为应用的一部分部署。</p><p>上述方法对于一些应用可行，但是对于基于云的应用（通常包含许多微服务，每个微服务还有很多实例，就不太行了。</p><p>对于配置管理，基于云的微服务开发强调：</p><ol><li><p>应用程序配置和被部署的代码完全分开</p></li><li><p>构建好服务器、应用以及一个永远不会改变的镜像</p></li><li>在服务启动时注入应用的配置信息，通过读取环境变量或者中心仓库的方式。</li></ol><h3 id="3-1-配置管理（复杂性）"><a href="#3-1-配置管理（复杂性）" class="headerlink" title="3.1 配置管理（复杂性）"></a>3.1 配置管理（复杂性）</h3><p>每当运维工程师需要手动配置或者改变服务时，都可能引起configuration drift、宕机或者延迟等问题，因此配置管理非常重要。配置管理的四个原则：</p><ol><li><strong>分离</strong>——服务的物理部署应与配置信息分离开。应用程序配置不应该与服务实例一同部署。配置信息应当在服务启动时作为环境变量传递给服务或者从中央仓库读取。</li><li><strong>抽象</strong>——将访问配置数据的功能抽象到一个服务接口中。应用程序使用基于REST的JSON服务来检索配置数据，而不是直接访问服务存储仓库（即通过文件或者使用JDBC从数据库读取数据）。</li><li><strong>中心化</strong>——基于云的应用程序可能有很多个服务，尽量减少保存配置信息的存储库。</li><li><strong>稳定</strong>——由于配置信息和实际代码完全隔离，要保证其高可用性和冗余性</li></ol><p>由于将配置信息置于实际代码之外，它将作为一个外部依赖，需要进行单独管理并进行版本控制。</p><p><strong>On accidental complexity</strong></p><h4 id="3-1-1-配置管理架构"><a href="#3-1-1-配置管理架构" class="headerlink" title="3.1.1 配置管理架构"></a>3.1.1 配置管理架构</h4><p>配置管理过程中，发生了以下重要的活动：</p><ol><li>当一个微服务实例启动时，它将会调用一个服务endpoint来<strong>读取它所在特定的环境的配置信息</strong>。服务启动后，用于配置管理的连接信息（连接credentials（证书/凭据）、服务端点等）将会传递进来。</li><li><strong>实际的配置存在于一个配置库（repository）中</strong>。可以使用不同的实现来保存配置数据。配置库的实现选择包括源代码控制下的文件、关系型数据库或是键值数据库。</li><li>应用程序的配置管理与应用程序的部署方式无关。<strong>配置管理的更改通常由构建/部署管道（build and deployment pipeline）来处理</strong>，配置的改变会被标记上版本信息并部署到不同环境中。</li><li>当配置管理发生了改变，<strong>使用这个配置信息的服务必须被通知（notify）</strong>并刷新应用程序数据的副本。</li></ol><h4 id="3-1-2-实现方式"><a href="#3-1-2-实现方式" class="headerlink" title="3.1.2 实现方式"></a>3.1.2 实现方式</h4><p>对比了一下常用的开源项目，最终选定<strong>Spring Cloud configuration server</strong></p><h3 id="3-2-构建Spring-Cloud配置服务器"><a href="#3-2-构建Spring-Cloud配置服务器" class="headerlink" title="3.2 构建Spring Cloud配置服务器"></a>3.2 构建Spring Cloud配置服务器</h3><p>本章我们要新建一个单独的目录——<strong>confsvr</strong>。在此目录下，需要新建一个pom.xml并把启动Spring Cloud配置服务器要用到的jar包添加上。</p><p>从pom.xml中可以发现描述Spring Boot的版本和Spring Cloud的版本并不相同。前者使用的是如<strong>1.4.4</strong>这样的版本号；后者使用的是一个叫<strong>release train</strong>的东西，版本号以伦敦地铁站名命名，如<strong>Angel，Brixton和Camden</strong>（很奇葩是不是？一个版本号都要搞这么多幺蛾子）。</p><h4 id="3-2-1-创建Spring-Cloud-Config启动类"><a href="#3-2-1-创建Spring-Cloud-Config启动类" class="headerlink" title="3.2.1 创建Spring Cloud Config启动类"></a>3.2.1 创建Spring Cloud Config启动类</h4><p>启动类中，多了一个<em>@EnableConfigServer</em>的注解，表明这是一个Spring Cloud Config的服务。</p><h4 id="3-2-2-通过文件系统使用配置服务器"><a href="#3-2-2-通过文件系统使用配置服务器" class="headerlink" title="3.2.2 通过文件系统使用配置服务器"></a>3.2.2 通过文件系统使用配置服务器</h4><p> 在<strong>application.yml</strong>文件中，可以通过<strong>文件系统</strong>或者<strong>基于云的Git提供商（如BitBucket或者GitHub）</strong>配置服务器。通过文件系统（本机）配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">   port: 8888</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: native</span><br><span class="line">  cloud:</span><br><span class="line">     config:</span><br><span class="line">       server:</span><br><span class="line">           native:</span><br><span class="line">              searchLocations: classpath:config/,classpath:config/licensingservice</span><br></pre></td></tr></table></figure><p><em>8888</em>指定了配置服务器运行的端口号；<em>native</em>说明了使用文件系统存储配置信息；<em>searchLocations</em>制定配置文件位置（使用相对路径）。</p><p>通过向配置服务器发送get请求：<em><a href="http://localhost:8888/licensingservice/default" target="_blank" rel="noopener">http://localhost:8888/licensingservice/default</a></em>，可以看到以JSON格式返回的位于licensingservice.yml中的配置信息。将URL最后的endpoint换成dev，则会得到dev和default两个配置。这是因为Spring Cloud实现了一个层级的读取配置的机制。它首先寻找default，然后若找到更高层级的，则会覆盖default中已有的，即如果在default和dev中同时设置了某个属性值，则使用dev中的；否则，使用default中的。</p><h3 id="3-3-将Spring-Cloud-Config集成到Spring-Cloud客户端"><a href="#3-3-将Spring-Cloud-Config集成到Spring-Cloud客户端" class="headerlink" title="3.3 将Spring Cloud Config集成到Spring Cloud客户端"></a>3.3 将Spring Cloud Config集成到Spring Cloud客户端</h3><p>上节只是将读取了硬编码的licensing service的配置，本节将通过与数据库交互来读取配置数据。</p><h4 id="3-3-1-建立依赖"><a href="#3-3-1-建立依赖" class="headerlink" title="3.3.1 建立依赖"></a>3.3.1 建立依赖</h4><p>依次添加<em>spring-boot-starter-data-jpa、postgresql、spring-cloud-config-client</em>依赖包，引入Spring Data Java持久层API、Postgres JDBC驱动。最后一个依赖包含了和Spring Cloud配置服务器交互用到的所有的类。</p><h4 id="3-3-2-配置许可证服务使用Spring-Cloud-Config"><a href="#3-3-2-配置许可证服务使用Spring-Cloud-Config" class="headerlink" title="3.3.2 配置许可证服务使用Spring Cloud Config"></a>3.3.2 配置许可证服务使用Spring Cloud Config</h4><p>添加完依赖，我们需要将写好的服务（licensing service）也做相关配置，以告诉我们的服务到哪去找配置（连接配置服务器）。对于Spring Cloud Config，配置信息可以放在以下两个文件中：<strong>bootstrap.yml和application.yml</strong>。（两个配置文件都在<em>src/main/resources</em>目录下）</p><p><em>bootstrap.yml</em>会读取应用的属性，且<strong>优先级最高</strong>。一般来说，其中包含了<strong>应用的名字、应用的profile（使用哪个配置profile）以及连接到配置服务器的URI</strong>。其它想设置的配置信息可以放在服务的外面——<em>application.yml</em>（而不是在配置服务器上）。通常，放在application.yml中的配置信息是你认为当配置服务器不可用时也能执行的。</p><p><em>bootstrap.yml</em>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: licensingservice</span><br><span class="line">  profiles:</span><br><span class="line">    active:</span><br><span class="line">      default</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      uri: http://localhost:8888</span><br></pre></td></tr></table></figure><p>其中，<em>spring.application.name</em>是应用的名字，并且必须与Spring Cloud配置服务器下的目录对应。如：若有一个服务<em>licensingservice</em>，则在配置服务器的<em>src/main/resources/config</em>下要有一个licensingservice的目录与之对应。</p><p><em>spring.profiles.active</em>指出Spring Boot要使用哪个profile来运行。每一个profile对应一份不同的配置。</p><p><em>spring.cloud.config.uri</em>指出服务应当从哪个endpoint寻找（连接）Spring Cloud配置服务器。默认使用端口8888。</p><h4 id="3-3-3-使用数据源"><a href="#3-3-3-使用数据源" class="headerlink" title="3.3.3 使用数据源"></a>3.3.3 使用数据源</h4><p>本项目使用的是Spring Data JPA（一个封装了JPA规范的框架），可以通过约定好的<strong>方法命名规则</strong>写dao接口，就可以在不写接口实现的情况下，还实现对数据库的访问。提供了出CRUD之外的功能，如分页、排序、复杂查询等。项目中LicenseRepository的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LicenseRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">License</span>,<span class="title">String</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">findByOrganizationId</span><span class="params">(String organizationId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> License <span class="title">findByOrganizationIdAndLicenseId</span><span class="params">(String organizationId,String licenseId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的命名规则形如 <em>findByXXId</em> 。通常，可以继承<strong>JpaRepository</strong>或<strong>CrudRepository</strong>。其中，JpaRepository继承自PagingAndSortingRepository，后者又继承自CrudRepository。顾名思义，Crud提供了CRUD的相关方法；PagingAndSorting提供了分页排序的方法；Jpa实现了一组Jpa规范的方法。</p><p><em>@Repository</em>注解表示这个接口作为一个repository，可以自动产生一个<strong>动态代理</strong>。</p><h4 id="3-3-4-使用-Value读取属性"><a href="#3-3-4-使用-Value读取属性" class="headerlink" title="3.3.4 使用@Value读取属性"></a>3.3.4 使用@Value读取属性</h4><p>配置类ServiceConfig类中，有一个<em>@Value</em>标记，它会自动<strong>把关于数据库的配置数据注入到数据库连接对象中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;example.property&#125;"</span>)</span><br><span class="line">  <span class="keyword">private</span> String exampleProperty;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getExampleProperty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exampleProperty;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过@Value注解，Spring会自动从Spring Cloud配置服务器寻找<em>example.property</em>属性，并把其值注入到ServiceConfig类中。</p><h4 id="3-3-5-通过Git使用Spring-Cloud配置服务器"><a href="#3-3-5-通过Git使用Spring-Cloud配置服务器" class="headerlink" title="3.3.5 通过Git使用Spring Cloud配置服务器"></a>3.3.5 通过Git使用Spring Cloud配置服务器</h4><p>使用Git来管理配置属性（property）的好处就是，你的所有配置属性的管理也在<strong>源控制（source control）</strong>下。每当你重新构建/部署应用时，配置也可以同步构建/部署。</p><p>要将Git作为我们的配置服务器的配置信息的存放地点，需要更改application.yml文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        encrypt.enabled: <span class="keyword">false</span></span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/carnellj/config-repo/</span></span><br><span class="line">          searchPaths: licensingservice,organizationservice</span><br><span class="line">          username: <span class="keyword">native</span>-cloud-apps</span><br><span class="line">          password: <span class="number">0f</span>fended</span><br></pre></td></tr></table></figure><p>如果用文件系统作为配置服务器，则server下为<strong>native，</strong>此处为git。<strong>searchPaths</strong>指明了配置文件所在的路径。</p><h4 id="3-3-6-刷新配置属性（property）"><a href="#3-3-6-刷新配置属性（property）" class="headerlink" title="3.3.6 刷新配置属性（property）"></a>3.3.6 刷新配置属性（property）</h4><p>当配置改变时，如何使应用使用最新的配置？</p><p>可以在应用的启动类前加上<strong>@RefreshSCope</strong>注解，它会重新加载你自己写的（额外的）属性配置文件，但不会刷新数据库的配置。可以输入<em>http://\&lt;yourserver>:8080/refresh</em>来执行刷新。</p><p><strong>关于刷新微服务</strong></p><p>Spring Cloud配置服务提供了一个<strong>基于push的机制——Spring Cloud Bus</strong>，每当检测到配置改变后会告诉所有使用这个服务的客户端。Spring Cloud配置需要一个额外的中间件——<strong>RabbitMQ</strong>。这是一个有效的办法，但并不是所有的Spring Cloud Configuration后端都支持这个机制（如Consul）。</p><p>下一章会介绍使用Spring服务发现和Eureka来注册一个服务的所有实例。作者常用的一个方法是，通过写脚本来查询服务发现引擎上某个服务的所有实例，然后立即调用<em>/refresh</em>端点。</p><p>或者，你可以重启服务器/容器来得到新的配置。如果使用Docker将会很方便。因为重启Docker只需要几秒钟，通过重启就可以重新读取配置数据。</p><h3 id="3-4-保护敏感配置信息"><a href="#3-4-保护敏感配置信息" class="headerlink" title="3.4 保护敏感配置信息"></a>3.4 保护敏感配置信息</h3><p>在配置文件中全部用纯文本（明文）来保存配置信息的做法不够安全，尤其是当其中含有一些敏感信息，如数据库凭据（credentials）。Spring Cloud Config允许你用<strong>对称（共享秘钥）或非对称（公钥、私钥）方式</strong>对敏感信息加密。</p><p>我们将看看如何搭建Spring Cloud配置服务器以使用对称秘钥的加密。步骤如下：</p><ol><li>下载安装Oracle JCE</li><li>创建加密秘钥</li><li>加密和解密属性</li><li>配置微服务以在客户端使用加密</li></ol><h4 id="3-4-1-下载安装Oracle-JCE依赖包"><a href="#3-4-1-下载安装Oracle-JCE依赖包" class="headerlink" title="3.4.1 下载安装Oracle JCE依赖包"></a>3.4.1 下载安装Oracle JCE依赖包</h4><p>在官网下载好后，定位到文件资源管理器的<strong>$JAVA_HOME/jre/lib/security</strong>目录，将下载好的压缩文件解压，替换对应的<em>local_policy.jar</em>和<em>US_export_policy.jar</em>文件，若害怕丢失可以先备份一下。</p><h4 id="3-4-2-创建一个秘钥"><a href="#3-4-2-创建一个秘钥" class="headerlink" title="3.4.2 创建一个秘钥"></a>3.4.2 创建一个秘钥</h4><p>在配置服务器上设置秘钥，可以在bootstrap.yml或者application.yml里。设置<strong>encrypt.key: IMSYMMETRIC</strong>。秘钥可以随便设置，但是有两点注意：</p><ol><li>秘钥应为12个字符及以上，最好是随机序列的字符</li><li>保管好你的秘钥，解密时必须用加密时用的秘钥</li></ol><h4 id="3-4-3-加密-解密（property）"><a href="#3-4-3-加密-解密（property）" class="headerlink" title="3.4.3 加密/解密（property）"></a>3.4.3 加密/解密（property）</h4><p>现在我们可以对我们希望加密的属性进行加密了。</p><p>通过向配置服务器发送POST请求：<em><a href="http://localhost:8888/encrypt" target="_blank" rel="noopener">http://localhost:8888/encrypt</a></em>，将要加密的对象放在request body中，发送POST请求就能得到加密后的结果。同理，发送/decrypt请求，就能将已加密对象解密。</p><p>我们可以将配置文件中的密码替换为我们加密完的结果。</p><p>看起来不错！但是仍然存在问题：我们还是能通过GET请求看到密码的明文！向<em><a href="http://localhost:8888/licensingservice/default" target="_blank" rel="noopener">http://localhost:8888/licensingservice/default</a></em>发送请求，可以看到密码不在原来的位置了（偷偷跑到JSON数据末尾了…）。原因就是，虽然已经将property加密，但是配置服务器会自动将其解密，因此，我们需要将其在客户端解密（客户端在服务端fetch到配置数据，然后将其在客户端解密）。</p><h4 id="3-4-4-配置微服务-在客户端解密"><a href="#3-4-4-配置微服务-在客户端解密" class="headerlink" title="3.4.4 配置微服务-在客户端解密"></a>3.4.4 配置微服务-在客户端解密</h4><ol><li>在服务端配置Spring Cloud Config不要解密</li><li>在微服务端（licensing server）设置对称秘钥</li><li>微服务端引入<em>spring-security-rsa</em>依赖</li></ol><p>第一步，在配置服务器的application.yml上配置<strong>spring.cloud.config.server.encrypt.enables: false</strong>。</p><p>第二步，在微服务的bootstrap.yml中添加与配置服务器上相同的对称秘钥：<strong>encrypt.key: IMSYMMETRIC</strong>。</p><p>第三步，添加依赖。</p><p>现在访问<em><a href="http://localhost:8888/licensingservice/default" target="_blank" rel="noopener">http://localhost:8888/licensingservice/default</a></em>，发现密码已经是加密过的了。</p><h3 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h3><ul><li><p>Spring Cloud配置服务器让你可以为不同的环境创建不同的配置</p></li><li><p>Spring使用<strong>profiles</strong>来自动根据不同环境决定使用什么配置</p></li><li><p>Spring Cloud配置服务可以使用基于文件/Git的应用来存储应用属性</p></li><li><p>Spring CLoud配置服务可以使用对称/非对称加密保护你的关键数据</p></li></ul><h2 id="4-发现服务"><a href="#4-发现服务" class="headerlink" title="4 发现服务"></a>4 发现服务</h2><p>在分布式架构中，我们需要发现一台机器的物理地址。这个概念随着云计算的出现而出现——服务发现。服务发现可以简单到只用一个配置文件来维护应用程序用到的所有远程地址（服务器），也可以复杂到诸如使用UDDI（Universal Description，Discovery，and Integration）仓库。</p><p>服务发现之所以对微服务和基于云的应用这么重要，原因有两个：</p><p><strong>第一，有利于应用的快速横向扩展/收缩（scale up/down）</strong>。服务消费者通过服务发现将服务的物理地址抽象出来了，由于消费者不知道服务的具体地址，因此可以从服务池（pool）中任意添加/移除新的服务实例。</p><p>这也改变了应用架构升级的方式——<strong>由升级硬件（垂直扩展）到增加服务器（横向扩展）</strong>。</p><p><strong>第二，增加了应用的弹性（灵活性）</strong>。当服务出现异常（不可用时），服务发现引擎能够快速将它从服务可用列表上移除并寻找可用的服务。应用failure导致的影响被降到了最低。</p><h3 id="4-1-我的服务在哪呢？"><a href="#4-1-我的服务在哪呢？" class="headerlink" title="4.1 我的服务在哪呢？"></a>4.1 我的服务在哪呢？</h3><p>当你的应用调用位于多台服务器上的资源时，就需要定位这些资源的物理位置。在普通应用（非云架构）中，通常使用<strong>DNS+负载均衡器（load balancer）</strong>的解决方式。</p><p>应用需要调用其他服务时，通过一个DNS名称以及服务所在路径来调用该服务。DNS名称会被解析到一个商用的负载均衡器（硬件，如F5）或者开源的负载均衡器（如HAProxy）。</p><p>负载均衡器负责接收请求，检查路由表中托管该服务的服务器，并选择一个服务器，将请求转发（forward）给它。每个服务的实例被部署到一个或多个服务器上，这些服务器的数量是<strong>固定的（static）</strong>，当其中某个服务器挂了（crash），它会被恢复到挂掉之前的状态（与之前有相同的IP和配置）。</p><p>为了实现高可用，通常在负载均衡器的基础上再设置一个<strong>二级负载均衡器</strong>，当负载均衡器挂掉，它会取代他的位置。</p><p>上述模型对于一些在固定的服务器上运行的小型应用是可行的，但是对于基于云的微服务应用就不太行了，因为：</p><ul><li><strong>单点故障</strong>——如果负载均衡器挂了，整个应用就完了！尽管你可以将load balancer做成高可用的（尽管你可以设置二级、三级…），但是负载均衡器往往是应用程序基础设施的集中式阻塞点（centralized checkpoints）。</li><li><p><strong>有限的横向扩展能力</strong>——在服务集中到单个负载均衡器集群的条件下，将负载均衡的基础设施扩展到多台服务器上的能力是有限的。许多商用的负载均衡器被两个因素所限制：<strong>冗余模型和许可证成本</strong>。首先，许多采用<strong>热插拔模型</strong>，即同一时刻最多有一个负载均衡器在运行。二级负载均衡器只是用来在主负载均衡器失效时才起作用。这样做实际上是被硬件限制了（只能无限提升一台负载均衡器的性能，因为不能多台同时工作）；其次，商用负载均衡器具有有限数量的许可证，<strong>它面向固定容量模型而不是可变容量模型</strong>。</p></li><li><p><strong>静态管理</strong>——大多数负载均衡器并没有快速注册/注销服务的能力。它们使用集中式数据库来存储路由规则，添加新的路由规则也只能通过供应商提供的私有API来实现。</p></li><li><strong>复杂</strong>——负载均衡器相当于微服务的代理，消费者的请求需要被映射到物理服务。这就需要定义和部署服务的映射规则（手动）。在传统方案中，新服务实例的注册是手动完成的，并不是在服务启动后立即完成。</li></ul><p>这四个原因并不是对负载均衡器的刻意指摘。负载均衡器在企业级环境中工作良好，大多数应用可以通过集中式网络基础设施来处理。此外，负载均衡器仍然可以在集中化SSL终端和管理服务端口安全方面发挥作用。负载均衡器可以锁定位于它后面的所有服务器的入站（入口）端口和出站（出口）端口访问。在满足行业要求方面，如PCI（Payment Card Industry），它仍是一个关键组成部分。</p><p>然而，在基于云的世界，你需要处理很多的<strong>事务</strong>和<strong>冗余</strong>。中心化的网络结构通常不能胜任。</p><h3 id="4-2-云中的服务发现"><a href="#4-2-云中的服务发现" class="headerlink" title="4.2 云中的服务发现"></a>4.2 云中的服务发现</h3><p><strong>服务发现</strong>机制具有以下特点：</p><ul><li><strong>高可用</strong>——服务发现支持热集群环境，在服务发现集群可以跨多个节点实现共享查找。一个节点不可用时，其他节点可以take over。</li><li><strong>P2P</strong>——点对点。每一个节点地位平等，共享服务实例的状态。</li><li><strong>负载均衡</strong>——确保将服务请求合理地分配给不同正在工作状态的服务实例。</li><li><strong>弹性/灵活性</strong>——服务发现客户端应该能够在<strong>本地缓存服务信息</strong>。本地缓存的意义在于，一旦服务发现引擎不可用，应用仍然能够function。</li><li><strong>容错性</strong>——服务发现需要检测服务实例的健康状态，并对其采取措施。</li></ul><h4 id="4-2-1-服务发现架构"><a href="#4-2-1-服务发现架构" class="headerlink" title="4.2.1 服务发现架构"></a>4.2.1 服务发现架构</h4><p>怎么实现一个服务发现系统？一般包含以下四个部分：</p><ul><li><strong>服务注册</strong>——怎样将一个服务注册到服务发现代理？</li><li><strong>客户端查找</strong>——客户端查找服务信息（地址）的方式是什么？</li><li><strong>信息共享</strong>——节点之间如何共享服务信息？</li><li><strong>健康监测</strong>——服务们（services）如何将自己的健康状况报告给服务发现代理？</li></ul><p>除了依赖<strong>服务发现服务/引擎(service discovery services)</strong>来寻找服务外，客户端也可以通过缓存的方式进行负载均衡。</p><h4 id="4-2-2-使用Spring和Netflix-Eureka进行服务发现实战"><a href="#4-2-2-使用Spring和Netflix-Eureka进行服务发现实战" class="headerlink" title="4.2.2 使用Spring和Netflix Eureka进行服务发现实战"></a>4.2.2 使用Spring和Netflix Eureka进行服务发现实战</h4><p>在下面的例子中，我们将许可证（license）服务中包含的组织（organization）相关信息抽出来，放到许可证服务中。<strong>当许可证服务被调用时，它将调用组织服务以检索与指定的组织ID相关联的组织信息</strong>。组织服务的位置的实际解析存储在服务发现注册表中。</p><p><img src="/passages/SPMIA/client-load-balance.png" alt="client-load-balance"></p><h3 id="4-3-构建Spring-Eureka服务"><a href="#4-3-构建Spring-Eureka服务" class="headerlink" title="4.3 构建Spring Eureka服务"></a>4.3 构建Spring Eureka服务</h3><p>类似于构建配置服务器（Spring Cloud Config Server）</p><p>首先，添加maven依赖：<em>spring-cloud-starter-eureka-server</em>（使用Eureka库，包含Ribbon）。然后在application.yml中添加配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">  server:</span><br><span class="line">    waitTimeInMsWhenSyncEmpty: 5</span><br><span class="line">  serviceUrl:</span><br><span class="line">    defaultZone: http://localhost:8761</span><br></pre></td></tr></table></figure><p>设置Eureka服务器在8761（默认）端口监听；<strong>registerWithEureka</strong>设为空是因为，Eureka是个用于服务发现的服务器，可以让其它服务到自己这来注册，这个值是为需要通过Eureka注册自己的服务的组件提供的，所以设为false；<strong>fetchRegistry</strong>设为false是指，不要在本地缓存注册信息，因为这个也是给调用Eureka服务的客户端使用的（从路径也可以看出：*eureka.client.**；<strong>waitTimeInMsWhenSyncEmpty</strong>是指Eureka服务器启动后不会立即宣传已注册的服务，它将等待5分钟，以便所有的服务都注册完成，在本地测试时可以注释掉这行，加快测试过程；单个服务注册Eureka需要最多30s，因为Eureka需要收到来自服务的连续三次心跳ping，每次10s。</p><p>最后，在Eureka的启动类中，添加<strong>@EnableEurekaServer</strong>注解，表示启动服务器。</p><h3 id="4-4-使用Spring-Eureka注册服务"><a href="#4-4-使用Spring-Eureka注册服务" class="headerlink" title="4.4 使用Spring Eureka注册服务"></a>4.4 使用Spring Eureka注册服务</h3><p>启动了Eureka服务，之后就需要将服务注册到Eureka服务器。</p><p>首先，添加依赖：<em>spring-cloud-starter-eureka</em>。</p><p>然后，修改需要注册到Eureka的服务的配置文件application.yml。在bootstrap.yml中配置的<em>spring.application.name</em>就作为服务的ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    preferIpAddress: true</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: true</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><p><em>eureka.instace.preferIpAddress</em>为true是指用IP来注册服务而不是主机名；registerWithEureka和fetchRegistry都为true，因为这是要注册到Eureka的服务，且开启客户端缓存（每30s，客户端会重新与Eureka通信检查是否需要修改注册服务表）；<strong>serviceUrl</strong>：客户端通过这个地址定位已注册的服务，Eureka的高可用性就是通过这个做到的。可同时配置多个地址（用逗号隔开），当某些服务不可用时，可用服务节点之间会相互通信，保证被路由到合适的服务。</p><p>本次注册的是organizationservice，所以配置好后，启动应用，访问<em><a href="http://localhost:8761/eureka/apps/\" target="_blank" rel="noopener">http://localhost:8761/eureka/apps/\</a>&lt;APPID></em>就可以看到已注册的服务的信息。返回的服务状态信息默认是xml格式的，也可以以JSON格式输出（将请求方式改为POST，并把请求头的<strong>Accept</strong>值设为<em>application/json</em>）。</p><h3 id="4-5-使用服务发现来查找服务"><a href="#4-5-使用服务发现来查找服务" class="headerlink" title="4.5 使用服务发现来查找服务"></a>4.5 使用服务发现来查找服务</h3><p>服务注册完了后，可以进行调用了。我们使用licensingservice来调用organizationservice，调用时不需要知道organizationservice的地址，使用Netflix客户端，服务消费者可以和<strong>Ribbon</strong>交互。从低到高层次（越高封装越多）的和Ribbon交互的客户端有：</p><ul><li>Spring Discovery client</li><li>Spring Discovery client enabled RestTemplate</li><li>Netflix Feign client</li></ul><h4 id="4-5-1-使用Spring-DiscoverClient查找服务实例"><a href="#4-5-1-使用Spring-DiscoverClient查找服务实例" class="headerlink" title="4.5.1 使用Spring DiscoverClient查找服务实例"></a>4.5.1 使用Spring DiscoverClient查找服务实例</h4><p><strong>DiscoveryClient与实际运用</strong>                                                                          </p><h4 id="4-5-2-使用Spring-RestTemplate（Ribbon-aware）调用服务"><a href="#4-5-2-使用Spring-RestTemplate（Ribbon-aware）调用服务" class="headerlink" title="4.5.2 使用Spring RestTemplate（Ribbon-aware）调用服务"></a>4.5.2 使用Spring RestTemplate（Ribbon-aware）调用服务</h4><h4 id="4-5-3-使用Netflix-Feign客户端调用服务"><a href="#4-5-3-使用Netflix-Feign客户端调用服务" class="headerlink" title="4.5.3 使用Netflix Feign客户端调用服务"></a>4.5.3 使用Netflix Feign客户端调用服务</h4><h2 id="5-构建客户端弹性模型——Netflix-Hystrix"><a href="#5-构建客户端弹性模型——Netflix-Hystrix" class="headerlink" title="5 构建客户端弹性模型——Netflix Hystrix"></a>5 构建客户端弹性模型——Netflix Hystrix</h2><p>在基于云的环境中，<strong>检测出系统组件crash</strong>比较容易，<strong>检测出组件running slow</strong>却很难，因为：</p><ul><li><strong>服务可能一点一点变坏</strong>——服务的崩溃可能由很小的征兆开始，即服务不是一下子就崩溃的。可能开始是一些用户发现了一点问题，直到某一刻突然线程池被耗尽并彻底崩溃。</li><li><strong>对远程服务的调用通常是同步的，不会缩短调用时间</strong>——服务的调用没有超时的概念，开发人员调用服务并等待服务返回（一直）。</li><li><strong>应用更擅长处理远程资源的彻底故障，而不是部分退化（degradation）</strong>——只要没有彻底崩溃，应用会一直调用尽管运行情况很糟糕的服务，直到资源耗尽。</li></ul><h3 id="5-1-什么是客户端弹性模型？"><a href="#5-1-什么是客户端弹性模型？" class="headerlink" title="5.1 什么是客户端弹性模型？"></a>5.1 什么是客户端弹性模型？</h3><p>客户端弹性模型的目的就是使客户端<strong>fail fast</strong>。包括：</p><ol><li>客户端负载均衡模式</li><li>断路器（circuit breaker）模式</li><li>后备（fallback）模式</li><li>舱壁（bulkhead）模式</li></ol><p>四个模式之间的配合如下图：</p><p><img src="/passages/SPMIA/client-resiliency.png" alt="client-resiliency"></p><h4 id="5-1-1-客户端负载均衡"><a href="#5-1-1-客户端负载均衡" class="headerlink" title="5.1.1 客户端负载均衡"></a>5.1.1 客户端负载均衡</h4><p>客户端负载均衡要做的事情就是，客户端从服务发现代理（如Netflix Eureka）那里查找服务实例的时候，会将实例的物理地址缓存下来。当服务的消费者（consumer）需要调用服务实例时，<strong>客户端load balancer</strong>将会从自己维护的一个地址池<strong>（service locations pool）</strong>中返回一个地址。</p><p>客户端负载均衡器是存在于服务客户端和服务消费者之间的，它可以检测服务实例的运行情况。监测到问题后，可以将对应的服务实例从可用服务地址池中移出，阻止对那个服务实例的调用。</p><p>这就是<strong>Netflix Ribbon</strong>库所做的，开箱即用。</p><h4 id="5-1-2-断路器模式"><a href="#5-1-2-断路器模式" class="headerlink" title="5.1.2 断路器模式"></a>5.1.2 断路器模式</h4><p>断路器模式是模仿电路断路器的工作方式。电路系统中，断路器如果监测到电路中电流过大，会断路，以防止下游部件被烧毁 。</p><p>类比过来，软件断路器的作用就是，若调用某个远程服务花费时间过长，断路器就会介入并中断调用。断路器将监视所有对远程资源的调用，如果调用失败次数足够多，断路器就会启动。</p><h4 id="5-1-3-后备模式"><a href="#5-1-3-后备模式" class="headerlink" title="5.1.3 后备模式"></a>5.1.3 后备模式</h4><p>通过后备模式，当服务失败时，不是立马抛出异常，而是尝试换一个路径执行。这通常涉及从另一个数据源查找数据、将请求排队等待后续处理等。</p><p>比如，你的电子商务网站需要监控用户行为并据此做出推荐。通常你可以调用微服务来分析该用户的历史购买行为（记录），并据此做出分析。如果此微服务失败了，那么后备处理可能就是查询“所有”用户的购买记录并分析，这些数据可能来自一个完全不同的服务和数据源。</p><h4 id="5-1-4-舱壁模式"><a href="#5-1-4-舱壁模式" class="headerlink" title="5.1.4 舱壁模式"></a>5.1.4 舱壁模式</h4><p>舱壁模式基于一个概念——在造船的时候，船舱的设计可以将每个隔间的“危险情况”隔离在内部。当船身破裂，每个船舱还是可以保护行人的（？？？那Titanic是怎么回事？每个船舱都挂了吗）</p><p>同样的概念运用到微服务就是当一个服务要和多个远程资源交互时，使用舱壁模式，你可以<strong>将对不同远程资源的调用分离到不同的线程池</strong>，来降低风险。某个服务响应速度变慢，处理同类型服务调用的线程池将变得饱和，不再接收请求。</p><h3 id="5-2-为什么客户端弹性很重要？"><a href="#5-2-为什么客户端弹性很重要？" class="headerlink" title="5.2 为什么客户端弹性很重要？"></a>5.2 为什么客户端弹性很重要？</h3><p>简而言之，就是当A服务调用B服务，B服务又调用C服务…很多个服务调用形成了一条链，一旦被很多服务调用的“源头”出现问题，就可能会导致后面很多服务的崩溃。</p><p>当服务B发现服务C响应缓慢时，断路器会设置一个timer来检测请求被处理的时间，若计时器超时后服务B还没有得到响应，就会收到一个error，并且断路器开始记录error的个数；如果一段时间内error次数过多，所有调用服务C的请求都会直接被拒绝（强行fail）。</p><p>当被断路器强行插手解决问题时，有三个好处：</p><ol><li>B服务知道前方有问题了，不需要再等断路器的超时通知了</li><li>B服务可以决定自己<strong>是fail还是另寻出路（后备模式）</strong></li><li>给了服务C一点时间和空间去恢复自己</li></ol><p>断路器的存在使得远程调用可以：</p><ol><li><strong>Fail fast</strong>——防止事情进一步恶化</li><li><strong>Fail gracefully</strong>——断路器使得应用开发者们可以在意外发生时另寻他法，如从其他数据源检索数据</li><li><strong>Recover seamlessly</strong>——断路器可以负责查询资源是否可用，服务是否恢复，并开发访问接口</li></ol><h3 id="5-3-使用Hystrix"><a href="#5-3-使用Hystrix" class="headerlink" title="5.3 使用Hystrix"></a>5.3 使用Hystrix</h3><p>构建和实现断路器模式、后备模式和舱壁模式，需要对线程和线程管理有很深的理解。Netflix的Hystrix库在微服务架构中久经考验，你可以使用它构建强大的客户端弹性模型。需要做的包括：</p><ul><li>在licensingservice的pom.xml中添加Spring Cloud/Hystrix依赖。</li><li>使用Spring Cloud/Hystrix标记（annotations）来将远程调用包装成断路器模式。</li><li>为每一个<strong>远程资源-断路器</strong>定制超时时间。可以设定一个断路器强行接管控制之前，failure的次数。</li><li>为服务设计后备模式策略（fallback strategy），以在断路器生效时起作用。</li><li>为每个远程调用设立单独的线程池，并使用舱壁模式将不同的远程资源隔离开，</li></ul><h3 id="5-4-配置licensing服务器"><a href="#5-4-配置licensing服务器" class="headerlink" title="5.4 配置licensing服务器"></a>5.4 配置licensing服务器</h3><p>在licensingservice的pom.xml中添加<strong>spring-cloud-starter-hystrix</strong>和<strong>hystrix-javanica</strong>，并制定hystrix-javanica的版本为1.5.9。实际上，spring-cloud-starter-hystrix中以及包含了hystrix-javanica，但是<strong>Cmamden.SR5</strong>版本的Spring Cloud包含的是1.5.6的hystrix-javanica，其中的一个问题是：如果Hystrix代码没有后备，会跑出一个<em>java.lang.reflect.UndeclaredThrowableException</em>异常而不是<em>com.netflix.<br>hystrix.exception.HystrixRuntimeException</em>，于是单独声明一下后者的版本，从maven拉取一个不同版本的包。</p><p>然后在需要使用断路器模式的服务的启动类上加上注解<strong>@EnableCircutBreaker</strong>就行了。</p><h3 id="5-5-使用Hystrix实现一个断路器"><a href="#5-5-使用Hystrix实现一个断路器" class="headerlink" title="5.5 使用Hystrix实现一个断路器"></a>5.5 使用Hystrix实现一个断路器</h3><p>我们将看到两大类的Hystrix实现：<strong>对数据库的调用</strong>和<strong>内部服务调用</strong>。如图：</p><p><img src="/passages/SPMIA/hystrix-two-cases.png" alt="hystrix-two-cases"></p><p>两种类型调用中，Hystrix的使用是类似的。</p><p>首先，看一下如何使用一个同步的Hystrix断路器来控制从licensing数据库检索licensing服务的数据。通过同步方式调用，许可证服务将会检索数据，同时它会等到SQL语句执行完成，或者断路器提示超时。</p><p>通过添加<em>@HystrixCommand</em>注解，方法被标记为一个Hystrix断路器，Spring框架会为其生成一个动态代理，将所有调用此方法的请求放到一个线程池中处理。尽管看起来没有写多少代码，但是可以实现很多功能。断路器会中断任何超过1000ms的调用。</p><p>因为我是在本地启动的数据库，所以如果数据库没问题，可能断路器一直不需要工作。因此，在方法中加入一些【人工延迟】，来模拟响应缓慢的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">randomlyRunLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> randomNum = rand.nextInt((<span class="number">3</span> - <span class="number">1</span>) + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (randomNum==<span class="number">3</span>) sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个随机数（取值【0|1|2】+1），当值为3时，线程休眠11000ms。sleep()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">11000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在访问<a href="http://localhost:8082/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a/licenses/，多刷新几次，会发现出现了超时错误，这就说明我们的断路器起作用了，由于数据库操作超时导致抛出了*com.netflix" target="_blank" rel="noopener">http://localhost:8082/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a/licenses/，多刷新几次，会发现出现了超时错误，这就说明我们的断路器起作用了，由于数据库操作超时导致抛出了*com.netflix</a>.<br>hystrix.exception.HystrixRuntimeException*异常。</p><p><img src="/passages/SPMIA/HystrixRuntimeException.png" alt="HystrixRuntimeException"></p><h4 id="5-5-1-对organizationservice的调用超时"><a href="#5-5-1-对organizationservice的调用超时" class="headerlink" title="5.5.1 对organizationservice的调用超时"></a>5.5.1 对organizationservice的调用超时</h4><p>使用方法级的标记（断路器）的好处就是，它不区分你是在访问数据库还是调用另一个微服务。</p><p><strong>注意</strong></p><p>使用<em>@HystrixCommand</em>标记尽管很容易，但是使用默认的标记可能有问题。因为默认的标记会将所有的远程调用放到同一个线程池中，下面的章节实现了舱壁模式，其中自定义了<em>@HystrixCommand</em>标记的一些参数。</p><h4 id="5-5-2-定制断路器的超时时间"><a href="#5-5-2-定制断路器的超时时间" class="headerlink" title="5.5.2 定制断路器的超时时间"></a>5.5.2 定制断路器的超时时间</h4><p>定制断路器的超时时间，只需要在<em>@HystrixCommand</em>标记上增加对应的参数<strong>timeoutInMilliseconds</strong>即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(commandProperties= &#123;<span class="meta">@HystrixProperty</span>(</span><br><span class="line">               name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value=<span class="string">"12000"</span>)&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">getLicensesByOrg</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">randomlyRunLong();</span><br><span class="line"><span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commandProperties中可以添加很多@HystrixProperty，每一个属性由一个name和一个value构成。</p><p>类似commandProperties，也可以设置threadPoolProterties的参数。</p><p><strong>关于服务超时</strong></p><blockquote><p>显然，12s的断路器超时只是我用来作为教学的例子。在分布式环境中，如果我听到开发团队反馈，说远程服务调用上的1s超时时间太少了，因为他们的服务平均需要5-6s的时间，那么我会经常感到紧张。</p><p>这些反馈通常告诉我，被调用的服务存在为解决的性能问题。开发人员应该避免在Hystrix调用上增加默认超时时间的诱惑，除非实在无法解决运行缓慢的服务调用。</p><p><strong>如果确实遇到一些比其他服务调用需要更长时间的服务调用，务必将这些服务调用隔离到单独的线程池中。</strong></p></blockquote><h3 id="5-6-后备处理（fallback）"><a href="#5-6-后备处理（fallback）" class="headerlink" title="5.6 后备处理（fallback）"></a>5.6 后备处理（fallback）</h3><p>断路器模式的【美妙之处】在于，<em>中间商是可以赚差价的</em></p><p>嗯？？其实就是，远程资源的消费者和其本身之间存在一个中介，每当有请求，中介会拦截下来，为你选择最安全、效率最高的服务；当出现异常情况，中介也可以选择一个备用方法来执行（前提是你写了备用方法，因为它只有使用fallback的机制，但没有创造fallback的机制）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod = <span class="string">"buildFallbackLicenseList"</span>)</span><br><span class="line">public List&lt;License&gt; getLicensesByOrg(<span class="built_in">String</span> organizationId) &#123;</span><br><span class="line">randomlyRunLong();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private List&lt;License&gt; buildFallbackLicenseList(<span class="built_in">String</span> organizationId) &#123;</span><br><span class="line">List&lt;License&gt; fallbackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">License license = <span class="keyword">new</span> License()</span><br><span class="line">.withId(<span class="string">"0000000-00-00000"</span>)</span><br><span class="line">.withOrganizationId(organizationId)</span><br><span class="line">.withProductName(<span class="string">"Sorry no licensing information currently available"</span>);</span><br><span class="line"></span><br><span class="line">    fallbackList.add(license);</span><br><span class="line"><span class="keyword">return</span> fallbackList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“正常工作”的方法上添加HystrixCommand标记，并设置其fallbackMethod，并在下方写上fallback方法实现，且两个方法的返回值和参数需相同。当服务无法正常工作时，会调用fallback方法处理。</p><p>现在，连续调用几次licensingservice服务，请求超时时会由fallback方法处理：</p><p><img src="/passages/SPMIA/fallbackMethod.png" alt="fallbackMethod"></p><h3 id="5-7-实现舱壁模式"><a href="#5-7-实现舱壁模式" class="headerlink" title="5.7 实现舱壁模式"></a>5.7 实现舱壁模式</h3><p>在@HystrixCommand标记中添加参数：<em>threadPoolKey、threadPoolProperties</em></p><p>threadPoolKey是说为指定的方法建立一个新的Hystrix线程池来处理。</p><p>threadPoolProperties可以配置两个参数，<code>name=&quot;coreSize&quot;, value=&quot;30&quot;</code>指定线程池大小；<code>name=&quot;maxQueueSize&quot;, value=&quot;10&quot;</code>指定队列中线程数量，即当线程池满时可以排队等待的请求数量；</p><h3 id="5-8-基础进阶——微调Hystrix"><a href="#5-8-基础进阶——微调Hystrix" class="headerlink" title="5.8 基础进阶——微调Hystrix"></a>5.8 基础进阶——微调Hystrix</h3><p>至此，我们已经学会了如何使用Hystrix实现断路器和舱壁模式。接下来我们要对断路器的行为进行定制化微调（customize）（通过修改参数，使Hystrix的工作模式更符合我们的实际情况）。记住，<strong>Hystrix能做的不只是将长时间的远程调用设为超时，Hystrix还可以监控调用失败的次数</strong>。当一个服务调用失败次数过多，Hystrix会自动阻止来自远程的调用（即请求无法到达远程资源）。</p><p>这样做<strong>（failing fast）</strong>有两个好处：<strong>1. 客户端不会一直调用并等待超时信号发出；2. 服务端不会很快挂掉，有一个恢复时间</strong>。</p><p>每当一个Hystrix命令遇到服务错误时，它会启动一个10s的计时器，来检查服务失败的频率。10s的窗口大小是可配置的。首先Hystrix会检查10s内发生了几次调用，<strong>如果调用次数少于窗口内可以发生调用次数的最小值，那么及时这些调用全部失败，Hystrix也不会fail fast</strong>（自动阻止来自远程的调用）。例如，10s内Hystrix会执行fail fast的默认调用次数为20，那么如果10s内有15个调用都失败了，Hystrix不会启动fail fast，调用仍会到达远程服务。</p><p>如果远程调用的失败次数在10s内达到最小值后，Hystrix将会查看整体故障的百分比。如果比例超过了阈值（默认50%），Hystrix将对所有远程调用触发断路器并让其失效。<strong>同时，它会在此过程中，不断试探故障是否恢复，通过<u>定时开闸</u>的方式。</strong>即，它会开启一个新的活动窗口，每5s它会让一个请求通过，如果请求成功，则Hystrix会重置断路器，放开请求通道；否则，过5s继续尝试。</p><p>因此，我们可以通过以下参数来控制我们的断路器工作效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(commandProperties = &#123;</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span>, value = <span class="string">"75"</span>),</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>, value = <span class="string">"7000"</span>),</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"metrics.rollingStats.timeInMilliseconds"</span>, value = <span class="string">"15000"</span>)，</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"metrics.rollingStats.numBuckets"</span>, value = <span class="string">"5"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>requestVolumeThreshold</strong>：Hystrix将断路器断闸之前，10s内接收到的连续的调用个数</p><p><strong>errorThresholdPercentage</strong>：整体调用失败（由于超时、抛出异常或返回HTTP 500）的百分比。超过后Hystrix会执行fail fast。</p><p><strong>sleepWindowInMilliseconds</strong>：断路器跳闸之后，Hystrix允许另一个调用通过以便查看是否恢复健康之前Hystrix的休眠时间。</p><p><strong>timeInMilliseconds</strong>：监视服务调用情况的窗口大小。</p><p><strong>numBuckets</strong>：统计窗口中失败次数的数据。Hystrix将统计数据放到bucket中，以此判断调用是否失败。timeInMilliseconds的值必须能被numBuckets整除，如timeInMilliseconds为15000（15s）的同时numBuckets为3或5。</p><p>检查失败次数的统计窗口越小且bucket数量越多，月耗费CPU和内存资源。因此，要酌情设计窗口大小和bucket数量。</p><h4 id="5-8-1-重新审视Hystrix配置"><a href="#5-8-1-重新审视Hystrix配置" class="headerlink" title="5.8.1 重新审视Hystrix配置"></a>5.8.1 重新审视Hystrix配置</h4><p>配置Hystrix时，可以设置不同的级别（level）：</p><ol><li>应用程序级别的默认值</li><li>类级别的默认值</li><li>在类中定义的线程池级别</li></ol><p>通过在类级别设置默认参数，可以是类中所有Hystrix命令享有相同的配置。类级别属性通过<strong>@DefaultProperties</strong>的类级注解设置。除非希望在某线程池上显示地覆盖，否则所有线程池都将继承应用程序级别的默认设置或类中定义的默认设置。</p><h3 id="5-9-线程上下文和Hystrix"><a href="#5-9-线程上下文和Hystrix" class="headerlink" title="5.9 线程上下文和Hystrix"></a>5.9 线程上下文和Hystrix</h3><p>当一个<em>@HystrixCommand</em>被执行时，它可以使用两种不同的隔离策略来运行：<strong>THREAD</strong>和<strong>SEMAPHORE</strong>。默认使用THREAD方式。使用线程方式隔离，Hystrix命令可以将调用格力在一个线程池中运行，不会将它的上下文和调用它的父线程共享。这样Hystrix可以随时中断线程的执行，不必担心会影响到调用它的父线程。</p><p>使用基于信号量的隔离方式，Hystrix管理由@HystrixCommand注解保护的分布式调用，不需要启动新线程，若调用超时，就会中断父线程。在同步容器服务器环境（Tomcat）中，中断父线程将会导致开发人员无法捕获异常。</p><p>要设置隔离方式，可以在commandProperties参数中添加<code>@HystrixProperty(name=&quot;execution.isolation.strategy&quot;, value=&quot;SEMAPHORE&quot;)</code>。</p><p><strong>注意：</strong></p><p>默认情况下，推荐使用<em>THREAD</em>隔离方式。这使你和父进程间保持了一个高层次的隔离。THREAD方式比SEMOPHORE方式更重，SEMOPHORE更轻量级。SEMOPHORE更适合服务量很大且使用异步I/O编程模型（如Netty）运行的情况。</p><h4 id="5-9-1-ThreadLocal和Hystrix"><a href="#5-9-1-ThreadLocal和Hystrix" class="headerlink" title="5.9.1 ThreadLocal和Hystrix"></a>5.9.1 ThreadLocal和Hystrix</h4><p>Hystrix在默认情况下不会将父级的上下文传递到由Hystrix命令管理的线程中。如，<strong>父线程中的ThreadLocal值在被此线程调用的线程（子线程，且使用@HystrixCommand标记）的方法中不能使用</strong>（默认隔离方式为THREAD情况时）。</p><p>举个例子说明。通常在一个基于REST的环境中，你想给某个服务调用传递一个上下文信息，以便于管理这个服务。比如，可以在HTTP请求头传递一个<strong>关联ID（correlationID）</strong>或者<strong>认证token</strong>，可以在下游所有的服务中调用。关联ID是唯一标识符，可用于在单个事务中跨多个服务调用进行追踪。</p><p><strong>要在所有服务调用中使用这个值，可以用一个Spring Filter类来拦截所有调用该REST服务的请求，从HTTP请求头中检索该信息，并将之存储到自定义的UserContext对象中。这样，在任何REST服务调用中要使用这个值时，可以从ThreadLocal存储变量中检索UserContext并读取其值。</strong>以下代码展示了如何在licensingservice中使用过滤器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UserContextFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">UserContextHolder</span><br><span class="line">    .getContext()</span><br><span class="line">    .setCorrelationId(httpServletRequest.getHeader(UserContext.CORRELATION_ID) );         UserContextHolder</span><br><span class="line">            .getContext()</span><br><span class="line">            .setUserId(httpServletRequest.getHeader(UserContext.USER_ID));         UserContextHolder</span><br><span class="line">            .getContext()</span><br><span class="line">            .setAuthToken(httpServletRequest.getHeader(UserContext.AUTH_TOKEN));        UserContextHolder</span><br><span class="line">            .getContext()</span><br><span class="line">            .setOrgId(httpServletRequest.getHeader(UserContext.ORG_ID));</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"UserContextFilter Correlation id: &#123;&#125;"</span>,  UserContextHolder.getContext().getCorrelationId());</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(httpServletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>UserContextHolder</strong>类用来<strong>在ThreadLocal中存储UserContext</strong>。一旦存储在ThreadLocal中，任何为请求执行的代码都会使用存储在UserContextHolder中的UserContext对象。UserContextHolder类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserContext&gt; userContext = <span class="keyword">new</span> ThreadLocal&lt;UserContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> UserContext <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserContext context = userContext.get();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = createEmptyContext();</span><br><span class="line">            userContext.set(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userContext.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(UserContext context)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(context, <span class="string">"Only non-null UserContext instances are permitted"</span>);</span><br><span class="line">        userContext.set(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> UserContext <span class="title">createEmptyContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以在许可证服务中添加一些日志了，以便测试。</p><ul><li>在/licenses/utils/UserContextFilter.java中的doFilter()方法</li><li>/licenses/controllers/LicenseServiceController.java中的getLicenses()方法</li><li>/licenses/services/LicenseService.java中的getLicenseByOrg()方法，此方法是使用@HystrixCommand标记的</li></ul><p>现在可以在调用license服务时加上一个HTTP header：</p><table><thead><tr><th>key</th><th></th></tr></thead><tbody><tr><td>tmx-correlation-id</td><td>TEST-CORRELATION-ID</td></tr></tbody></table><p>再次访问 <a href="http://localhost:8081/v1/organizations/e254f8c-c442-4ebe-a82ae2fc1d1ff78a/licenses/会发现在控制台中打印了三条日志信息：" target="_blank" rel="noopener">http://localhost:8081/v1/organizations/e254f8c-c442-4ebe-a82ae2fc1d1ff78a/licenses/会发现在控制台中打印了三条日志信息：</a></p><blockquote><p> UserContextFilter Correlation id: TEST-CORRELATION-ID</p><p>LicenseServiceController Correlation id: TEST-CORRELATION-ID</p><p>LicenseService.getLicensesByOrg  Correlation id: </p></blockquote><p>可以看到，<strong>由@HystrixCommand标记的方法<em>LicenseService.getLicensesByOrg()</em>没有打印出correlationID</strong>，这是因为它没有找到当前线程的UserContext。我们可以通过Spring Cloud和Hystrix提供的并发策略机制来实现上下文的传递。</p><h4 id="5-9-2-HystrixConcurrencyStrategy实战"><a href="#5-9-2-HystrixConcurrencyStrategy实战" class="headerlink" title="5.9.2 HystrixConcurrencyStrategy实战"></a>5.9.2 HystrixConcurrencyStrategy实战</h4><p>Hystrix允许你定义自己的并发策略来包装你的Hystrix调用，并将父线程的上下文注入到有Hystrix命令管理的子线程中。实现HystrixConcurrencyStrategy，你需要做以下三件事：</p><ol><li>定义自己的Hystrix并发策略类</li><li>定义一个Java <strong>Callable</strong>类，将UserContext注入Hystrix命令中</li><li>配置Spring Cloud来使用自定义的Hystrix并发策略</li></ol><p><strong>自定义Hystrix并发策略类</strong></p><p>Hystrix<strong>只允许</strong>你为一个应用定义一个并发策略。Spring Cloud已经定义好了一个并发策略，用来处理Spring security的信息。你可以将自己定义的并发策略和Spring Cloud提供的集成到一起，作为Hystrix并发策略。</p><p>我们通过<em>ThreadLocalAwareStrategy.java</em>来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalAwareStrategy</span> <span class="keyword">extends</span> <span class="title">HystrixConcurrencyStrategy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HystrixConcurrencyStrategy existingConcurrencyStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocalAwareStrategy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HystrixConcurrencyStrategy existingConcurrencyStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.existingConcurrencyStrategy = existingConcurrencyStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">wrapCallable</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> existingConcurrencyStrategy != <span class="keyword">null</span></span><br><span class="line">                ? existingConcurrencyStrategy</span><br><span class="line">                .wrapCallable(<span class="keyword">new</span> DelegatingUserContextCallable&lt;T&gt;(callable, UserContextHolder.getContext()))</span><br><span class="line">                : <span class="keyword">super</span>.wrapCallable(<span class="keyword">new</span> DelegatingUserContextCallable&lt;T&gt;(callable, UserContextHolder.getContext()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个并发策略类，继承HystrixConcurrencyStrategy，Spring Cloud已经有了一个并发策略类，所以构造方法中需要传入现有的currency strategy。在<strong>wrapCallable()</strong>方法中，传入一个<strong>Callable</strong>变量，<strong>DelegatingUserContextCallable</strong>方法负责将父线程（执行REST服务调用的线程）的UserContext传入Hystrix命令标记的方法中。</p><p><strong>定义一个Java Callable类来将UserContext注入Hystrix命令</strong></p><p>接下来就是实现如何将父线程的context传入Hystrix命令中。通过<strong>DelegatingUserContextCallable.java</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingUserContextCallable</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; delegate;</span><br><span class="line">    <span class="keyword">private</span> UserContext originalUserContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingUserContextCallable</span><span class="params">(Callable&lt;V&gt; delegate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             UserContext userContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="keyword">this</span>.originalUserContext = userContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserContextHolder.setContext( originalUserContext );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.call();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.originalUserContext = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">Callable&lt;V&gt; <span class="title">create</span><span class="params">(Callable&lt;V&gt; delegate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         UserContext userContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatingUserContextCallable&lt;V&gt;(delegate, userContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，DelegatingUserContextCallable类包含一个Callable对象（用来调用有<em>@HystrixCommand</em>标记的方法），一个UserContext对象（用来保存从父线程传入的UserContext）。设置好UserContext，存储UserContext的ThreadLocal变量就和有Hystrix标记的线程关联起来了。下面<code>try{}</code>中的call方法只是一个模板，实际使用时改成相应的代码（即有Hystrix标记的方法，如<strong><em>LicenseServer.getLicenseByOrg()</em></strong>）。</p><p><strong>配置Spring Cloud来使用你自己的Hystrix并发策略</strong></p><p>定义好了<strong>Hystrix并发策略</strong>和<strong>线程上下文传递方法</strong>，我们需要将它们告诉Spring Cloud和Hystrix。为此，我们新建一个配置类<strong>ThreadLocalConfiguration</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">private</span> HystrixConcurrencyStrategy existingConcurrencyStrategy;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Keeps references of existing Hystrix plugins.</span></span><br><span class="line">            HystrixEventNotifier eventNotifier = HystrixPlugins.getInstance()</span><br><span class="line">                    .getEventNotifier();</span><br><span class="line">            HystrixMetricsPublisher metricsPublisher = HystrixPlugins.getInstance()</span><br><span class="line">                    .getMetricsPublisher();</span><br><span class="line">            HystrixPropertiesStrategy propertiesStrategy = HystrixPlugins.getInstance()</span><br><span class="line">                    .getPropertiesStrategy();</span><br><span class="line">            HystrixCommandExecutionHook commandExecutionHook = HystrixPlugins.getInstance()</span><br><span class="line">                    .getCommandExecutionHook();</span><br><span class="line"></span><br><span class="line">            HystrixPlugins.reset();</span><br><span class="line"></span><br><span class="line">            HystrixPlugins.getInstance().registerConcurrencyStrategy(<span class="keyword">new</span> ThreadLocalAwareStrategy(existingConcurrencyStrategy));</span><br><span class="line">            HystrixPlugins.getInstance().registerEventNotifier(eventNotifier);</span><br><span class="line">            HystrixPlugins.getInstance().registerMetricsPublisher(metricsPublisher);</span><br><span class="line">            HystrixPlugins.getInstance().registerPropertiesStrategy(propertiesStrategy);</span><br><span class="line">            HystrixPlugins.getInstance().registerCommandExecutionHook(commandExecutionHook);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@Autowired</em>：当配置类对象被构造时，它将会autowire（自动装配）现有的HystrixConcurrencyStrategy。</p><p>注册自己的并发策略前，先拿到所有的Hystrix组件（如<strong>getEventNotifier()</strong>）；重置；然后注册自己的并发策略并将组件添加进去。最关键的一句，注册自己的并发策略——<code>HystrixPlugins.getInstance().registerConcurrencyStrategy(new ThreadLocalAwareStrategy(existingConcurrencyStrategy));</code></p><p>现在，重新构建并重启服务，通过GET请求访问 <a href="http://localhost:8081/v1/organizations/e254f8c-c442-4ebe-a82ae2fc1d1ff78a/licenses/" target="_blank" rel="noopener">http://localhost:8081/v1/organizations/e254f8c-c442-4ebe-a82ae2fc1d1ff78a/licenses/</a> ，会发现被@HystrixCommand标记的方法也成功地找到了<strong>【TEST-CORRELATION-ID】</strong> ，表明UserContext成功由父线程（调用服务的线程）传入被Hystrix标记的线程。</p><p>打印出的日志信息：</p><blockquote><p>UserContextFilter Correlation id: TEST-CORRELATION-ID</p><p>LicenseServiceController Correlation id: TEST-CORRELATION-ID</p><p>LicenseService.getLicensesByOrg  Correlation id: TEST-CORRELATION-ID</p></blockquote><h2 id="6-服务路由——Zuul"><a href="#6-服务路由——Zuul" class="headerlink" title="6 服务路由——Zuul"></a>6 服务路由——Zuul</h2><p>在分布式架构（如微服务）中，你需要确保安全（security）、日志（logging）、用户追踪（tracking of users）这样的活动在多个服务调用中能够正常发生，并且尽量在所有服务中一致的实现这些特性，而不需要每个开发团队构建自己的解决方法。尽管可以使用<strong>公共库或框架</strong>来在单个服务中构建这些功能，但这样做有三个影响：</p><p><strong>第一，在构建的每个服务中很难始终实现这些功能。</strong>开发人员专注于交付功能，在每日的快速开发工作中，他们很容易忘记实现服务日志或跟踪。尤其是对于那些在金融服务或医疗保健等严格监管的行业工作的人来说，一致且用文档来记录系统中的行为通常是符合政府法规的要求。</p><p><strong>第二，正确地发现这些功能是一个挑战。</strong>对每个正在开发的服务进行诸如<strong>微服务安全</strong>的建立与配置可能是很痛苦的。将实现cross-cutting关注点（如安全问题）的责任推给下面的开发团队将会增加开发人员忘记实现或没有正确实现这些功能的可能性。</p><p><strong>第三，这将会在所有服务中创建一个hard dependency</strong>。在所有服务中共享的公共框架中创建的功能越多，想要添加/更改功能就越困难，往往需要重写编译、部署。共享库中的核心功能的升级可能成为一个数月的迁移过程。</p><p>为了解决这个问题，将这些横切关注点（cross-cutting concerning）抽象成一个独立的且作为应用程序中<strong>所有服务调用的过滤器和路由器的服务</strong>很有必要。这种横切关注的叫做<strong>服务网关</strong>。服务客户端不再直接调用服务，而是通过服务网关（作为单个策略执行点（Policy Enforcement Point，PEP）），进行路由，到达最终目的地。</p><p>本章，使用Spring Cloud和Zuul来实现服务网关。要实现的有：</p><ul><li>把所有服务调用放到一个唯一的URL后，将调用请求做映射（通过服务发现机制）</li><li>把correlation ID注入到每个经过服务网关的服务中</li><li>把correlation ID注入到从客户端发回的响应中</li><li>构建一个动态路由机制，将具体的organizations服务（被调用服务）路由到某个不同的服务实例端点（负载均衡）</li></ul><h3 id="6-1-服务网关是什么"><a href="#6-1-服务网关是什么" class="headerlink" title="6.1 服务网关是什么"></a>6.1 服务网关是什么</h3><p>目前为止，我们已经会用两种方式调用服务了——web client或服务发现引擎（如Eureka）</p><p>服务网关存在于服务客户端与服务之间，作为调用服务时的统一中间件。</p><p>可以在服务网关中实现的<strong>横切关注点（每个/多数服务都要用的）</strong>有：</p><ul><li><strong>静态路由</strong>——通过统一URL调用服务，不必知道每个服务的具体端点（一般需要知道服务名）</li><li><strong>动态路由</strong>——根据请求/数据的不同，动态的进行路由。如，参与测试版（beta）程序的客户可能会被路由到特定服务集群的服务，与正常版不同。</li><li><strong>认证、授权</strong>——因为所有服务调用都要通过网关，所以在这里做认证/授权很方便，验证服务调用者是否经过认证，并有权限调用相应服务。</li><li><strong>度量数据收集和日志记录</strong>——网关可以收集度量数据和日志信息当服务调用经过时，还可以确保在用户请求上提供关键信息<strong>以确保日志统一</strong>。这并不意味着不需要从单个服务中收集度量数据，而是<strong>通过服务网关可以集中收集许多基本度量数据，如服务调用次数和服务响应时间</strong>。</li></ul><p><strong>且慢——服务网关不会造成单点故障吗？</strong></p><blockquote><p>前面说过，集中式负载均衡器会造成单点故障和性能瓶颈，若没有正确实现，服务网关也会有同样风险。因此要记住一下几点：</p><p><strong>在单独的服务组前面，负载均衡器仍然很有用</strong>。</p><p><strong>要保持为服务网关编写的代码是无状态的</strong>。</p><p><strong>要保持为服务网关编写的代码是轻量的</strong>。</p></blockquote><h3 id="6-2-Spring-Cloud和Netflix-Zuul"><a href="#6-2-Spring-Cloud和Netflix-Zuul" class="headerlink" title="6.2 Spring Cloud和Netflix Zuul"></a>6.2 Spring Cloud和Netflix Zuul</h3><p>要使用Zuul，首先要做一些准备工作：</p><ol><li>引入依赖</li><li>修改项目代码，将服务加上合适的标记以表明它是一个Zuul服务</li><li>配置Zuul来和Eureka通信（可选）</li></ol><p>注意：第三点中，若使用了服务发现引擎，则请求来到服务网关后，服务网关还需要“查表”（与服务发现引擎通信），才能知道具体的服务实例端点。</p><h4 id="6-2-1-构建Zuul项目"><a href="#6-2-1-构建Zuul项目" class="headerlink" title="6.2.1 构建Zuul项目"></a>6.2.1 构建Zuul项目</h4><p>即构建一个Zuul服务器，用来作服务网关。首先添加依赖<em>spring-cloud-starter-zuul</em></p><h4 id="6-2-2-为Zuul服务使用Spring-Cloud注解"><a href="#6-2-2-为Zuul服务使用Spring-Cloud注解" class="headerlink" title="6.2.2 为Zuul服务使用Spring Cloud注解"></a>6.2.2 为Zuul服务使用Spring Cloud注解</h4><p>在zuulsvr这个module中新建启动类，并增加<em>@EnableZuulProxy</em>注解，使服务成为一个服务器。</p><p><strong>注意：</strong></p><p>如果你开启了自动补全（IDE），你可能注意到还有一个注解叫<em>@EnableZuulServer</em>。两者的区别就是<em>@EnableZuulServer</em>不会加载Zuul反向代理过滤器，以及Eureka服务器用来服务发现。换句话说，<em>@EnableZuulProxy</em>预置好了更多的过滤器，如果你想用现成的，那就拿来直接用。如果你不想用Eureka来实现服务发现（如Consul），你可以选择Server。</p><h4 id="6-2-3-配置Zuul与Eureka进行通信"><a href="#6-2-3-配置Zuul与Eureka进行通信" class="headerlink" title="6.2.3 配置Zuul与Eureka进行通信"></a>6.2.3 配置Zuul与Eureka进行通信</h4><p>Zuul默认可以和Spring Cloud的相关组件进行合作。如，Zuul会自动使用Eureka来作为服务发现服务器，使用Ribbon来进行客户端请求的负载均衡。</p><p>在Zuul的<em>application.yml</em>中添加Eureka的配置即可，与Eureka中的相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    preferIpAddress: true</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: true</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    serviceUrl:</span><br><span class="line">        defaultZone: http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><h3 id="6-3-在Zuul中配置路由"><a href="#6-3-在Zuul中配置路由" class="headerlink" title="6.3 在Zuul中配置路由"></a>6.3 在Zuul中配置路由</h3><p>Zuul核心就是一个反向代理。反向代理就是一个中间的服务器，处于客户端（想要访问某资源）和资源之间。客户端不知道它访问的是服务器还是代理。反向代理服务器就像真正的服务器那样，处理客户端请求。</p><p>关于映射路由，Zuul有多种机制：</p><ul><li>通过服务发现自动映射</li><li>通过服务发现手动映射</li><li>通过静态路由手动映射</li></ul><h4 id="6-3-1-通过服务发现自动映射路由"><a href="#6-3-1-通过服务发现自动映射路由" class="headerlink" title="6.3.1 通过服务发现自动映射路由"></a>6.3.1 通过服务发现自动映射路由</h4><p>路由映射规则可以在application.yml中定义。其实，也可以不用定义。Zuul可以根据服务ID自动进行路由（0配置！）。比如，想调用organizationservice，你可以通过调用Zuul服务实例，访问端点：<a href="http://localhost:5555/organizationservice/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a。" target="_blank" rel="noopener">http://localhost:5555/organizationservice/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a。</a></p><p>使用Zuul集成Eureka的好处是，你永远都只需要知道单一的URL端点（Zuul），你可以在不告知Zuul的情况下添加/移除服务。因为Zuul总是和Eureka通信，来获得每个服务的物理地址。</p><p>使用<strong>/routes</strong>端点可以查看由Zuul管理的路由：<a href="http://localhost:5555/routes。" target="_blank" rel="noopener">http://localhost:5555/routes。</a></p><p><img src="/passages/SPMIA/zuul-routes.png" alt="zuul-routes"></p><p>右边是服务ID（名），左边是Zuul创建的路由URL</p><h4 id="6-3-2-使用服务发现手动映射路由"><a href="#6-3-2-使用服务发现手动映射路由" class="headerlink" title="6.3.2 使用服务发现手动映射路由"></a>6.3.2 使用服务发现手动映射路由</h4><p>Zuul允许你手动的定义路由映射规则。默认情况，Zuul通过<strong>服务ID</strong>（如organizationservice）来映射，如果你想使用自己的规则，可以在Zuul服务的application.yml中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    organizationservice: /organization/**</span><br></pre></td></tr></table></figure><p>现在就可以通过<a href="http://localhost:5555/organization/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a访问到organization服务了。再次访问http://localhost:5555/routes，会发现映射到organizationservice的有两个路由：`&quot;organization/**&quot;" target="_blank" rel="noopener">http://localhost:5555/organization/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a访问到organization服务了。再次访问http://localhost:5555/routes，会发现映射到organizationservice的有两个路由：`&quot;organization/**&quot;</a>: “organizationservice”<code>；</code>“organizationservice/<strong>“: “organizationservice”`。其中，第二个是Zuul自动生成的，第一个是刚才我们配置的。如果不需要Zuul为我们自动生成，可以使用</strong>ignored-services<strong>来配置，如：<code>ignored-services: &#39;organizationservice&#39;</code>。如果想把所有Zuul生成的都忽略掉，使用***</strong>。</p><p>一个用来区分【API路由】和【内容路由】常见的方法是，所有的API路由以<strong>/api</strong>打头。对于Zuul， 可以在配置项中加上<strong>/prefix</strong>。就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  ignored-services: &apos;*&apos;</span><br><span class="line">  prefix:  /api</span><br><span class="line">  routes:</span><br><span class="line">    organizationservice: /organization/**</span><br><span class="line">    licensingservice: /licensing/**</span><br></pre></td></tr></table></figure><h4 id="6-3-3-使用静态URL手动路由"><a href="#6-3-3-使用静态URL手动路由" class="headerlink" title="6.3.3 使用静态URL手动路由"></a>6.3.3 使用静态URL手动路由</h4><p>Zuul可以用来路由一些<strong>不是由Eureka管理的服务</strong>。假如你的licensing service是由Python写的，你想用Zuul来做服务代理，可以直接在配置文件中写死：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.licensestatic.path: /licensestatic/**</span><br><span class="line">zuul.routes.licensestatic.url:  http://licenseservice-static:8081</span><br></pre></td></tr></table></figure><p>这样，对于<em>licensestatic</em>端点，Eureka不会知道，所有访问到licensestatic的请求会直接被路由到<a href="http://licenseservice-static:8081端点。这样做存在一个问题：绕过了Eureka，只有一条路径可以用来处理请求（即licensestatic.url）。幸运的是，可以手动配置Zuul来禁用Ribbon和Eureka集成，然后列出Ribbon将进行负载均衡的各个服务实例。如下面所示：" target="_blank" rel="noopener">http://licenseservice-static:8081端点。这样做存在一个问题：绕过了Eureka，只有一条路径可以用来处理请求（即licensestatic.url）。幸运的是，可以手动配置Zuul来禁用Ribbon和Eureka集成，然后列出Ribbon将进行负载均衡的各个服务实例。如下面所示：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    licensestatic:</span><br><span class="line">      path: /licensestatic/**</span><br><span class="line">      serviceId: licensestatic　　⇽---　定义一个服务ID，该服务ID将用于在Ribbon中查找服务</span><br><span class="line">ribbon:</span><br><span class="line">  eureka:</span><br><span class="line">    enabled: false　　⇽---　在Ribbon中禁用Eureka支持</span><br><span class="line">licensestatic:</span><br><span class="line">  ribbon:</span><br><span class="line">    listOfServers: http://licenseservice-static1:8081,</span><br><span class="line">      http://licenseservice-static2:8082　　⇽---　指定请求会路由到的服务器列表</span><br></pre></td></tr></table></figure><p><strong>处理非JVM服务</strong></p><blockquote><p>使用静态路由并在Ribbon中禁用Eureka的一个问题是，禁用了通过Zuul网关的素有服务的Ribbon支持。这意味着Eureka服务器的压力会更大，因为Zuul不能使用Ribbon来缓存查找服务。Ribbon做的就是客户端负载均衡，即每次查找不是直接问Eureka，它会先在本地查找缓存，并定期和Eureka通信来将最近使用到的缓存到客户端。如果不能使用Ribbon，那么每次Zuul都会直接调用Eureka来解析服务地址。</p><p>因此，我们可以使用多个服务网关，基于不同的需求。对于非JVM的应用，可以设置一个单独的服务器来处理。作者推荐，最好是使用Spring Cloud “SideCar”实例。使用SideCar你可以用一个Eureka实例注册一个非JVM服务，并通过Zuul进行代理。有兴趣可以在<a href="http://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html#spring-cloud-ribbonwithout-eureka上看看。" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html#spring-cloud-ribbonwithout-eureka上看看。</a></p></blockquote><h4 id="6-3-4-动态重新加载路由配置"><a href="#6-3-4-动态重新加载路由配置" class="headerlink" title="6.3.4 动态重新加载路由配置"></a>6.3.4 动态重新加载路由配置</h4><p>Zuul暴露了一个【基于POST】的路由：<strong>/refresh</strong>。通过访问/refresh端点，就可以刷新配置信息。</p><p><strong><em>为什么没有刷新？？在Zuul的application.yml和配置服务器上分别改都没用…</em></strong></p><h4 id="6-3-5-Zuul和服务超时"><a href="#6-3-5-Zuul和服务超时" class="headerlink" title="6.3.5 Zuul和服务超时"></a>6.3.5 Zuul和服务超时</h4><p>Zuul使用Netflix的Hystrix和Ribbon库来防止“又臭又长”的服务调用影响服务网关的性能。默认情况下，Zuul会终止并返回HTTP 500错误，对于任何超过1s的调用（这也是Hystrix的默认值）。可以在Zuul服务的配置文件中直接更改此配置值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 2500</span><br></pre></td></tr></table></figure><p>如果你想<strong>将某个服务的超时时间设置的不一样</strong>，而不是对所有服务生效，把<code>default</code>部分改成相应服务ID就好了。如，设置licensingservice的超时时间为3s：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.licensingservice.execution.isolation.thread.timeoutInMilliseconds: 3000</span><br></pre></td></tr></table></figure><p>然而，尽管我们可以设置自己的超时时间（其实设置的是Hystrix的超时时间），Ribbon也有一个超时时间，默认为5s。万一自己设计的服务有超过5s的调用请求的风险，最好还是设置一下这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.licensingservice.execution.isolation.thread.timeoutInMilliseconds: 7000</span><br><span class="line">licensingservice.ribbon.ReadTimeout: 7000</span><br></pre></td></tr></table></figure><p>即，<strong><em>若有需要配置超时时间≥5的，需要同时配置Hystrix和Ribbon</em></strong>。</p><h3 id="6-4-Zuul的强大之处——过滤器"><a href="#6-4-Zuul的强大之处——过滤器" class="headerlink" title="6.4 Zuul的强大之处——过滤器"></a>6.4 Zuul的强大之处——过滤器</h3><p>除了代理所有请求，简化服务调用，Zuul真正厉害的地方应该在于<strong>需要通过网关流经所有的服务调用的自定义逻辑</strong>。这种自定义逻辑通常用于强制执行一组一致性的应用程序策略，如安全性、日志记录和对所有服务的跟踪。</p><p>这些策略也被叫做<strong>“横切关注点（cross-cutting concerns）”</strong>，因为要将它们应用在所有服务中。这样，可以按照J2EE中的servlet过滤器或Spring Aspect类似的方式来使用。servlet过滤器或Spring Aspect被本地化为特定的服务，而使用Zuul和Zuul过滤器可以为通过Zuul路由的所有服务实现横切关注点。</p><p>Zuul允许你在Zuul网关内使用过滤器来构建自定义逻辑。Zuul支持的过滤器有：</p><ul><li><strong>前置过滤器</strong>——在Zuul<strong>将实际请求发送到目的地之前被调用</strong>。前置过滤器通常执行确保服务具有一致的消息格式（如，HTTP首部是否设置妥当）的任务；或者确保调用服务的用户已通过验证和授权（Authentication、Authorization）。</li><li><strong>后置过滤器</strong>——在<strong>目标服务被调用并将响应发送回客户端后被调用</strong>。通常用来记录从目标服务返回的响应、处理错误或审核对敏感信息的响应。</li><li><strong>路由过滤器</strong>——在<strong>调用目标服务之前拦截调用</strong>。<strong>通常用来确定是否需要进行某些级别的动态路由</strong>。例如，本章后面使用的路由级别的过滤器，将在同一服务的两个不同版本之间进行路由，以便将一小部分的服务调用路由到服务的新版本。这样就能在不让每个人都使用新服务的情况下，让少量的用户体验新功能。</li></ul><p><img src="/passages/SPMIA/3-layer-filter-principle.png" alt="3-layer-filter-principle"></p><p>上图为三层过滤器的原理。、</p><p><img src="/passages/SPMIA/3-layer-filter-application.png" alt="3-layer-filter-application"></p><p>上图为结合应用的三层过滤器实现：</p><ul><li><strong>TrackingFilter</strong>：检查请求的HTTP首部，若不存在correlationID（关联ID），则为其创建一个。</li><li><strong>SpecialRoutesFilter</strong>：确定是否需要动态路由，即是否需要将一部分满足某种条件的请求路由到同一个服务的另一个版本上。如，确定是否需要做<strong>A/B测试</strong>。A/B测试是指给用户呈现同一个服务的两个不同版本，在投放到用户群体前，可以测试版本中新的feature。</li><li><strong>ResponseFilter</strong>：确保响应中有correlationID。</li></ul><h3 id="6-5-构建前置过滤器-产生关联ID"><a href="#6-5-构建前置过滤器-产生关联ID" class="headerlink" title="6.5 构建前置过滤器 | 产生关联ID"></a>6.5 构建前置过滤器 | 产生关联ID</h3><p>创建一个类：<em>TrackingFilter</em>。它会检查所有请求，确保请求头中都有一个header：<em>tmx-correlation-id</em>。此ID可以用来在多个服务中跟踪某个用户的请求。<strong>关联ID的实现将使用ThreadLocal变量</strong>。</p><p>如果某个请求的HTTP首部没有<em>tmx-correlation-id</em>，Zuul下的TrackingFilter类会生成并设置好关联ID。<strong>关联ID代表着某次服务调用是为了执行用户的某个请求而做的一系列服务调用的一部分</strong>。</p><p>接下来分析TrackingFilter类。</p><h3 id=""><a href="#" class="headerlink" title="#"></a>#</h3><p>所有的Zuul过滤器都要继承ZuulFilter类，并重写四个方法：filterType()、filterOrder()、shouldFilter()、run()。</p><p><strong>注意</strong></p><blockquote><p>对于普通的Spring MVC或者Spring Boot服务，<strong>RequestContext</strong>是从<strong><em>org.springframework.web.servletsupport.RequestContext</em></strong>包中引入的；而在Zuul中，提供了一个额外的RequestContext，以方便进行Zuul相关的操作，即它是来自<strong><em>com.netflix.zuul.context</em></strong>包的。</p></blockquote><h4 id="6-5-1-在服务调用中使用关联ID"><a href="#6-5-1-在服务调用中使用关联ID" class="headerlink" title="6.5.1 在服务调用中使用关联ID"></a>6.5.1 在服务调用中使用关联ID</h4><p>我们将关联ID加入了流经Zuul的每个服务调用中，但是要怎么保证：</p><ul><li>关联ID可以被正在被调用的服务访问</li><li>所有调用此服务的下游服务调用仍然可以将关联ID继续往下传递</li></ul><p>实现过程入下：</p><p><img src="/passages/SPMIA/3-layer-filter.png" alt="3-layer-filter"></p><p>以上过程发生了四件事：</p><ol><li>当服务调用（licensing service）经过Zuul网关时，<em>TrackingFilter</em>将会把关联ID注入所有经过Zuul的请求头中。</li><li><em>UserContextFilter</em>类是一个自定义的HTTP ServletFilter。它将一个关联ID和一个<em>UserContext</em>类对象关联起来（根据关联ID创建一个UserContext）。UserContext对象用于将一些待会要用到的值存储到ThreadLocal中。</li><li>许可证服务的业务逻辑要执行一个对组织服务的调用。</li><li><em>RestTemplate</em>类用来调用组织服务。RestTemplate类将使用一个自定义的Spring Interceptor（UserContextInterceptor 拦截器）类，来将关联ID注入返回的响应请求的HTTP首部中。</li></ol><p><strong>重复代码与共享库对比</strong></p><blockquote><p>是否应该在微服务中使用公共库的话题时微服务设计中的一个灰色地带。微服务纯粹主义者会说，<strong>不要在服务中使用自定义框架，因为它会在服务中引入人为的依赖，业务逻辑的更改或bug修正可能对所有服务造成大规模的重构</strong>。但是，其他一些微服务实践者指出，这样是不切实际的，因为存在一些情况（如UserContextFilter），构建公共库并在服务之间共享它是有意义的。</p><p>当我们在处理一些基础设施风格的任务时（所有服务都要用的那种），很适合使用公共库；若是共享面向业务的类，那就是自找麻烦，因为这样是在打破服务之间的界限。</p><p>在本章示例代码中，作者之所以在每一个服务的utils包中都写了UserContext、UserContextFilter、UserContextInterceptor类的副本，因为这样不需要创建一个共享库并把它发布到Maven上然后引入依赖，这样会看起来更复杂。</p></blockquote><p><strong>UserContextHolder：存储UserContext</strong></p><p>UserContextHolder负责将UserContext存储到一个ThreadLocal变量中，以便于让处理当前请求的线程所调用的方法能够访问。</p><p><strong>自定义RestTemplate和UserContextInteceptor类：保证关联ID向下游传播</strong></p><p>要使用UserContextInteceptor，需要定义一个<em>RestTemplate</em>类，并把UserContextInteceptor放到里面。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestTemplate template = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    List interceptors = template.getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (interceptors == <span class="keyword">null</span>) &#123;</span><br><span class="line">        template.setInterceptors(Collections.singletonList(<span class="keyword">new</span> UserContextInterceptor()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> UserContextInterceptor());</span><br><span class="line">        template.setInterceptors(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@LoadBalanced</strong>注解表示这个RestTemplate对象要使用Ribbon；将UserContextInteceptor加入到创建好的RestTemplate中。经过这样定义，每当你使用<strong>@Autowired</strong>标记，将RestTemplate注入一个类中，创建的RestTemplate都是带有UserContextInterceptor的。</p><p><strong>日志聚合、认证…</strong></p><blockquote><p>现在有了关联ID，并可以把它传递到每个服务上，那就可以跟踪一个事务啦。可以考虑将所有服务日志放到一个中心的日志聚合处，每个条目通过关联ID来标识，第九章介绍的Spring Cloud Sleuth就是做这个的。</p></blockquote><h3 id="6-6-构建后置过滤器-接收关联ID"><a href="#6-6-构建后置过滤器-接收关联ID" class="headerlink" title="6.6 构建后置过滤器 | 接收关联ID"></a>6.6 构建后置过滤器 | 接收关联ID</h3><p>与构建前置过滤器类似，构建一个ResponseFilter，用于将关联ID”输出“到返回的响应中。</p><h3 id="6-7-构建动态路由过滤器"><a href="#6-7-构建动态路由过滤器" class="headerlink" title="6.7 构建动态路由过滤器"></a>6.7 构建动态路由过滤器</h3><p>目标：动态过滤器可以获取到所有经过Zuul的服务ID，然后调用<strong>SpecialRoutesService</strong>，<strong>SpecialRoutesFilter</strong>会产生一个随机数作为权重，通过与新版本的服务进行比较，决定是否进行特殊路由。</p><h4 id="6-7-1-构建路由过滤器的框架结构"><a href="#6-7-1-构建路由过滤器的框架结构" class="headerlink" title="6.7.1 构建路由过滤器的框架结构"></a>6.7.1 构建路由过滤器的框架结构</h4><p>还是像之前一样，继承ZuulFilter并覆盖其方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialRoutesFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> filterUtils.ROUTE_FILTER_TYPE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-7-2-实现run-方法"><a href="#6-7-2-实现run-方法" class="headerlink" title="6.7.2 实现run()方法"></a>6.7.2 实现run()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line"></span><br><span class="line">        AbTestingRoute abTestRoute = getAbRoutingInfo( filterUtils.getServiceId() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (abTestRoute!=<span class="keyword">null</span> &amp;&amp; useSpecialRoute(abTestRoute)) &#123;</span><br><span class="line">            String route = buildRouteString(ctx.getRequest().getRequestURI(),</span><br><span class="line">                    abTestRoute.getEndpoint(),</span><br><span class="line">                    ctx.get(<span class="string">"serviceId"</span>).toString());</span><br><span class="line">            forwardToSpecialRoute(route);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先，调用<strong>SpecialRoutesService</strong>服务来检查是否存在关于这个服务（如service_name=organizationservice）的一个特殊路由记录。</p></li><li><p><strong>useSpecialRoute</strong>方法会将在数据库中查到的weight值与生成的随机值的大小做比较，决定是否将请求路由到备用服务。</p></li><li>如果调用特殊路由服务找到了一条记录，则为其构建一个完整的URL。</li><li>最后，<strong>forwardToSpecialRoute</strong>方法将请求转发。</li></ul><h4 id="6-7-3-转发路由"><a href="#6-7-3-转发路由" class="headerlink" title="6.7.3 转发路由"></a>6.7.3 转发路由</h4><h4 id="6-7-4-整合"><a href="#6-7-4-整合" class="headerlink" title="6.7.4 整合"></a>6.7.4 整合</h4><h2 id="7-保护你的微服务（Securing）"><a href="#7-保护你的微服务（Securing）" class="headerlink" title="7 保护你的微服务（Securing）"></a>7 保护你的微服务（Securing）</h2><p>本章主要使用Spring Cloud security和OAuth2来保护基于Spring的服务。OAuth2是一个基于令牌（token）的安全框架，允许用户使用第三方验证服务进行验证。如果用户成功进行了验证，则会出示一个令牌，该令牌必须与每个请求一起发送。然后，验证服务可以对令牌进行确认。使用OAuth2的好处是，在调用多个服务来完成用户请求时，用户不需要在处理请求的时候为每个服务都提供自己的凭据信息就能完成验证。</p><p>一个成熟的OAuth2实现还需要一个前端Web应用程序来输入用户凭据。本章将使用REST客户端（如POSTMAN）来模拟凭据的提交。有关如何配置前端应用程序，可以参考：<a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-springsecurity-part-v。" target="_blank" rel="noopener">https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-springsecurity-part-v。</a></p><p>首先，来看一下OAuth2架构：</p><h3 id="7-1-OAuth2简介"><a href="#7-1-OAuth2简介" class="headerlink" title="7.1 OAuth2简介"></a>7.1 OAuth2简介</h3><p>OAuth2安全框架包含四个组件：</p><ol><li><strong>被保护的资源</strong>——既然要认证用户才能访问，那么资源/微服务就是被保护的。</li><li><strong>资源所有者</strong>——资源所有者定义了应用的名字，可以访问的用户，可访问用户的权限。每个通过资源所有者注册的应用都有一个<strong>应用名</strong>和<strong>应用秘钥</strong>。此两者是证书的一部分。</li><li><strong>应用</strong>——指的是调用服务的应用，即用户通过此应用来调用某个服务。</li><li><strong>OAuth2认证服务器</strong>——认证服务器是存在于应用和服务之间的中介。有了认证服务器，用户不必每次都使用证书来验证身份。</li></ol><p>工作流程如下：</p><p><img src="/passages/SPMIA/oauth2-authentication.png" alt="oauth2-authentication"></p><p> 如上图所示，每次验证身份时只需要通过token即可。</p><p>资源拥有者，可以使用OAuth2和角色来定义用户可以访问的服务端点以及可以使用的HTTP动词（GET、POST等）。</p><p>Web服务安全是一个很复杂的主题。你要明白是谁在调用你的服务：（内部用户；外部用户），怎样调用（内部基于Web的客户端；移动设备；外部的Web应用），有哪些行为。OAuth2允许你使用以下四种授权方式：</p><ul><li><strong>密码（password）</strong></li><li><strong>客户端证书（client credential）</strong></li><li><strong>授权码（authorization code）</strong></li><li><strong>隐式（implicit）</strong></li></ul><p>由于篇幅问题，本章只讨论：</p><ul><li>怎样使用密码来授权</li><li>使用JWT（JSON Web Token）来将信息编码在token中</li><li>怎样使应用更安全</li></ul><p>如果想了解OAuth2的更多细节，推荐阅读：Justin Richer和Antonio Sanso的书：<em>OAuth2 in Action (2017)</em>。</p><h3 id="7-2-一步一步来：使用Spring和OAuth2保护一个端点"><a href="#7-2-一步一步来：使用Spring和OAuth2保护一个端点" class="headerlink" title="7.2 一步一步来：使用Spring和OAuth2保护一个端点"></a>7.2 一步一步来：使用Spring和OAuth2保护一个端点</h3><p>最简单的方式：使用密码验证。需要做的有：</p><ul><li>建立一个基于Spring Cloud的OAuth2认证服务</li><li>注册一个伪UI应用程序（作为一个已授权的应用程序），可以对用户身份进行验证和授权</li><li>使用OAuth2密码授权来保护EagleEye服务。不需要写UI，而是用Postman模拟用户登录，并使用OAuth2服务来验证身份</li><li>保护licensing和organization服务，使仅认证用户能够访问</li></ul><h4 id="7-2-1-建立EagleEye-OAuth2验证服务"><a href="#7-2-1-建立EagleEye-OAuth2验证服务" class="headerlink" title="7.2.1 建立EagleEye OAuth2验证服务"></a>7.2.1 建立EagleEye OAuth2验证服务</h4><p>像其他部分一样，认证服务也是作为一个Spring Boot服务来运行的，需要首先添加需要的Maven依赖，然后为其设置一个启动类。需要的依赖有：</p><ul><li>spring-cloud-security</li><li>spring-security-oauth2</li></ul><p>认证服务启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = &#123; <span class="string">"/user"</span> &#125;, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">user</span><span class="params">(OAuth2Authentication user)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; userInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        userInfo.put(<span class="string">"user"</span>, user.getUserAuthentication().getPrincipal());</span><br><span class="line">        userInfo.put(<span class="string">"authorities"</span>, AuthorityUtils.authorityListToSet(user.getUserAuthentication().getAuthorities()));</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AuthenticationServer.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableAuthorizationServer启动认证服务器；</p><p>添加路由：/<strong>user</strong>（实际上是/auth/user，/auth在认证服务的配置文件application.yml中声明contextPath）</p><p>被保护的服务将调用此端点，来验证token并检索来调用此服务的用户所拥有的角色及权限。</p><h4 id="7-2-2-将客户端注册到OAuth2服务"><a href="#7-2-2-将客户端注册到OAuth2服务" class="headerlink" title="7.2.2 将客户端注册到OAuth2服务"></a>7.2.2 将客户端注册到OAuth2服务</h4><p>将在<em>OAuth2Config.java</em>中把需要注册的客户端注册上去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth2Config</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="string">"eagleeye"</span>)</span><br><span class="line">                .secret(<span class="string">"thisissecret"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="string">"refresh_token"</span>, <span class="string">"password"</span>, <span class="string">"client_credentials"</span>)</span><br><span class="line">                .scopes(<span class="string">"webclient"</span>, <span class="string">"mobileclient"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      endpoints</span><br><span class="line">        .authenticationManager(authenticationManager)</span><br><span class="line">        .userDetailsService(userDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OAuth2的配置类继承了<em>AuthorizationServerConfigurer</em>（<strong>AuthorizationServerConfigurerAdapter也继承自AuthorizationServerConfigurer</strong>），后者是Spring Security的一个核心类。提供了一些验证key和授权的方法。需要重写两个方法：</p><ul><li>configure()方法，定义注册到认证服务上的客户端，入参为<em>ClientDetailsServiceConfigurer</em>类型。</li><li>ada</li></ul><p>我们再深入看一下第一个configure()方法。</p><p><em>ClientDetailsServiceConfigurer</em>类支持两种不同的存储应用信息的方式：内存中和JDBC数据库中。本例使用<em>clients.inMemory()</em>方式。</p><p><em>withClient()</em>和<em>secret()</em>方法提供了注册认证服务的应用名和密码，密码在服务调用认证服务时获取访问token时用。</p><p><em>authorizedGrantTypes()</em>方法传入了一个逗号分隔的授予权限类型，本例中支持<strong>密码</strong>和<strong>客户端证书</strong>授权。</p><p><em>scopes()</em>方法定义调用认证服务的应用的类型。比如，Thoughtmechanix服务提供同一个应用的两个版本：一个web端，一个移动端。这些应用有相同的客户端名字和秘钥。当这个app向OAuth2申请key的时候，需要确定 是在哪个scope，确定了scope，才能给予适当的权限。需要注意的是，<strong>scope的定义与权限的定义不冲突，且优先级较高</strong>，即，无论一个用户有什么权限，它还要有适当的scopes才能够对某个资源有访问权限。这种限制数据访问的实践（practice）在处理敏感用户信息时极为常见（如（病人）健康记录、税务信息）。</p><p>现在已经注册了一个应用，<strong>EagleEye</strong>。既然使用密码方式来验证，接下来要对用户设置对应的账户和密码。</p><h4 id="7-2-3-配置EagleEye用户"><a href="#7-2-3-配置EagleEye用户" class="headerlink" title="7.2.3 配置EagleEye用户"></a>7.2.3 配置EagleEye用户</h4><p>已经设置好了应用级别的key和secret，可以为用户设置其单独的credentials和roles了。Spring存储/检索用户信息（用户的证书和角色）的地方有三种：内存、支持JDBC的关系型数据库、LDAP服务器。</p><p>LDAP服务器是什么？可以参考<a href="https://www.jianshu.com/p/7e4d99f6baaf" target="_blank" rel="noopener">这个</a>。</p><p>本例中，使用内存方式存储用户角色。定义两个用户账号：<em>john.carnell、william.woodward</em>；<em>john.carnell</em>拥有<code>USER</code>权限，<em>william.woodward</em>拥有<code>ADMIN</code>权限。</p><p>对每个用户的证书和角色的授予在<em>WebSecurityConfigurer.java</em>中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfigurer</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsServiceBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.userDetailsServiceBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">"john.carnell"</span>).password(<span class="string">"password1"</span>).roles(<span class="string">"USER"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="string">"william.woodward"</span>).password(<span class="string">"password2"</span>).roles(<span class="string">"USER"</span>, <span class="string">"ADMIN"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的两个bean：<em>authenticationManagerBean()、userDetailsServiceBean</em>分别用来对用户进行验证和返回用户信息。</p><h4 id="7-2-4-验证用户"><a href="#7-2-4-验证用户" class="headerlink" title="7.2.4 验证用户"></a>7.2.4 验证用户</h4><h2 id="8-事件驱动的架构——Spring-Cloud-Stream"><a href="#8-事件驱动的架构——Spring-Cloud-Stream" class="headerlink" title="8 事件驱动的架构——Spring Cloud Stream"></a>8 事件驱动的架构——Spring Cloud Stream</h2><h2 id="9-分布式跟踪——Spring-Cloud-Sleuth-amp-Zipkin"><a href="#9-分布式跟踪——Spring-Cloud-Sleuth-amp-Zipkin" class="headerlink" title="9 分布式跟踪——Spring Cloud Sleuth &amp; Zipkin"></a>9 分布式跟踪——Spring Cloud Sleuth &amp; Zipkin</h2><h2 id="10-部署微服务"><a href="#10-部署微服务" class="headerlink" title="10 部署微服务"></a>10 部署微服务</h2><h2 id="NOTES："><a href="#NOTES：" class="headerlink" title="NOTES："></a>NOTES：</h2>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/SPMIA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git使用</title>
      <link>https://gitplayb.github.io/passages/Git%E4%BD%BF%E7%94%A8/</link>
      <guid>https://gitplayb.github.io/passages/Git%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Sun, 22 Dec 2019 14:54:48 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><p>一般有两种方式：<code>git init</code>或者<code>git clone url</code> </p><p><strong>前者</strong>会在当前选定目录下创建一个<strong>.git</strong>隐藏目录（Windows上需要把隐藏文件查看勾选上才可以看到），即本目录将会作为一个本地仓库可以与远程仓库连接。打开.git目录可以看到里面含有一些此仓库的基本信息，主要是记录分支信息还有文件的更改情况等。</p><p><strong>后者</strong>可以直接从远程仓库中复制一份完全一样的代码，到你的本地目录，作为本地仓库（前提是你配置好了Git客户端如GitHub的用户名/密码或者SSH秘钥）。</p><h3 id="记录仓库中的改变"><a href="#记录仓库中的改变" class="headerlink" title="记录仓库中的改变"></a>记录仓库中的改变</h3><p><strong>版本控制系统</strong>最大的作用就是<strong>记录、跟踪文件的改变，使用户可以方便地在不同版本间切换</strong>。对于Git，基本状态有四个：<strong>Untracked、Unmodified、Modified、Staged</strong>。</p><ul><li><strong>Untracked</strong>——未被git加入跟踪，即文件怎么改变git都不管</li><li><strong>Unmodified</strong>——已跟踪、未修改，git记录其改变情况，但现在还没有改变</li><li><strong>Modified</strong>——已修改、未暂存，已经发生了改变，并且git记录了此改变</li><li><strong>Staged</strong>——已暂存，已将改变情况告诉git，加入暂存区，作为下次commit（提交）的材料</li></ul><h4 id="跟踪-记录文件"><a href="#跟踪-记录文件" class="headerlink" title="跟踪/记录文件"></a>跟踪/记录文件</h4><p>当我们想让git为我们记录一个文件的改变时，使用<code>git add</code>命令，后面跟着的是想要跟踪的文件名。这时我们查看git状态（<code>git status</code>）会发现，状态已经由<strong>untracked</strong>变成了<strong>tracked</strong>，终端会显示<em>Changes to be committed</em>。即，我们已经到达提交前的一个状态：所有改变已被记录并暂存。如果提交之前又对加入跟踪的文件作了改变，还需要再次运行<code>git add</code>命令，将改变暂存，然后提交。</p><p>由此可以看出，<code>git add</code>命令有两个作用：</p><ol><li>开始追踪/记录文件</li><li>将文件（改变）提交到暂存区</li></ol><p>#### </p><h4 id="查看状态（简版）"><a href="#查看状态（简版）" class="headerlink" title="查看状态（简版）"></a>查看状态（简版）</h4><p>查看状态有两种方式：<code>git status</code>或者<code>git status -s</code>或者<code>git status --short</code>。</p><p>前者查看较为详细的状态；后者查看简要状态。</p><p>其中后者的状态表示有两列：<strong>第一列表示暂存区的状态；第二列表示远程仓库的状态。</strong><code>??</code>表示为追踪；<code>A</code>代表已暂存；<code>M</code>代表已修改。</p><p>在git bash中操作一番发现，<strong>已修改但是没有暂存时<code>M</code>出现在右边且是红色的；修改且暂存后<code>M</code>出现在左边且是绿色的</strong>。如下：</p><p><img src="/passages/Git使用/git-status-s.png" alt="git-status-s"></p><p>显示还是挺人性化的，红色表示警告，暂存之后，就变成了绿色，表示正常状态。</p><p>如果做了改变，又没有commit，就会出现下图的情况：</p><p><img src="/passages/Git使用/1573698024559.png" alt="1573698024559"></p><p>使用<code>git diff</code>查看具体区别：</p><p><img src="/passages/Git使用/1573697956849.png" alt="1573697956849"></p><p>使用<code>git add -A</code>将所有改动文件暂存：（详细版本会说“changes to be committed”，并且会以绿色字体列出改动的文件）</p><p><img src="/passages/Git使用/1573698564785.png" alt="1573698564785"></p><p>使用commit命令提交后，再看status</p><p><img src="/passages/Git使用/1573698789058.png" alt="1573698789058"></p><p>提醒你要push代码，将改动同步到远程仓库</p><p>使用<code>git status -s</code>则会什么都不显示</p><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>通常有一些文件，你是不想让git追踪的，即你怎么改变都是在本地改变的，不需要git干预（因为默认情况下git会把<strong>.git</strong>所在目录下所有文件都当成潜在客户，即你没有add（追踪），它会缠着你让你追踪）。这时，我们就需要一个新建一个名为<strong>.gitignore</strong>的隐藏文件，告诉git，哪些文件不需要追踪。</p><p>文件的书写格式如下：</p><ul><li>空行或以<strong>#</strong>开头（注释）的行会被忽略</li><li>支持部分<strong>正则表达式</strong></li><li>开头加<strong>/</strong>避免递归</li><li>末尾加<strong>/</strong>指定一个目录</li><li>开头加<strong>!</strong>表示否定</li></ul><p>示例的.gitignore文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ignore all .a files</span><br><span class="line">*.a</span><br><span class="line"># but do track lib.a, even though you&apos;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># ignore all files in any directory named build</span><br><span class="line">build/</span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># ignore all .pdf files in the doc/ directory and any of its subdirectories</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p>以上的描述已经很清楚了，主要就是通配符<strong>*</strong>的使用。</p><h4 id="查看暂存-未暂存的文件"><a href="#查看暂存-未暂存的文件" class="headerlink" title="查看暂存/未暂存的文件"></a>查看暂存/未暂存的文件</h4><p>使用<code>git diff</code>。</p><p>如果改动了某个文件，使用diff可以查看<strong>已暂存/未暂存</strong>的文件，已暂存的文件下次commit将会被提交。</p><p>使用diff时可以加上一个参数：<code>git diff --cached</code>或者<code>git status --staged</code>，没什么区别。</p><p>还可以在其它外部工具（不是terminal）中使用git diff，使用<code>git difftool --tool-help</code>查看本机可以用的比较工具。</p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>使用<code>git commit</code>。</p><p>输入此命令会自动打开git bash配置的默认编辑器（未设置是vim），你可以写上本次提交的描述；</p><p>或者，直接<code>git commit -m &quot;message&quot;</code>加上描述；</p><p>如果不想每次commit前都要暂存（使用<code>git add</code>），可以在提交时加上<strong>-a</strong>参数，即<code>git commit -a</code>。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>在git上删除一个文件，你得首先让git不要再追踪（track）它，然后提交。使用<code>git rm</code>就可以做到，并且也会将它从电脑磁盘上删除。如果直接使用<strong>rm</strong>，会提示：changes not staged for commit</p><p>使用<code>git rm</code>，按下回车会反馈：删除了哪个文件。再查看status，会记录之前的操作–删除文件，并等待提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm <span class="string">'PROJECTS.md'</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">  </span><br><span class="line">    deleted: PROJECTS.md</span><br></pre></td></tr></table></figure><p>删除以后，下次提交git就不会管它了。如果已经修改了这个文件或者已经把它add到了暂存区，删除时要使用<strong>- f</strong>强制删除，这是为了防止意外删除，因为删除了无法恢复。</p><p>还有一种情况，你只想把文件从暂存区删除，但是保留在你的电脑磁盘上。这就好比你忘了在.gitignore中忽略这个文件。删除时添加<strong>–cached</strong>参数，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p>在命令中也可以使用通配符*，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm <span class="built_in">log</span>/\*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>上面命令将删除所有log/目录下的.log文件（好像是遇到*需要处理成转义字符）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm \*~</span><br></pre></td></tr></table></figure><p>上面命令会删除所有以~结尾的文件</p><h4 id="移动文件-重命名"><a href="#移动文件-重命名" class="headerlink" title="移动文件/重命名"></a>移动文件/重命名</h4><p>不像其他的VCS（版本控制）系统，Git不会显式地追踪移动操作，即你在磁盘目录上对文件移动不会被记录到git的状态中。【但是！】Git提供了mv命令，如果使用mv命令进行移动，则会被记录在status中。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README.md README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">  </span><br><span class="line">    renamed: README.md -&gt; README</span><br></pre></td></tr></table></figure><p>重命名操作被Git记录了下来，此操作相当于以下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>即，如果仅仅是在磁盘上对文件进行移动，完了还要告诉Git，将暂存区的旧文件移除，新文件暂存。</p><p>这样看来，使用Git提供的移动/重命名操作，还是很方便的（<strong>或者直接在文件夹里修改名字就好了，Git不会记录</strong>）。</p><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>使用<code>git log</code>命令查看提交历史记录。</p><h1 id="廖雪峰"><a href="#廖雪峰" class="headerlink" title="###############廖雪峰"></a>###############廖雪峰</h1><p><strong>git撤销回退版本和切换分支的命令都可以是<code>git checkout</code></strong>，但切换分支还可以用<strong><code>git switch</code></strong>，所以最好用switch切换分支以区分。</p><p><strong>git合并时默认使用fast forward模式</strong></p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Git%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你好</title>
      <link>https://gitplayb.github.io/passages/Hello/</link>
      <guid>https://gitplayb.github.io/passages/Hello/</guid>
      <pubDate>Sun, 22 Dec 2019 08:19:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;遇到认识的人，你会怎么打招呼呢&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>遇到认识的人，你会怎么打招呼呢</p><hr><a id="more"></a><p>当我遇到比较熟或者关系比较好的朋友，我会说<strong>嗨~</strong>或者<strong>嘿~</strong>，不知道是不是因为看美剧，我觉得Hey/Hi是在我感觉更ease的时候才会这么说，遇到不太熟或者只是一般的关系我则会说哈喽，这样，两个字会不会比一个字显得更亲热些？</p><h2 id="明天，你好"><a href="#明天，你好" class="headerlink" title="明天，你好"></a>明天，你好</h2><p>就是突然想起了这首歌。小时候听好像没什么特别的感觉，因为不知道长大是什么样子的，听女主唱清晰的咬字总感觉她像是在对一个老朋友诉说似的。</p><p>现在听起来，歌词很真挚，情感也很到位。听着这个有一种又想哭又想笑的感觉。相比探索地理上的未知，就像下面说的你好，世界，我觉得探索时间上的未知才是更需要勇气的。因为如果我们想要，总可以踏出自己的生活圈子，往更大的世界走走，即使不能行万里路，但我们总还是拥有自由的。而时间却不同，无论我们有多大能力，回到过去或未来也只是科幻电影里老生常谈的素材而已。所以我觉得，真正的未知便是明天，而幸运的是未来和现今不是断层的，我们是可以一笔一笔的勾勒出未来理想生活的蓝图的。</p><p>对明天说声你好吧，没有什么可以惧怕的。</p><h2 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h2><blockquote><p>当那天我郑重其事地打开电脑，在电脑上输入那一行字，我就觉得，我的世界从此会变得不一样了！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello, world&quot;);</span><br></pre></td></tr></table></figure><p>可能，程序员们不太擅长和这个世界打交道，于是说你好，世界。这样外人听起来可能有些生疏，但是他们自己却觉得说哈喽显得更熟络一些。管他的，他们开心就好。</p><p>而我要说嗨，世界。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Hello/#disqus_thread</comments>
    </item>
    
    <item>
      <title>求知欲和表达欲</title>
      <link>https://gitplayb.github.io/passages/Desires/</link>
      <guid>https://gitplayb.github.io/passages/Desires/</guid>
      <pubDate>Sat, 21 Dec 2019 17:15:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;生而为人，没有欲望是不太可能的。即使是看破了红尘、不食人间烟火的得道高僧，他难道不想做一个好和尚吗？可能存在只是混口饭吃的和尚，但至少他有活下去的欲望，否则他为什么要一日三餐呢…&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>生而为人，没有欲望是不太可能的。即使是看破了红尘、不食人间烟火的得道高僧，他难道不想做一个好和尚吗？可能存在只是混口饭吃的和尚，但至少他有活下去的欲望，否则他为什么要一日三餐呢…</p><a id="more"></a><h2 id="求知欲"><a href="#求知欲" class="headerlink" title="求知欲"></a>求知欲</h2><p>人和动物的区别，从刻板上说，是<em>会制造和使用工具</em>。但是我认为，语言的创造与使用使人类的思想得到了传播并发展，这才是我们作为一种比较特别的生物存在于这星球的立足点。没有语言，我们可能无异于皮皮虾。</p><h3 id="生而为人"><a href="#生而为人" class="headerlink" title="生而为人"></a>生而为人</h3><p>我们从出生开始，只是一个脑袋里充满着很强烈的探索欲望的生命体，经过父母、老师、和身边同龄人或者比我们经历的更多的伙伴们的相处，我们见到的越来越多，了解的越来越多。我们逐渐学到了这个世界的运转规则（<em>How the world runs</em>），学到了我们应该如何与他人相处（<em>How to get along</em>），以及我们在世界上觉得最重要的东西（人生观、世界观、价值观），学会了思考（<em>What matters</em>）等等。就像一台需要不断更新新的内容并删除旧的没有价值的内容的计算机，我们小脑袋的容量也是有限的，可不是花点钱就能升级更大RAM的。于是，我们从0，到呈指数型爆炸的知识增长阶段（求学阶段），到高速接收信息的稳定阶段（工作前期），到生活稳定下来转换人生角色感受生活另一面的日常阶段，我们的一生似乎已经要转完一个圈。然而在转圈的过程中，求知一直伴随我们左右，无论主动或是被动。</p><h3 id="工具制造"><a href="#工具制造" class="headerlink" title="工具制造"></a>工具制造</h3><p>人类不断发展，有一部分原因是人类善于思考。人类在想方设法地让自己的生活变得更加美好，无论是出于什么理由。</p><p>人类想制造工具的想法让我们积累了越来越多的知识，也让我们越来越乐于探索新的知识。每个人出生时都是好奇宝宝，不过随着时间的流逝，一些人专注于一些方面，随之对其他的不太感兴趣，也没有探索欲了。</p><h3 id="现代社会"><a href="#现代社会" class="headerlink" title="现代社会"></a>现代社会</h3><p>第三次工业革命——信息技术革命的到来与发展，使得人类社会像是坐上了一列加速度在不断增长的高速列车上。信息技术革命带来了信息爆炸，或者说是知识爆炸，这对于我们来说既是个好事情，又是个不那么好的事情（说什么话都两面说，这样比较有哲学家的范）。</p><p>好的方面，人类社会可以快速发展，就像近些年逐渐攀升的高铁速度一样，人们也觉得自己所处的时代是最好的时代，似乎想干什么就能干什么；不太好的一面，就是人类让自己处于一个不停运转的传送带上，想想吧，你是一个手无缚鸡之力的婴儿，被人放到传送带上后一走了之，你不担心自己的目的地是万丈深渊吗？因此我们需要不断学习，即使我们没有很理想的学习速度，但是至少要有危机意识。就像篮球场上的，即使你没有姚明的身高，但你的意识到了，一个后卫也可以让对方中锋无力反击。</p><h2 id="表达欲"><a href="#表达欲" class="headerlink" title="表达欲"></a>表达欲</h2><p>每个人都有表达自己的欲望。这里说的表达自己，是指希望自己的观点能够被他人听到，无论是否被理解。归根到底，人类是社会性动物，人不可能离开社会的群体而独自生活。</p><p>就像那个实验中体现的（好像是把一个人关进监狱，给他很多钱，但是让他待在一个小黑屋里，给他提供充足的食物和生活下去的必需品，但是不让他离开房间半步，同时不能和任何人接触，到最后好像疯了？？），虽然也有反例（比如<em>鲁滨逊漂流记</em>，<em>月亮与六便士</em>），鲁滨逊是因为意外，思特里克兰德则是因为想要追寻理想，喜欢画画过了头。他们并不是由于讨厌和这个社会相处而逃离。</p><p>那些小说中的人物在现实社会中出现的机率还是蛮小的，现实社会中类似的有<em>卢梭</em>，还有中国古代一些喜欢隐居的文人墨客如<em>陶渊明</em>等。但是他们实际上只是想逃离现实生活中的不满部分（如卢梭是因为喜欢自然，而且他虽然住在一栋无人光临的小屋中，但他有时候还是会回到岸上和人接触的，比如建造房子时需要购买材料；陶渊明隐居则是因为看够了官场争斗，并且自己喜欢田园生活），而且，这些人也都是有朋友的，他们只是觉得在复杂的社会里生活，不如追寻自己的内心，并不是讨厌和人相处。</p><h3 id="表达OR倾听？"><a href="#表达OR倾听？" class="headerlink" title="表达OR倾听？"></a>表达OR倾听？</h3><p>人类喜欢表达胜于喜欢倾听。</p><p>所以说，能遇到一个好好听你说话的人，就好好对待ta吧。就像那首歌里唱的<em>全世界谁倾听你</em>，正所谓知音难寻。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Desires/#disqus_thread</comments>
    </item>
    
    <item>
      <title>梦幻岛</title>
      <link>https://gitplayb.github.io/passages/Dreamland/</link>
      <guid>https://gitplayb.github.io/passages/Dreamland/</guid>
      <pubDate>Sun, 15 Dec 2019 16:07:09 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;每个人心中都有一座梦幻岛。&lt;/p&gt;
&lt;p&gt;希望有一天，你能带我到你家的小岛上去踏青。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>每个人心中都有一座梦幻岛。</p><p>希望有一天，你能带我到你家的小岛上去踏青。</p></blockquote><a id="more"></a><p>分享一首歌，大学校园里走在长桥上听到第一秒就爱不释👂的一首歌。</p><p>歌曲名叫<em>Island in the sun</em>，由美国独立摇滚乐队<a href="https://baike.baidu.com/item/weezer/3589565?fr=aladdin" target="_blank" rel="noopener">Weezer</a>演唱。</p>    <div id="aplayer-rzNQpxOY" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="20705824" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><p>歌词大意就是，我们可以在一个小岛上放空自己什么也不想，只有快乐在我们左右。</p><blockquote><p>When you’re on a holiday,</p><p>You can’t find the words to say.</p><p>All the things that come to you,</p><p>And I wanna feel it too.</p><p>On an island in the sun,</p><p>We’ll be playing and having fun.</p><p>And it makes me feel so fine</p><p>I can’t control my brain</p><hr><p>When you’re on a golden sea,</p><p>You don’t need no memory.</p><p>Just a place to call your own,</p><p>As we drift into the zone.</p><p>On an island in the sun,</p><p>We’ll be playing and having fun.</p><p>And it makes me feel so fine</p><p>I can’t control my brain</p><hr><p>We’ll run away together</p><p>We’ll spend some time forever</p><p>We’ll never feel bad anymore</p><p>Hip hip</p><p>Hip hip</p><p>Hip hip</p></blockquote><p>简陋地翻译一下：</p><blockquote><p>当你在度假的时候，你什么话也不想说</p><p>你经历的所有事情，我也想与你一起感受</p><p>在一个阳光下的小岛上，我们将开心地玩乐</p><p>这让我觉得如此美妙以至于无法控制我的大脑</p><p>当你在金色的大海上，什么事情都不需要记起</p><p>只需要找回真正的自己，在我们漂入大海的地方</p><p>我们将一起逃离无论什么鬼地方</p><p>我们将一起度过一段美好时光</p><p>我们再也不会感到很糟糕</p><p>嘿 嘿</p><p>嘿 嘿</p></blockquote>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Dreamland/#disqus_thread</comments>
    </item>
    
    <item>
      <title>那年今日</title>
      <link>https://gitplayb.github.io/passages/%E9%82%A3%E5%B9%B4%E4%BB%8A%E6%97%A5/</link>
      <guid>https://gitplayb.github.io/passages/%E9%82%A3%E5%B9%B4%E4%BB%8A%E6%97%A5/</guid>
      <pubDate>Fri, 15 Nov 2019 15:52:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;写在父亲生日&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>写在父亲生日<br><a id="more"></a></p><h2 id="第一堂课"><a href="#第一堂课" class="headerlink" title="第一堂课"></a>第一堂课</h2><p>我们的缘分，从许多年前我对你哭而你对我笑那一刻开始。不知道什么原因，我降临在一块你也不怎么熟悉的土地上，开始了和你的相爱相杀之旅。</p><p>我的记忆最早开始于上学之前的那段时间。当我看到和我差不多大的小朋友都蹦蹦跳跳地去学校的时候，我说：<em>”我也要上学！“</em>。你说，<em>你和别的小朋友不同，你得再等一等</em>。当时还不知道为什么下半年出生就要比别人上学晚。于是我每天背着心爱的小书包走来走去，想象我在学校里上课的样子。直到后来，我终于如愿以偿，在学校的第一堂课我永远也不会忘记。第一节课上，老师带我们玩了丢手绢，我还依稀记得：</p><blockquote><p>丢啊丢啊丢手绢</p><p>轻轻地放在小朋友的后面</p><p>大家不要告诉他</p><p>快点快点抓住他</p><p>快点快点抓住他</p></blockquote><p>当时觉得上学真好呀，还能做游戏。第一节课下了，我把书包收拾好，准备到和你约定好的地方，等你来接我。结果，左等右等没有等到你，我非常诧异。于是在附近转了转，好像也没什么人，心想<em>怎么放学了大家都不回家吗</em>。我又走回班里才发现，原来一上午要上四节课的啊。于是心有不甘地回了教室，感叹一句<em>”还好刚才没有在那里傻傻等半天“</em>。</p><h2 id="自行车"><a href="#自行车" class="headerlink" title="自行车"></a>自行车</h2><p>上学路程比较远，所以你说，给你买辆自行车吧。于是，在某个炎炎的下午，在摔过了无数次（也没几次）跤之后，终于算是勉强学会了。当时学会了，我以为我就要骑着练习的那辆车去上学呢。结果，某个下午你又给我一个惊喜–<em>”看看，新买的自行车怎么样“</em>。后来长大以后，看到这辆车真的觉得好小好可爱啊。不难想象当时我激动的心情，简直要跳起来了。熟能生巧，于是没过几天，经过了在漫长通勤路上的锤炼，我骑车的技术变得非常熟练：单手、空手、站起来、自己带自己…小孩的胆子你真的无法揣测。</p><h2 id="辅导书"><a href="#辅导书" class="headerlink" title="辅导书"></a>辅导书</h2><p>从小到大，我基本没有用过辅导书，因为我觉得，课本上的内容已经足够了，成绩也证明了一切。然而，小时候的那本礼物，我还是记忆尤其深刻。</p><p>你从外地回来，给我带了一本数学的辅导资料。我也不知道你是怎么知道我需要这些辅导材料的，当时上课学的内容也没有和你说过。可能是在书店里看到，然后问的店员吧（我猜）。于是，当你把这本书拿回来说是给我的时候，我非常惊讶，当然也很开心，因为买到的刚好是我们当时学的那一本。但是，由于我实在是没有看辅导书的习惯（直到高中才有），所以那本书荒废了很久。想到这，还是觉得有些遗憾（看了说不定我高中的数学就不用这么挣扎了）。</p><h2 id="第一个🏀"><a href="#第一个🏀" class="headerlink" title="第一个🏀"></a>第一个🏀</h2><p>初中时，因为一场篮球比赛的临时替补（当时算是班里高的），我爱上了打篮球。在那个处处散发着荷尔蒙的年纪，我这一爱还一发不可收。于是我开始了攻心战术，<em>”爸，我想要买个篮球，行吗，行不行嘛…“</em>。因为成绩还不错，而且也不算太贵吧（虽然和小时候的自行车差不多了），于是你答应了。和你一起去店里挑篮球的那个下午，阳光明媚。当拿着气打的足足的篮球出来的时候，你对我说，<em>”高兴吧“</em>，我也嘿嘿一笑。</p><p>后来你说，你年轻时也爱打篮球，还会三步上篮呢。于是我看你在我面前表演三步上篮，虽然动作没有那么敏捷了，但还是很有范儿呢！</p><h2 id="颁奖典礼"><a href="#颁奖典礼" class="headerlink" title="颁奖典礼"></a>颁奖典礼</h2><p>即使不说，每个父母还是有<em>望子成龙，望女成凤</em>的期盼的。每当我因为一些小事情需要被表扬时，站在台上或台下的你总是洋溢出喜不自禁的笑容。</p><p>多年以后，不知道我能做出天大的好事情，才能看到当年你脸上那，自豪而又温暖的笑容呢。</p><h2 id="写作文"><a href="#写作文" class="headerlink" title="写作文"></a>写作文</h2><p>很小的时候，因为读书少，所以不怎么会写作文。还记得第一篇作文被老师写了很多评语，然而并不是表扬我的，而是指出哪些地方应该怎么写。</p><p>我知道你喜欢文字，于是后来问你，作文应该怎么写。你却笑着说，<em>写作文有什么难的，你就把你心里想的写出来不就得了</em>。可是，我心里没有什么想法啊-_-。然后你又给我指了条路，多看看书，要写的有条理而且充满感情。于是，我后来写的作文还是不知道写什么。</p><h2 id="一周一次📞"><a href="#一周一次📞" class="headerlink" title="一周一次📞"></a>一周一次📞</h2><p>后来我去了更远的地方上学，你说要来送我，可是阴差阳错没有来到。某一段时间，可能由于心情不好，很少给家里打电话，直到某一次你们打了半天电话也没通，很担心我发生了什么事。等到我发现然后打过去，你们也没有怪我。于是我说，<em>以后要每周给你们打一次电话</em>。记得开始打电话时还是可以说很多话，但是后来就不知道说些什么，感觉每天都是那些重复的简单的问候。有时可能因为事情多拖到了很晚或者后一天才打，匆匆说几句话就挂掉。现在想想，其实你们也没有想说多少话，只是想告诉我家里很好不用担心，然后知道我在这边也过得很好，就够了。</p><h2 id="你的梦"><a href="#你的梦" class="headerlink" title="你的梦"></a>你的梦</h2><blockquote><p>曾梦想仗剑走天涯，看一看世间的繁华</p><p>年少的心总有些轻狂，如今你四海为家</p></blockquote><p>你曾经梦想着，穿上抖擞的迷彩服，在共和国的土地守卫疆土；</p><p>你曾经也梦想着，在方寸讲台上，将自己的知识与见地，传递领悟。</p><p>只是你早早地担上了生活的担子，在奔波与疲累间逐渐忘却你的梦。</p><p>其实并没有忘记，你只是把它放在了心中的那块柔软的角落，珍藏。</p><h2 id="老小孩"><a href="#老小孩" class="headerlink" title="老小孩"></a>老小孩</h2><p>你在我眼中，一直是个长不大的老小孩。你很爱笑，你也总能用你的笑容感染我。</p><p>然而今天，电话里听到你的声音，变得又沙哑厚实了一些，我不知道是该高兴还是心酸。但是无论如何，我还是很高兴，你还是那个尽管有时和我聊天会尴尬（主要是我的原因），但还是没话找话说的我记忆中的父亲。</p><h2 id="还有呢"><a href="#还有呢" class="headerlink" title="还有呢"></a>还有呢</h2><p>今晚本是个寻常的夜晚，只是耳机里播放到了刀郎的西海情歌，我听到的却没有情歌，只有西海。刀郎的声音总能让我想到家乡，想起那个等着妈妈做好饭，电视机上播放着<em>喀什噶尔胡杨</em>的画面的，美丽的下午。</p><hr><p>魏则西事件已经发生了很久但只是听说没有细看，今天看到了他父母为他发的最后一条知乎，还有他生前痛苦挣扎之际发的感谢帮助他的网友的话，再一次对生命感到敬畏了，生命的脆弱经不起我们折腾，每一个健康活着的人都应该感到荣幸。</p><hr><blockquote><p>好好活，就是做很多很多有意义的事儿</p></blockquote><p><em>士兵突击</em>，是第一部让我看哭的电视剧，忘不了三多的这句话。</p><hr><p>以上。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E9%82%A3%E5%B9%B4%E4%BB%8A%E6%97%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git多账号配置</title>
      <link>https://gitplayb.github.io/passages/Git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</link>
      <guid>https://gitplayb.github.io/passages/Git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Sat, 28 Sep 2019 06:26:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;有时候我们需要在一台电脑上配置多个Git账号（如公司一个、自己一个），道理还是一样，只是稍微麻烦一点。在这里记录一下操作过程。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有时候我们需要在一台电脑上配置多个Git账号（如公司一个、自己一个），道理还是一样，只是稍微麻烦一点。在这里记录一下操作过程。</p><a id="more"></a><h2 id="单账号"><a href="#单账号" class="headerlink" title="单账号"></a>单账号</h2><h3 id="SSH-Git的原理"><a href="#SSH-Git的原理" class="headerlink" title="SSH/Git的原理"></a>SSH/Git的原理</h3><p>Git使用HTTPS/SSH协议，如果使用https，则每次提交代码时需要输入用户名和密码；如果用ssh，则每次无需输入验证，由Git服务器进行验证。其中，公钥由Git服务器保存，自己本地保存的是私钥，验证时，服务器将公钥与你本地的私钥进行匹配。SSH是非对称加密的一个典型例子。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p><strong>生成一对公/私钥</strong></p><p>在本地Git客户端输入命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"邮箱地址"</span></span><br></pre></td></tr></table></figure></li></ol><p>​        ssh-keygen命令生成一对公/私钥，-t指定秘钥类型为rsa方式，-C为comment（注释）</p><ol start="2"><li><p><strong>将公钥保存到服务器</strong></p><p>将本地生成的公钥（<strong>.pub</strong>）复制下来，粘贴到Git服务器（如GitHub）<strong>New SSH key</strong>的地方，保存为一个可以区分的名字就好了</p></li><li><p><strong>测试连接</strong></p><p>在Git客户端测试是否能连接上Git服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>若看到这样的内容，代表连接成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Hi yourname! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>安装过程中会提示你输入<strong>passphrase</strong>，即口令。正常情况下（为了方便）可以不用输入，直接回车；输入的话就是为了防止别人操作你的电脑，也可以登录你的Git。输入过程中字符是不显示的（类似于web表单页面输入密码），出于安全考虑。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>来到公司后，由于公司这边用的是GitLab，于是配置了GitLab的SSH。配置了公钥和私钥后可以免密登录，很方便。但是，想要自己新建项目练习的时候发现，公司给的账号是<strong>LDAP账号</strong>，即<strong>域账号</strong>。由于域账号有权限的限制，所以自己什么也做不了，只能新建snippet（代码片段）。所以，想用GitHub来做项目练习。</p><p>之前自己有一个GitHub账号，也在自己的电脑上配置了SSH秘钥，即自己电脑可以和GitHub的服务器连上，进行本地代码库的一些操作。于是想在公司电脑上也配置一下秘钥就行了。</p><p>但是问题来了——</p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>第一次进行SSH配置时的配置文件在目录<strong><em>$USER/Administrator/.ssh</em></strong>下，包括<strong>id_rsa（私钥）和id_rsa.pub（公钥）</strong>。我如果再配置一个SSH连接，秘钥怎么命名呢？</p><p>很自然地想到，可以命名为：<strong>id_rsa_github和id_rsa_github.pub</strong>。但是Git要怎么识别呢？</p><p>于是在网上搜索一番，发现Git是可以配置多个账号的。</p><h3 id="1-分别生成公-私钥"><a href="#1-分别生成公-私钥" class="headerlink" title="1. 分别生成公/私钥"></a>1. 分别生成公/私钥</h3><p>生成公/私钥的过程和配置一个SSH连接的过程是一样的，同样的步骤✖2就好啦。</p><p>需要把不同的连接的公/私钥的名字区分开，并与<em>config</em>里的名字对应，这样Git服务器才知道到哪去找对应的秘钥。</p><h3 id="2-新建config"><a href="#2-新建config" class="headerlink" title="2. 新建config"></a>2. 新建config</h3><p>在<strong>.ssh</strong>目录下，新建一个配置文件<strong>config（无后缀）</strong>，用于对不同账号的主机进行配置。假如我们想同时配置一个GitLab的账号，一个GitHub的账号，那么我们需要做的就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host gitlab.com</span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    User yourname@yourhost.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile $USER/Administrator/.ssh/id_rsa_gitlab</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User yourname@yourhost.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile $USER/Administrator/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><p>可以看到，我们指定了验证身份时用到的是publickey（存放在Git服务器的公钥），并且匹配它的私钥文件是<strong>id_rsa_name</strong>，只要可以通过<strong>name</strong>来区分不同的账号即可。</p><p><strong>User</strong>是你的账号邮箱，也可以与你注册Git平台的邮箱不一致，只是你每次提交代码时的一个身份标记。</p><h3 id="3-将私钥添加到ssh-agent"><a href="#3-将私钥添加到ssh-agent" class="headerlink" title="3. 将私钥添加到ssh-agent"></a>3. 将私钥添加到ssh-agent</h3><p>有时，在本地配置好后还是无法克隆项目（<code>permission denied</code>）怎么办？这时候，还需要把自己的私钥添加到<strong>ssh-agent</strong></p><ol><li><p>在Git中输入<code>eval $(ssh-agent -s)</code>首先寻找一个ssh代理；</p></li><li><p>将自己的私钥告诉代理：<code>ssh-add ~/.ssh/id_rsa</code>。表示将主目录下的私钥<em>id_rsa</em>加入ssh连接。</p></li></ol><p>之后再打开Git，就不需要输入密码啦！Git的操作（clone等等）也都可以在本地进行了。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>爵士俱乐部一人游</title>
      <link>https://gitplayb.github.io/passages/%E7%88%B5%E5%A3%AB%E4%BF%B1%E4%B9%90%E9%83%A8%E4%B8%80%E4%BA%BA%E6%B8%B8/</link>
      <guid>https://gitplayb.github.io/passages/%E7%88%B5%E5%A3%AB%E4%BF%B1%E4%B9%90%E9%83%A8%E4%B8%80%E4%BA%BA%E6%B8%B8/</guid>
      <pubDate>Sun, 15 Sep 2019 16:59:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;万万没想到，自己竟然会在中秋节去听一场爵士乐的现场。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>万万没想到，自己竟然会在中秋节去听一场爵士乐的现场。</p><a id="more"></a><h2 id="阴差阳错"><a href="#阴差阳错" class="headerlink" title="阴差阳错"></a>阴差阳错</h2><p>原本计划和朋友去<strong>深圳湾公园</strong>散散步的，结果天公不作美，刚吃完饭出来，天就开始阴沉沉地哭诉了起来。就在我们还纠结是要冒着小雨去那里还是原路返回时，雨似乎帮我们做了决定——从小雨瞬间变成了大雨。于是我们只好找个商场躲了起来。</p><p>就在商场闲得无聊的时候，我想在美团上看看有没有好点的清吧，想去坐坐。看了一些，也有一些合适的，想叫小伙伴一起去，他说算了吧，我想自己去可能也比较无聊，就打算放弃。可是浏览的过程中，发现有些是音乐主题的，突然来了兴趣，于是直接搜索<em>live house</em>，没想到附近还真有一个。然后赶紧点开看了看评论，还不错，关键是有人拍了视频，8月30日的现场表演嘉宾竟然有<code>顾忠山</code>！他可是我知道的为数不多的本土爵士音乐家。而且还有朋友听过他的现场，并给我推荐过。这让我一时心潮澎湃啊，顿时觉得这家店还是蛮有逼格的哈哈哈。评论中有的说蛇口的这家是深圳唯一的一家Jazz Club，心里不敢相信，觉得深圳这么大的城市应该挺多这样的<code>吧</code>。不过，就我看来也不是没有可能的。深圳可能忙着发展经济和技术去了，像上海那样的城市可能多点（主要是国内欣赏这个的比较少，而且专门玩这个的音乐家也很稀缺，没有环境和氛围）。</p><p>于是，打了下电话咨询了一下，waiter帮我预约了吧台的座位，就开开心心地过去了。</p><h2 id="首个Live-house"><a href="#首个Live-house" class="headerlink" title="首个Live house"></a>首个Live house</h2><p>我原本打算坐公交过去，查了下路线发现，公交站离我那里有大概总路线的1/3，就直接散步走过去了。当我走到那家俱乐部所在的小巷时，隐约已经传出了一些音乐声。门口摆放着一个double bass（爵士乐的经典四大件之一），从门口瞧了一眼，店面不大，是那种比较cozy的小清吧。</p><p>刚到那坐下，还没到表演时间，里面的人们在喝酒聊天，表演场地已经收拾好了，房子内的音乐声是从音箱里传出来的，waiter在忙着为客人调酒。进去以后看到了菜单，第一页写着一条<em>“每一位客人至少点一杯饮料“</em>，我觉得这也很正常，毕竟有乐队现场演出。点了一杯威士忌，因为上面有很多种类，每一类下面又有很多不同的”代号“，所以看了一下大概价格，就随便点了一个。等waiter端上来我喝了第一口，有点后悔。忘了威士忌是烈酒，赶紧问了下度数，他说是40°，这才安心了一点。不过刚好我要的是加冰的，随着冰块的融化，酒变得越来越淡，也容易入口多了。</p><h2 id="爵士乐队"><a href="#爵士乐队" class="headerlink" title="爵士乐队"></a>爵士乐队</h2><p>当晚的爵士乐队好像是常驻在那里表演的，主要的键盘、吉他、贝斯手都没换，鼓手倒是换了好几个。从刚开始表演，到后面的<code>jam session</code>，一共有三个鼓手。每个乐手演奏的都挺投入，但是我还是最喜欢吉他手，因为f孔空心吉他的<strong>Sweet tone</strong>（甜美的音色）是最让我无法抗拒的！幸运的是，我的手机还坚持下来（不时清一下内存）拍了很多照片，也录了一些视频，当然最后的jam session因为太长就只录了音。</p><h2 id="日本朋友"><a href="#日本朋友" class="headerlink" title="日本朋友"></a>日本朋友</h2><p>原本没想到会有这么多日本的朋友来这里。一进去就看到了几个金发碧眼的欧美白人，后来发现坐在吧台的，我旁边一串日本友人。当晚去的人还是比较多的，还有几个是站在门口附近听的，开始就看到他们随着音乐的律动晃动身体，觉得大家还真是挺享受音乐的（抖就完事了）。</p><h2 id="一些图片"><a href="#一些图片" class="headerlink" title="一些图片"></a>一些图片</h2><p><img src="/passages/爵士俱乐部一人游/Meeting-Jazz.jpg" alt="Meeting-Jazz" title="Meeting-Jazz"><br><img src="/passages/爵士俱乐部一人游/drinks.jpg" alt="吧台" title="吧台"><br><img src="/passages/爵士俱乐部一人游/band.jpg" alt="乐队" title="乐队"></p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E7%88%B5%E5%A3%AB%E4%BF%B1%E4%B9%90%E9%83%A8%E4%B8%80%E4%BA%BA%E6%B8%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>新生活二三事</title>
      <link>https://gitplayb.github.io/passages/%E6%96%B0%E7%94%9F%E6%B4%BB%E4%BA%8C%E4%B8%89%E4%BA%8B/</link>
      <guid>https://gitplayb.github.io/passages/%E6%96%B0%E7%94%9F%E6%B4%BB%E4%BA%8C%E4%B8%89%E4%BA%8B/</guid>
      <pubDate>Sun, 08 Sep 2019 12:32:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;入职已经将近一个月了，原本打算一周写一次总结之类的东西，到现在才算是挤出来了第一篇。以后会做到一周一更的🤔&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>入职已经将近一个月了，原本打算一周写一次总结之类的东西，到现在才算是挤出来了第一篇。以后会做到一周一更的🤔<br><a id="more"></a></p><h2 id="初入职场"><a href="#初入职场" class="headerlink" title="初入职场"></a>初入职场</h2><blockquote><p>该来的总会来的，你不可能永远是一个学生</p></blockquote><p>当然，你可以选择<strong>做</strong>一个学生（有句话怎么说的来着，终生学习对吧），毕竟有这么多东西需要学习，无论是专业方面还是你的兴趣方面，或者生活中的方方面面。</p><p>从来时火车上的不确定感，到进入公寓后行李落地的那一刻，我意识到我的新生活就要开始了。</p><p>在培训基地培训的日子过得很漫长，或许是因为每天的生活<em>被安排的满满当当（<del>明明白白</del>）</em>，所以我们每天什么也不想，再加上网络问题，我们唯一的乐趣就是在宿舍里和新同事们聊聊天。小伙伴儿们都是来自各个学校的，大家都挺友好、挺可爱的，因为住在一起的都是一个部门的，所以聊起来也有比较多的话题。在培训基地为我们培训的领导们也都是来自集团各个部门的前辈，而且有很多是“校招大学生”。听了一些领导的极富感染力的演讲后，确实让人心头燃起了一些热火。这期间还做了很多新奇的小（大）游戏，见识到了来自各个学校的伙伴们的聪明才智，也让我们学到了团队合作等。</p><h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><p>第一天到工位以后，发现自己将要待着敲代码的地方环境还是不错的，新配的电脑，舒适的椅子，以及窗外不错的view。了解了自己部门以及小组做的主要业务后，导师说我们要先熟悉一下Spring Boot的使用，以及微服务方面的知识。因此之后的几周一直在看相关的资料与demo项目。</p><p>开始的一天半基本是在安装软件和配置环境中度过的。大部分都可以安装成功，还有一些需要管理员权限。之前用自己的电脑倒没发现管理员权限竟然这么关键，公司这块还是挺严格的。如果安装一些电脑上没有预置的，需要权限的，就需要给help center打电话，请他们来安装。</p><p>和自己在一块办公的还有两个小伙伴，我们上班时间也都一起学习，遇到问题也可以讨论。</p><h2 id="学习成果"><a href="#学习成果" class="headerlink" title="学习成果"></a>学习成果</h2><p>在网上找了一些Spring Boot的学习资料，大略看了其中的内容后，选择了几个比较感兴趣的。目前脑子里留下最多的印象就是<em>Spring Boot为什么好，它怎么做到的自动配置，你可以用它来做微服务开发等等</em>。看了几个简单的小项目后，也对一些常见的注解有了了解。因为没有一本权威的书籍，所以自己在同时看几个相关的，里面也有配套的不同的项目，希望这样自己可以对用Spring Boot开发有一个更全面的认识，在项目的相同处和不同处之中找到一些key point。</p><h2 id="哦，生活"><a href="#哦，生活" class="headerlink" title="哦，生活"></a>哦，生活</h2><p>某天晚上，睡觉前听到了雨声，就突然没了困意，于是想把这“烦人的雨”记录下来，咳咳。</p><blockquote><p><em>夜，</em></p><p><em>像个冒失鬼一样将我包围</em></p><p><em>窗外偷偷飘来一阵雨水</em></p><p><em>速度快到还没被我的耳机捕捉</em></p><p><em>就已经了无踪影</em></p><p><em>你，</em></p><p><em>像个偷心贼一般将我劝退</em></p><p><em>眼前匆匆回放（闪过）的一段影像（倒影）</em></p><p><em>画面模糊到我想要伸手触摸</em></p><p><em>却发现无足重轻</em></p></blockquote>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E6%96%B0%E7%94%9F%E6%B4%BB%E4%BA%8C%E4%B8%89%E4%BA%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>毕业小记</title>
      <link>https://gitplayb.github.io/passages/Graduation/</link>
      <guid>https://gitplayb.github.io/passages/Graduation/</guid>
      <pubDate>Tue, 28 May 2019 08:44:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;[GAME OVER 0_0]&lt;/strong&gt;. &lt;em&gt;Do you wanna restart?&lt;/em&gt;&lt;br&gt;&lt;code&gt;y or n&lt;/code&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>[GAME OVER 0_0]</strong>. <em>Do you wanna restart?</em><br><code>y or n</code></p><a id="more"></a><h2 id="毕业视频"><a href="#毕业视频" class="headerlink" title="毕业视频"></a>毕业视频</h2><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"loop":true,"video":{"url":"/passages/Graduation/graduation.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Graduation/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
