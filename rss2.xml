<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Oliv&#39;s Blog</title>
    <link>https://gitplayb.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 22 Dec 2019 15:20:55 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>SPMIA</title>
      <link>https://gitplayb.github.io/passages/SPMIA/</link>
      <guid>https://gitplayb.github.io/passages/SPMIA/</guid>
      <pubDate>Sun, 22 Dec 2019 14:57:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;英文版&lt;em&gt;Spring Microservices in Action&lt;/em&gt;读书笔记。英文书的特点就是篇幅很长话很多，比较容易理解，适合初学者；但不好就是如果想要消化得好就读起来太慢&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>英文版<em>Spring Microservices in Action</em>读书笔记。英文书的特点就是篇幅很长话很多，比较容易理解，适合初学者；但不好就是如果想要消化得好就读起来太慢</p><a id="more"></a><h2 id="1-欢迎来到云的世界"><a href="#1-欢迎来到云的世界" class="headerlink" title="1 欢迎来到云的世界"></a>1 欢迎来到云的世界</h2><p><strong>什么是微服务</strong></p><ul><li>应用逻辑被拆分成很多组件，组件之间（功能/职责）界限分明，合作来完成一个项目</li><li>每个组件完成某一domain的小任务，可以独立部署。一个微服务应是可重用的。</li><li>组件之间基于一些原则进行通信——HTTP、JSON来进行数据交换</li><li>不关心用什么技术来实现（因为使用的是技术无关性的”协议“–JSON）</li><li>由于其小、独立、分布式的特点，这些微服务可以有很多个小团队实现</li></ul><p><strong>为什么可以用Spring来构建微服务</strong></p><p>Spring是一个基于<strong>依赖注入</strong>的框架，不同于传统的Java应用中通过硬编码（类之间的相互调用）的方式将类进行链接（带来的坏处就是一旦编译完，类间的链接关系就不能改变了），Spring采用的是<strong>将类间的依赖/链接关系外部化（externalize）</strong>，能够更好的管理依赖。</p><p>使用Spring Boot和Spring Cloud，我们可以更方便地开发分布式的微服务，并将它们部署到云上。</p><p><strong>读这本书你可以学到</strong></p><ul><li>什么是微服务，如何设计构建一个微服务</li><li>什么时候不应该使用微服务</li><li>如何使用Spring Boot来构建微服务</li><li>构建微服务应用（基于云的）有哪些可行的pattern</li><li>怎样用Spring Cloud实现那些patterns</li><li>如何构建一个<strong>deployment pipeline</strong>，用于将服务部署到私有/公有云上</li></ul><p><strong>为什么要采用微服务架构</strong></p><p>随着技术的发展，现代社会的方方面面都被互联网连接起来了。任何一款产品都可能面向全球的竞争者，开发者也遇到了更大的挑战：</p><ul><li><strong>复杂度上升</strong>——应用不再是单打独斗，往往需要和其他的应用进行交互。比如阿里的支付宝现在绝不仅仅只是一个手机支付的app，它甚至涵盖了出行的基本需要（需要用到钱的地方）</li><li><strong>客户想要快速交付</strong>——用户没有耐心等待每一个新版本软件包的发行，他们希望每当更新了新的feature后可以很快地使用</li><li><strong>性能和可扩展性</strong>——全球化（数量级）的应用使得很难预测应用的交易量能达到多少，应用必须有能快速在多台服务器之间进行扩展（scale up）、不需要时收缩（scale down）的能力</li><li><strong>高可用性</strong>——用户希望应用是一直可用的，即不会崩溃或者出现什么bug</li></ul><p>通过将服务改造成微服务架构，我们得到的应用将会是：小的、简单的、松耦合的，即可扩展的、适应性强的、灵活的。</p><p><strong>什么是云</strong></p><p>云计算的三种基本模型：</p><ul><li><strong>Infrastructure as a Service（IaaS）</strong></li><li><strong>Platform as a Service（PaaS）</strong></li><li><strong>Software as a Service（SaaS）</strong></li></ul><p>除此之外，还有一些新兴的云平台类型，如：</p><ul><li><strong>Function as a Service（FaaS）</strong></li><li><strong>Container as a Service（CaaS）</strong></li></ul><p>FaaS使用到的技术如Amazon的Lambda技术以及Google Cloud Functions，构建出<strong>“Serverless”</strong>的应用可以完全运行在云服务提供商的计算平台。</p><p>CaaS指的就是将微服务作为便携的（portable）虚拟容器（如Docker）部署到云上。不像IaaS（你需要管理你的虚拟机器），你可以直接使用云服务提供商提供的工具来<strong>构建、发布、监测、扩展</strong>等等。Amazon的ECS（弹性容器服务）就是一例。</p><p><strong>云和微服务</strong></p><p>写好了微服务，一般来说有三种方式部署</p><ul><li><strong>物理服务器</strong>——不易扩展</li><li><strong>虚拟机器镜像</strong>——易扩展</li><li><strong>虚拟容器</strong>——易扩展，且较轻量级</li></ul><p>基于云的微服务最大的好处就是可伸缩性，即增强了它的横向扩展能力。</p><p>本书中使用Docker将微服务部署到基于IaaS的云上。</p><ul><li><strong>简化基础设施管理</strong>——通过简单的API调用，即可实现对基础设施的管理</li><li><strong>强大的横向扩展能力</strong>——可以很快地开启多个实例</li><li><strong>多地配置带来的高冗余性</strong>——通常云提供商会在多个地理位置拥有数据中心</li></ul><p><strong>为什么不使用PaaS？</strong></p><p>在这么多云服务模型中，IaaS是提供的服务最少的，只有Infrastructure，同时也是最灵活的，因为其它的部分你可以自己选择。之所以选择IaaS是因为当我们的微服务变得越来越多时，需要更大的灵活性。</p><p>使用PaaS你可以将应用作为JAR包或者WAR包部署上去。你不需要设置/修改应用服务器和相关的Java容器，这一点比较方便。</p><p>另外，基于FaaS的平台将会使你更加受限制。因为你虽然可以用自己熟悉的语言来写自己的服务，但是你需要严重依赖vendor提供的API和运行时引擎（runtime engine）（只有在那个引擎上你的应用才能正确function）。</p><h3 id="1-9-微服务不只是写代码"><a href="#1-9-微服务不只是写代码" class="headerlink" title="1.9 微服务不只是写代码"></a>1.9 微服务不只是写代码</h3><p>构建一个robust的微服务不只是写写代码。有几件事需要考虑：</p><ul><li><strong>大小适中</strong>——确保每一个微服务的职责边界大小合适，只有这样才能方便对应用做出修改并在特殊情况下降低风险</li><li><strong>定位透明（？）</strong>——怎样管理服务调用时的物理细节，多个实例可以快速启动/关闭</li><li><strong>灵活性</strong>——当服务fail时怎么通过路由（routing）保证应用的完整性，保护用户【就是错误处理吧】</li><li><strong>可复现</strong>——怎样确保服务中的每一个新的实例都有和生产环境中的实例相同的配置和code base（代码库）</li><li><strong>可扩展</strong>——怎么使用异步处理和事件来减少服务之间的直接依赖，并保证可扩展性</li></ul><p>接下来，介绍六个微服务模式：</p><ul><li>Core Development Pattern</li><li>路由模式</li><li>客户端灵活性（resiliency）模式</li><li>安全模式</li><li>日志和轨迹（trace）模式</li><li>构建和开发模式</li></ul><h4 id="1-9-1-核心开发模式"><a href="#1-9-1-核心开发模式" class="headerlink" title="1.9.1 核心开发模式"></a>1.9.1 核心开发模式</h4><ul><li><strong>服务粒度</strong>——怎样将业务（business domain）拆分成适当的微服务？若分的太粗略则职责会overlap；若分得太细则增加了应用的复杂度</li><li><strong>通信协议</strong>——JSON？XML？</li><li><strong>接口设计</strong>——怎样设计接口以供开发者调用？好的接口设计是intuitive，即让人看到你的接口就知道它是做什么的</li><li><strong>配置管理</strong>——怎样管理配置才能做到在不同云环境无需改动核心应用代码和配置</li><li><strong>事件处理</strong>——怎样通过事件处理将硬编码部分减到最少，增加应用的灵活性（resiliency）</li></ul><h4 id="1-9-2-路由模式"><a href="#1-9-2-路由模式" class="headerlink" title="1.9.2 路由模式"></a>1.9.2 路由模式</h4><p><strong>routing pattern</strong>要解决的是要使用微服务的客户端如何发现服务的location并被路由过去。</p><p>在基于云的应用中，你可能有很多微服务实例同时在运行。你应该将这些服务的物理地址抽象出来，为服务调用提供一个统一的入口，以便一直保持应用的安全性。</p><ul><li><strong>Service discovery</strong>——怎样设计（不通过硬编码service的location）使得你的服务容易被发现？怎样保证不能正确执行的微服务实例能够从可运行的服务实例中抽出？</li><li><strong>Service routing</strong>——怎样为不同服务设计统一入口？</li></ul><h4 id="1-9-3-客户端灵活性"><a href="#1-9-3-客户端灵活性" class="headerlink" title="1.9.3 客户端灵活性"></a>1.9.3 客户端灵活性</h4><p>微服务架构是高度分布式的，所以要特别注意某一服务中的问题会级联（影响）到其他的用户。为此，我们有以下四种模型：</p><ul><li><strong>客户端负载均衡</strong>——怎样在客户端缓存服务实例的地址（location）以便对某个包含多个实例的微服务的调用（请求）能被均衡的分发到所有正常运行的微服务实例中？</li><li><strong>电路断路器模式</strong>——怎样让一个客户端在请求失败或者遭遇性能问题时停止请求？当某个服务遭遇性能瓶颈，它会消耗调用它的客户端的资源。应该做到让微服务调用<strong>fail fast（死得快）</strong>来提醒客户端快速做出反应</li><li><strong>撤退模式（Fallback）</strong>——当一个微服务fail时，怎样提供一个插件机制使客户端能够通过别的方式而不是调用这个坏掉的服务的方式完成工作</li><li><strong>隔板模式（Bulkhead）</strong>——微服务使用分布式的资源来完成工作。怎样划分这些调用请求以防止某个服务失效影响到其他服务？</li></ul><h4 id="1-9-4-安全模式（Security）"><a href="#1-9-4-安全模式（Security）" class="headerlink" title="1.9.4 安全模式（Security）"></a>1.9.4 安全模式（Security）</h4><ul><li><strong>Authentication（验证）</strong>——验证客户端的身份</li><li><strong>Authorization（授权）</strong>——确定客户端有权限使用服务（确定了client的身份后）</li><li><strong>Credential management and propagation（证书管理和传播）</strong>——怎样使客户端不需要么次调用服务时都需要出示证书？可以使用基于token的安全标准，如<strong>OAuth2</strong>和<strong>JavaScript Web Tokens（JWT）</strong>，获得的token用来在服务与服务之间验证并为用户授权。</li></ul><h4 id="1-9-5-日志和追踪（tracing）模式"><a href="#1-9-5-日志和追踪（tracing）模式" class="headerlink" title="1.9.5 日志和追踪（tracing）模式"></a>1.9.5 日志和追踪（tracing）模式</h4><ul><li><strong>日志关系（correlation）</strong>——怎样将同一个用户交易（transaction）下的不同微服务的所有日志绑定在一起？可以实现一个<strong>关系ID（correlation ID）</strong>，作为一个单独的标识符，在一次事务的不同服务之间作为标识。</li><li><strong>日志聚合（aggregation）</strong>——如何将微服务产生的所有日志放到一起组成一个可查询的数据库？可以借助<strong>correlation ID</strong>。</li><li><strong>微服务轨迹（tracing）</strong>——怎么将一个客户端交易事务所涉及的所有微服务的流程可视化，并分析其中的性能</li></ul><h4 id="1-9-6-构建-发布模式"><a href="#1-9-6-构建-发布模式" class="headerlink" title="1.9.6 构建/发布模式"></a>1.9.6 构建/发布模式</h4><p>为了构建<strong>immutable infrastructure</strong>，我们需要确保一个服务的任何实例都与其他实例是不同的，并且一旦一个服务部署上去，它所在的infrastructure再也不会改变了。</p><ul><li><strong>构建/发布pipeline</strong>——怎样创造一个可重复的构建/发布过程，可以一键构建/部署到任何环境？</li><li><p><strong>Infrastructure as code</strong>——怎样做到“服务即代码”，即可以被执行，源代码被管理</p></li><li><p><strong>不变的服务器</strong>——一旦一个微服务的镜像被创建了，怎样保证在发布之后不被改变？</p></li><li><strong>Phoenix servers</strong>——服务器运行时间越长，越容易发生<strong>configuration drift（配置漂移）</strong>（配置发生变化）。怎样保证日常崩溃的服务器能由一个不变的镜像恢复重建？</li></ul><h3 id="1-10-使用Spring-Cloud构建微服务"><a href="#1-10-使用Spring-Cloud构建微服务" class="headerlink" title="1.10 使用Spring Cloud构建微服务"></a>1.10 使用Spring Cloud构建微服务</h3><p>使用Spring Cloud构建微服务的好处就是它集成了很多开发需要用到的patterns。</p><h4 id="1-10-1-Spring-Boot"><a href="#1-10-1-Spring-Boot" class="headerlink" title="1.10.1 Spring Boot"></a>1.10.1 Spring Boot</h4><p>Spring Boot极大简化了基于REST的微服务构建过程；简化了HTTP动词和URL的映射；简化了JSON协议和Java对象的序列化；简化了Java异常和HTTP异常代码的映射。</p><h4 id="1-10-2-Spring-Cloud-Config"><a href="#1-10-2-Spring-Cloud-Config" class="headerlink" title="1.10.2 Spring Cloud Config"></a>1.10.2 Spring Cloud Config</h4><p>Spring Cloud Config通过中心化的服务来处理管理应用的配置数据，使得应用的配置数据与服务分开。好处是无论新增了多少微服务实例，都可以拥有相同的配置。除了自己的property管理仓库，还集成了许多开源项目，如：</p><ul><li><strong>Git</strong>：版本控制系统</li><li><strong>Consul</strong>：开源的、服务发现工具。你可以用来注册自己的服务，客户端可以询问Consul服务的位置。Consul也包括一个key-value数据库，可以存储应用配置数据</li><li><strong>Eureka</strong>：开源的Netflix项目，与Consul类似</li></ul><h4 id="1-10-3-Spring-Cloud-Service-Discovery"><a href="#1-10-3-Spring-Cloud-Service-Discovery" class="headerlink" title="1.10.3 Spring Cloud Service Discovery"></a>1.10.3 Spring Cloud Service Discovery</h4><p>通过Spring Cloud，你可以把你服务器的物理地址抽象化，服务使用者（客户端）可以通过一个逻辑名而不是物理location来访问。Spring Cloud同样处理服务实例的注册与注销。可以使用<strong>Consul</strong>作为服务发现引擎。</p><h4 id="1-10-4-Spring-Cloud-Netflix-Hystrix-and-Ribbon"><a href="#1-10-4-Spring-Cloud-Netflix-Hystrix-and-Ribbon" class="headerlink" title="1.10.4 Spring Cloud/Netflix Hystrix and Ribbon"></a>1.10.4 Spring Cloud/Netflix Hystrix and Ribbon</h4><p>Spring Cloud集成了很多Netflix的开源项目。对于客户端灵活性模式，Spring Cloud使用Netflix Hystrix库和Ribbon项目来完成。</p><p>使用Hystrix库，你可以很快实现客户端弹性模式，如<strong>断路器模式</strong>和<strong>舱壁模式</strong></p><h4 id="1-10-5-Spring-Cloud-Netflix-Zuul"><a href="#1-10-5-Spring-Cloud-Netflix-Zuul" class="headerlink" title="1.10.5 Spring Cloud/Netflix Zuul"></a>1.10.5 Spring Cloud/Netflix Zuul</h4><p>Netflix Zuul为微服务应用提供服务路由功能。Zuul是代理服务请求的服务网关，通过集中的服务调用，开发人员可以强制执行服务策略，如安全验证、内容过滤和路由规则。</p><h4 id="1-10-6-Spring-Cloud-Stream"><a href="#1-10-6-Spring-Cloud-Stream" class="headerlink" title="1.10.6 Spring Cloud Stream"></a>1.10.6 Spring Cloud Stream</h4><p>可以通过Stream将轻量级消息处理集成到微服务中。借助它，开发人员能够构建智能的微服务，它可以使用在应用程序中出现的<strong>异步事件</strong>。此外,Stream可以将微服务与消息代理整合，如<strong>RabbitMQ</strong>和<strong>Kafka</strong>。</p><h4 id="1-10-7-Spring-Cloud-Sleuth"><a href="#1-10-7-Spring-Cloud-Sleuth" class="headerlink" title="1.10.7 Spring Cloud Sleuth"></a>1.10.7 Spring Cloud Sleuth</h4><p>Sleuth让你可以将唯一的<strong>tracking identifiers（跟踪标识符）</strong>集成到HTTP调用和消息通道中（RabbitMQ、Kafka）。这些<strong>tracking number（跟踪号码）</strong>，也叫<strong>correlation/trace Id（关联Id）</strong>可以在应用程序的不同的服务中跟踪一个事务/交易。使用Sleuth，这些trace ID会自动添加到日志中。</p><p>Sleuth真正大放异彩是和<strong>日志聚合工具如Papertrail</strong>和<strong>跟踪工具如Zipkin</strong>等结合的时候。<strong>Papertrail</strong>是一个基于云的日志平台，可以实时将不同微服务产生的日志聚合成一个可查询的数据库。<strong>Zipkin</strong>可以将Sleuth产生的数据通过可视化的方式来展示某次事务/交易中涉及的服务调用（service call）工作流（flow）。</p><h4 id="1-10-7-Spring-Cloud-Security"><a href="#1-10-7-Spring-Cloud-Security" class="headerlink" title="1.10.7 Spring Cloud Security"></a>1.10.7 Spring Cloud Security</h4><p>这是一个用于验证（authentication）和授权（authorization）的框架，可以控制访问本服务的人员和他们的权限。Spring Cloud Security是基于token的，允许服务之间通过认证服务器（authentication server）授予的token来通信。每当服务接收到调用请求，会检查HTTP请求附带的token，验证其身份和访问权限。</p><p>此外，Security支持<strong>JWT</strong>。JWT框架可以标准化一个<strong>OAuth2</strong>token的创建格式，并为<strong>创建令牌进行数字签名</strong>提供了标准。</p><h4 id="1-10-8-代码供应（provisioning）"><a href="#1-10-8-代码供应（provisioning）" class="headerlink" title="1.10.8 代码供应（provisioning）"></a>1.10.8 代码供应（provisioning）</h4><p>提到代码供应，我们需要额外的技术栈。Spring框架是一个面向应用开发的框架，并不包括构建/部署的工具。要实现一个<strong>build and development pipeline</strong>，你需要使用<strong>Travis CI</strong>作为构建工具，用<strong>Docker</strong>来构建包含微服务的服务器镜像。</p><h3 id="1-11-Spring-Cloud完整的小例子"><a href="#1-11-Spring-Cloud完整的小例子" class="headerlink" title="1.11 Spring Cloud完整的小例子"></a>1.11 Spring Cloud完整的小例子</h3><h3 id="1-12-本书要完成的项目"><a href="#1-12-本书要完成的项目" class="headerlink" title="1.12 本书要完成的项目"></a>1.12 本书要完成的项目</h3><h3 id="1-13-总结"><a href="#1-13-总结" class="headerlink" title="1.13 总结"></a>1.13 总结</h3><ul><li>微服务是很小的一个功能模块，负责特定的领域</li><li>没有行业标准，不像其他网络服务协议，微服务采用基于原则的方法，与REST和JSON相似</li><li>写微服务很容易，当将其完全用于生产（production）需要多加考虑。包含要实现的几种模式（上文讲到的）</li><li>虽然微服务与语言无关，但本书引入两个框架：Spring Boot和Spring Cloud</li><li>Spring Boot是为了简化基于REST/JSON的微服务的开发的</li><li>Spring Cloud是一系列开源技术的集合（包括Netflix下的项目）</li></ul><h2 id="2-使用Spring-Boot构建微服务"><a href="#2-使用Spring-Boot构建微服务" class="headerlink" title="2 使用Spring Boot构建微服务"></a>2 使用Spring Boot构建微服务</h2><h3 id="2-1-架构师的故事——设计微服务架构"><a href="#2-1-架构师的故事——设计微服务架构" class="headerlink" title="2.1 架构师的故事——设计微服务架构"></a>2.1 架构师的故事——设计微服务架构</h3><p>三个关键任务：</p><ol><li>分解业务问题</li><li>建立服务粒度</li><li>定义服务接口</li></ol><h4 id="2-1-1-分解业务问题"><a href="#2-1-1-分解业务问题" class="headerlink" title="2.1.1 分解业务问题"></a>2.1.1 分解业务问题</h4><ol><li>描述业务，注意<strong>名词：contracts（合同）、licenses（许可证）、assets（资产）</strong>。</li><li>注意<strong>动词：查找、更新</strong>。</li><li>寻找数据内聚（cohesion）：寻找数据之间的关系。每个微服务应该只包含自己的数据。</li></ol><p><strong>EagleEye</strong>的数据模型可以简化为四个部分：<strong>Organization、License、Contract、Assets</strong>。</p><h4 id="2-1-2-建立服务粒度（granularity）"><a href="#2-1-2-建立服务粒度（granularity）" class="headerlink" title="2.1.2 建立服务粒度（granularity）"></a>2.1.2 建立服务粒度（granularity）</h4><p>基于数据模型，我们将在以下四个元素上建立微服务：</p><ul><li><strong>Assets</strong></li><li><strong>License</strong></li><li><strong>Contract</strong></li><li><strong>Organization</strong></li></ul><p><strong>如何建立合适的粒度？</strong></p><ol><li><strong>由大到小</strong>——开始的时候先比较粗略地划分一下，之后将问题域逐渐细分，直到找到一个比较好的大小。否则，开始就划分太细会导致应用复杂度过大。</li><li><strong>注意交互</strong>——有助于建立服务的粗粒度接口，由粗到细是比较容易的</li><li><strong>服务职责会改变</strong>——当需要新的应用功能时，服务就会有新的职责。最初的微服务可能会拆分成多个微服务，原始的微服务作为这些新服务的编排层（orchestration/arrangement），负责将应用其他部分的功能封装起来。</li></ol><p><strong>“糟糕”的微服务</strong></p><ul><li><strong>服务承担过多的职责</strong>——某个服务的业务逻辑很复杂</li><li><strong>服务管理了太多的数据表</strong>——服务需要使用很多表来管理数据，每个服务应该只管理自己的数据，其他的通过交互/通信实现，一个服务最好包含<strong>3-5张表</strong></li><li><strong>太多的测试用例</strong>——每个微服务可能随着时间增长。开始就有很多测试用例，增长空间会变得很小</li><li><strong>粒度太细的微服务</strong>：<ul><li><strong>Everything都是一个微服务</strong>，每个服务只和一个数据库表打交道</li><li><strong>服务之间互相依赖严重</strong>——为了完成一个用户请求，一个服务需要来来回回调用其他的服务</li><li><strong>微服务成为简单CRUD的集合</strong>——<em>微服务是业务逻辑的表达，而不只是数据源的抽象层</em></li></ul></li></ul><h4 id="2-1-3-交互：定义服务接口"><a href="#2-1-3-交互：定义服务接口" class="headerlink" title="2.1.3 交互：定义服务接口"></a>2.1.3 交互：定义服务接口</h4><ol><li><strong>拥抱REST理念</strong></li><li><strong>使用URI来传递意图（intent）</strong>——作为服务端点的URI描述问题域中的不同资源，并能表示出资源之间的关系</li><li><strong>请求和响应使用JSON</strong>——轻量级的数据序列化协议</li><li><strong>使用HTTP状态码表示结果</strong>——用HTTP状态码表示服务的成功/失败</li></ol><h3 id="2-2-什么时候不使用微服务"><a href="#2-2-什么时候不使用微服务" class="headerlink" title="2.2 什么时候不使用微服务"></a>2.2 什么时候不使用微服务</h3><ol><li><strong>构建分布式系统的复杂性</strong></li><li><strong>虚拟服务器/容器散乱</strong></li><li><strong>应用类型</strong></li><li><strong>数据事务和一致性</strong></li></ol><h4 id="2-2-1-构建分布式系统的复杂性"><a href="#2-2-1-构建分布式系统的复杂性" class="headerlink" title="2.2.1 构建分布式系统的复杂性"></a>2.2.1 构建分布式系统的复杂性</h4><p>由于微服务是分布式的且细粒度的，构建起来往往比构建单体应用程序更复杂。微服务架构需要一个很高的运维成熟度（operational maturity）。除非部门愿意投入高分布式应用程序所需要的自动化以及运维工作（监控，scale up/down），否则不要考虑使用微服务。</p><h4 id="2-2-2-服务器散乱"><a href="#2-2-2-服务器散乱" class="headerlink" title="2.2.2 服务器散乱"></a>2.2.2 服务器散乱</h4><p>微服务最常用的部署方式就是<strong>一个服务器上部署一个微服务实例</strong>。在一个基于微服务的大型应用中，最终可能需要建设和维护50~100台服务器。即使在云上运行这些服务成本比较低，管理和监控这些机器的复杂度也是巨大的。</p><p><strong>注意</strong><br><strong>必须对微服务的灵活性和运行多台机器的成本（复杂性）进行权衡。</strong></p><h4 id="2-2-3-应用程序的类型"><a href="#2-2-3-应用程序的类型" class="headerlink" title="2.2.3 应用程序的类型"></a>2.2.3 应用程序的类型</h4><p>微服务的一个特点是<strong>提高可重用性</strong>，对构建需要高度弹性（resilient）和可伸缩性（scalable）的大型应用非常有用。这也是很多基于云的公司采用微服务架构的原因。如果构建一个小型的、部门级的应用或者只有很小的用户群</p><p>，构建分布式的模型（如微服务）将会成本太高，不值得。</p><h4 id="2-2-4-数据事务和一致性"><a href="#2-2-4-数据事务和一致性" class="headerlink" title="2.2.4 数据事务和一致性"></a>2.2.4 数据事务和一致性</h4><p>当你观察微服务时，你需要注意的是<strong>服务的数据使用模式</strong>和<strong>消费者如何使用它们</strong>。微服务包装并抽象出少量的表，作为执行“操作型”任务的机制，如针对存储的创建、增加和简单查询。</p><p>如果应用程序需要对多个数据源做一些复杂的数据聚合或者转换，微服务的分布式特点将会使这个过程变得很困难。你的微服务将会承担太多的职责，也很容易受性能问题的影响。</p><p>记住，在微服务间执行事务没有统一标准。如果需要事务处理，那就得自己构建这个逻辑。从第七章可以看到，微服务间可以通过消息进行通信，消息传递在更新过程中就带来了延迟。你的应用需要处理最终的<strong>一致性</strong>（数据的更新可能不会立即出现）。</p><h3 id="2-3-开发者故事：使用Spring-Boot和Java构建一个微服务"><a href="#2-3-开发者故事：使用Spring-Boot和Java构建一个微服务" class="headerlink" title="2.3 开发者故事：使用Spring Boot和Java构建一个微服务"></a>2.3 开发者故事：使用Spring Boot和Java构建一个微服务</h3><p>在本部分，我们将实现构建EagleEye应用的<strong>许可证（licensing）</strong>微服务。接下来几节将要：</p><ol><li>搭建微服务框架，构建应用程序的Maven脚本</li><li>实现一个Spring的启动类，用于启动装载微服务的容器并启动所有类的初始化工作</li><li>实现一个Spring Boot控制器类（controller）来映射服务请求的端点</li></ol><p>在本例中，实现了简单的get、put、post、delete方法，与HTTP动作对应。但是，目前只是简单实现了get，可以通过url中的变量来改变get到的结果。</p><p><strong> <em>@RestController</em>与<em>@Controller</em>的不同点：</strong></p><p><em>@RestController</em>实现了REST风格的controller，返回JSON类型的数据，并且不需要增加<em>@ResponseBody</em>的注解；</p><p><em>@Controller</em>只是返回一个普通的Response对象（当然要加上<em>@ResponseBody</em>注解），并且可以返回正确的jsp、html页面，由配置好的<strong>视图解析器（InternalResourceViewResolver）</strong>完成。</p><p><strong> <em>@RequestMapping</em>的level</strong></p><p>可以用来修饰<strong>类</strong>，也可以用来修饰<strong>方法</strong>。</p><p><strong>Endpoint命名很重要！</strong></p><p>Endpoint的名字就是每一个微服务的URL路径。命名时注意三点：</p><ol><li><strong>使用清晰的命名方式</strong>——尽量使命名一致且易读，能够一眼就看出来代表的什么资源</li><li>建立资源之间的关系——资源之间通常存在层级关系，如<code>spring-boot/docs/hello-world.html</code>。因此一个孩子不能单独地存在于父节点之外。若你的URL太长了（嵌套太多层），可能你的微服务需要重写（服务范围太大了）。</li><li><strong>在URL中标识版本号</strong>——URL代表了服务提供者和消费者之间的一种契约关系。最好将一个版本号放在所有端点前面。如<code>v1/organizations/e254f8c</code></li></ol><h3 id="2-4-开发者故事：构建运行时的严谨性"><a href="#2-4-开发者故事：构建运行时的严谨性" class="headerlink" title="2.4 开发者故事：构建运行时的严谨性"></a>2.4 开发者故事：构建运行时的严谨性</h3><p>从开发者的角度，要遵循四个原则：</p><ol><li>每个微服务应该自包含、可独立部署，并且在一个软件构件（artifact）中包含多个服务的实例（instances of service）</li><li>每个微服务应是可配置的。当服务启动时，它应该自动读取需要的配置数据（从central location或是从环境变量中），无需人工干预。</li><li>每个微服务实例应该对客户端是透明的。客户端不知道服务的确切位置（物理地址），客户端永远和代理（agent）打交道。</li><li>每个微服务可以报告它的health情况。这是云架构的关键部分。一旦某个实例无法正常运行，客户端需要被路由到正常的服务实例。</li></ol><p>从运维（DevOps）的角度，这四条原则可以映射到以下的运维生命周期：</p><ul><li>服务装配——怎样打包部署微服务来保证其可重复性与一致性，使得相同的服务代码和运行时环境以相同方式部署</li><li>服务引导/启动（bootstraping）——<strong>怎样将应用代码和与特定环境相关的配置代码分离</strong>，使得每次部署到新环境能够快速启动/发布，无需人工干预配置</li><li>服务注册/发现——当一个微服务实例被发布，怎样使其更容易被其他应用发现（discoverable）？</li><li>服务监控——微服务开发中，为了保证高可用性，通常一个服务有多个实例在运行。运维需要负责任何运行故障的监控与处理，并且将失效的服务拆卸掉。</li></ul><p><strong>构建12-factor微服务应用程序</strong></p><p>一个成功的微服务架构需要很多的开发与运维实践经验。有一个<strong>12因素应用宣言</strong>，所谓<strong>最佳实践（Best Practices）</strong>，原文可以在<a href="https://12factor.net" target="_blank" rel="noopener">https://12factor.net</a>找到，总结如下：</p><p><strong>代码库</strong>——所有应用代码和服务器供应信息都应处于版本控制中。每个微服务在版本控制系统中应该有独立的代码仓库。</p><p><strong>依赖</strong>——通过构建工具（如Maven）显式地（explicitly）声明依赖。第三发jar依赖应该明确其版本号。这样能够保证微服务始终用同样的版本库来构。</p><p><strong>配置</strong>——将配置代码和应用程序源代码分开。</p><p><strong>后端服务</strong>——微服务通过网络与数据库或消息系统进行通信。应该保证，任何时候都可以将本地管理的服务换成第三方服务。第10章，我们将从本地的Postgres数据库迁移到Amazon管理的数据库。</p><p><strong>构建、发布和运行</strong>——保持应用程序的构建、发布和运行过程分离。一旦代码构建完成，在运行时就不要再改动代码。一旦改动，就要重新构建发布。一个已构建服务是不可变的（immutable）。</p><p><strong>进程</strong>——微服务始终是无状态的。它们可以在任何时候被撤销和替换，不用担心服务实例的丢失会导致数据丢失。</p><p><strong>端口绑定</strong>——一个微服务在打包时是完全独立的，其中包含了运行时引擎。因此，运行微服务不需要额外的web或应用服务器，服务可以在命令行自启动，通过暴露的HTTP端口访问。</p><p><strong>并发</strong>——当你需要扩展（scale），不要依赖于单一服务的线程模型，而是创建更多服务实例来横向扩展。相对来说，单一服务的线程模型（scale up）量级不够大，多服务实例（scale out）更加易扩展。</p><p><strong>可处理性（disposability）</strong>——微服务是可以任意处置的，可以随时被启动和停止。应最小化启动时间，当被kill时应能够正常退出。</p><p><strong>开发/生产环境同等对待</strong>——减小服务在不同环境中运行的差异。开发者在本地开发时的基础设施（infrastructure）应与服务发布后运行时的相同 。这也意味着服务能够快速部署，代码被提交后，应该被测试，然后尽快从测试环境一直promote到生产环境。</p><p><strong>日志</strong>——日志是一个事件流。当日志被写出时，应该可以流式传输到<strong>Splunk</strong>或<strong>Fluentd</strong>这样的工具，通过校对整理将它们写到中央位置。微服务不需要关心这种情况发生的机制，开发者可以通过STDOUT查看日志。</p><p><strong>管理进程</strong>——开发人员经常需要对所写的服务进行管理工作（数据迁移、转换等）。应当用脚本来完成这些工作。脚本应该是可重复的，并且在每个运行的环境中是不可变的（不需要针对每个环境进行修改）。</p><h4 id="2-4-1-服务装配——打包部署你的微服务"><a href="#2-4-1-服务装配——打包部署你的微服务" class="headerlink" title="2.4.1 服务装配——打包部署你的微服务"></a>2.4.1 服务装配——打包部署你的微服务</h4><p>通常，基于Java的微服务框架都包含一个运行时引擎，如Spring Boot。可以从命令行运行，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package &amp;&amp; java -jar target/licensing-service-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>传统的J2EE开发中。应用是被部署到一个应用服务器上的。这样的应用只包含应用实体，需要被系统管理员团队根据不同的部署运行环境管理不同的配置。</p><p>这种做法——将应用服务器的配置和应用程序分离，在部署过程中引入了更多故障点（failure points），因为很多组织的应用服务器的配置不受源控制（source control），而是通过用户界面（UI）和本地管理脚本组合的方式来控制。这很容易在服务环境中发生configuration drift，并突然导致服务中断（outage）。</p><p>将运行时引擎嵌入应用的做法减少了配置漂移的可能性（因为统一位于源代码控制），这样也允许开发团队更好地思考他们的app是如何构建/部署的。</p><h4 id="2-4-2-服务引导：配置管理"><a href="#2-4-2-服务引导：配置管理" class="headerlink" title="2.4.2 服务引导：配置管理"></a>2.4.2 服务引导：配置管理</h4><p>当应用程序启动时，需要先从配置文件或者数据存储仓库（如数据库）读取配置数据，微服务也不例外。但是，对于成百上千的微服务实例，<strong>每当配置数据更新了后重新部署微服务似乎不太可行</strong>。</p><p>把配置数据存储在服务外部通常是个解决方法，但是基于云的微服务还需要考虑以下几点：</p><ol><li><strong>配置数据数据结构要简单，经常读取不常写入</strong>。最好不要用关系型数据库，因为关系型数据库的数据类型很复杂，大材小用。</li><li>数据定期访问，但是很少更改，因此<strong>读数据要做到低延迟</strong>。</li><li><strong>数据仓库应是高可用的</strong>，且靠近（地理上）需要读数据的服务。配置数据仓库不能完全关闭，否则会导致单点故障。</li></ol><h4 id="2-4-3-服务注册与发现：客户端如何与微服务通信"><a href="#2-4-3-服务注册与发现：客户端如何与微服务通信" class="headerlink" title="2.4.3 服务注册与发现：客户端如何与微服务通信"></a>2.4.3 服务注册与发现：客户端如何与微服务通信</h4><p>从微服务consumer的角度来看，一个微服务应当是地理位置透明的（不关心地理位置）。在基于云的环境中，服务器是短暂的（不固定的），不同于传统的位于企业数据中心的服务器。服务可以很快地启动/停止，被分配新的IP。</p><p>由于微服务的“短暂性”特征，它因此获得了高度的可扩展性、可用性以及灵活性。同时带来了一个问题——手工管理大量的短暂服务很容易造成运行中断（还话费大量人力）。</p><p>一个微服务，一个成熟的微服务（没错，<strong><em>你已经是个成熟的微服务了</em></strong>），应该会自己找到第三方代理并把自己注册上，这个过程也叫服务发现（service discovery）。</p><p>所谓的<strong>把自己注册到服务发现的代理</strong>，是指将两个东西告诉服务发现代理：</p><ol><li><strong>物理IP地址</strong>，或者服务实例的<strong>域名地址</strong>（domain address）</li><li>应用可以用来查看服务的<strong>逻辑名</strong></li></ol><p>某些服务发现代理还需要一个URL（注册代理的那个服务的），以便于代理进行健康检查（检查服务实例的运行情况）。然后，服务客户端就可以通过代理来查看服务的位置。</p><h4 id="2-4-4-报告微服务的健康状况"><a href="#2-4-4-报告微服务的健康状况" class="headerlink" title="2.4.4 报告微服务的健康状况"></a>2.4.4 报告微服务的健康状况</h4><p><strong>服务发现代理</strong>的任务不仅是像一个交通警察一样将客户端带到相应服务的位置，还要持续监视每一个微服务实例的运行情况，以确保客户端不会将请求发送到一个无效的服务实例上。</p><p>微服务开始运行后，服务发现代理会持续地监视并向<strong>健康检查接口（health check interface）</strong>发送ping报文，以确保服务可用。</p><p>通过构建一个一致的接口，可以使用基于云的监视工具来检测问题并反馈（如检测到异常后关闭服务等等）。</p><p>如果使用REST风格构建微服务，通常暴露一个HTTP端点，<strong>返回一个JSON类型的payload和HTTP状态码</strong>。如果没有使用类似Spring Boot的框架，则需要开发者自己手动实现端点；但是有了Spring Boot提供的<strong>开箱即用（out-of-the-box）的Spring Actuator</strong>组件，可以快速实现健康检查的接口。</p><p>在pom.xml中添加了依赖后，在地址栏输入<em><a href="http://localhost:8080/health" target="_blank" rel="noopener">http://localhost:8080/health</a></em>可以看到返回的健康数据。</p><h3 id="2-5-以上帝视角看问题"><a href="#2-5-以上帝视角看问题" class="headerlink" title="2.5 以上帝视角看问题"></a>2.5 以上帝视角看问题</h3><ol><li><strong>架构师</strong>——专注于业务问题的轮廓，分析出备选的微服务。记住，要从粗到细，一开始就把服务划分的过细不是个好习惯。</li><li><strong>软件工程师</strong>——尽管（每个）微服务很小，这并不意味着将良好的设计原则抛之脑后。服务中的每一层都有明确的职责。避免在代码中构建框架，尝试使每个微服务完全独立。不成熟的框架设计只会带来生命周期的后期巨大的维护代价。</li><li><strong>运维工程师</strong>——服务的存在需要介质，要尽早的建立服务的生命周期。运维不止要关注如何自动化构建和发布过程，更要关注如何监视服务的运行状况以及服务出现问题时怎么办。</li></ol><h2 id="3-使用Spring-Cloud配置服务器"><a href="#3-使用Spring-Cloud配置服务器" class="headerlink" title="3 使用Spring Cloud配置服务器"></a>3 使用Spring Cloud配置服务器</h2><p>开发人员需要注意的一点是，尽量把<strong>应用代码</strong>和<strong>配置信息</strong>分离开，即在应用程序中应不包含关于配置的任何信息。这样的一个好处是，由于应用代码部分没有关于配置的硬编码信息，每当配置发生了改变，<strong>不需要重新编译/部署</strong>。同时带来了一个问题，<strong>配置部分要作为一个单独的artifact进行管理和发布</strong>。</p><p>许多开发者会将配置信息放到低层级的属性（配置）文件（如YAML、JSON或XML）中。它放在服务器上，包含数据库或者中间件的连接信息，以及关于此应用的一些元数据（metadata）用来引导应用程序的行为。此种方式比较简单，大多数开发者也都是这么做的——将配置文件放到源代码控制，作为应用的一部分部署。</p><p>上述方法对于一些应用可行，但是对于基于云的应用（通常包含许多微服务，每个微服务还有很多实例，就不太行了。</p><p>对于配置管理，基于云的微服务开发强调：</p><ol><li><p>应用程序配置和被部署的代码完全分开</p></li><li><p>构建好服务器、应用以及一个永远不会改变的镜像</p></li><li>在服务启动时注入应用的配置信息，通过读取环境变量或者中心仓库的方式。</li></ol><h3 id="3-1-配置管理（复杂性）"><a href="#3-1-配置管理（复杂性）" class="headerlink" title="3.1 配置管理（复杂性）"></a>3.1 配置管理（复杂性）</h3><p>每当运维工程师需要手动配置或者改变服务时，都可能引起configuration drift、宕机或者延迟等问题，因此配置管理非常重要。配置管理的四个原则：</p><ol><li><strong>分离</strong>——服务的物理部署应与配置信息分离开。应用程序配置不应该与服务实例一同部署。配置信息应当在服务启动时作为环境变量传递给服务或者从中央仓库读取。</li><li><strong>抽象</strong>——将访问配置数据的功能抽象到一个服务接口中。应用程序使用基于REST的JSON服务来检索配置数据，而不是直接访问服务存储仓库（即通过文件或者使用JDBC从数据库读取数据）。</li><li><strong>中心化</strong>——基于云的应用程序可能有很多个服务，尽量减少保存配置信息的存储库。</li><li><strong>稳定</strong>——由于配置信息和实际代码完全隔离，要保证其高可用性和冗余性</li></ol><p>由于将配置信息置于实际代码之外，它将作为一个外部依赖，需要进行单独管理并进行版本控制。</p><p><strong>On accidental complexity</strong></p><h4 id="3-1-1-配置管理架构"><a href="#3-1-1-配置管理架构" class="headerlink" title="3.1.1 配置管理架构"></a>3.1.1 配置管理架构</h4><p>配置管理过程中，发生了以下重要的活动：</p><ol><li>当一个微服务实例启动时，它将会调用一个服务endpoint来<strong>读取它所在特定的环境的配置信息</strong>。服务启动后，用于配置管理的连接信息（连接credentials（证书/凭据）、服务端点等）将会传递进来。</li><li><strong>实际的配置存在于一个配置库（repository）中</strong>。可以使用不同的实现来保存配置数据。配置库的实现选择包括源代码控制下的文件、关系型数据库或是键值数据库。</li><li>应用程序的配置管理与应用程序的部署方式无关。<strong>配置管理的更改通常由构建/部署管道（build and deployment pipeline）来处理</strong>，配置的改变会被标记上版本信息并部署到不同环境中。</li><li>当配置管理发生了改变，<strong>使用这个配置信息的服务必须被通知（notify）</strong>并刷新应用程序数据的副本。</li></ol><h4 id="3-1-2-实现方式"><a href="#3-1-2-实现方式" class="headerlink" title="3.1.2 实现方式"></a>3.1.2 实现方式</h4><p>对比了一下常用的开源项目，最终选定<strong>Spring Cloud configuration server</strong></p><h3 id="3-2-构建Spring-Cloud配置服务器"><a href="#3-2-构建Spring-Cloud配置服务器" class="headerlink" title="3.2 构建Spring Cloud配置服务器"></a>3.2 构建Spring Cloud配置服务器</h3><p>本章我们要新建一个单独的目录——<strong>confsvr</strong>。在此目录下，需要新建一个pom.xml并把启动Spring Cloud配置服务器要用到的jar包添加上。</p><p>从pom.xml中可以发现描述Spring Boot的版本和Spring Cloud的版本并不相同。前者使用的是如<strong>1.4.4</strong>这样的版本号；后者使用的是一个叫<strong>release train</strong>的东西，版本号以伦敦地铁站名命名，如<strong>Angel，Brixton和Camden</strong>（很奇葩是不是？一个版本号都要搞这么多幺蛾子）。</p><h4 id="3-2-1-创建Spring-Cloud-Config启动类"><a href="#3-2-1-创建Spring-Cloud-Config启动类" class="headerlink" title="3.2.1 创建Spring Cloud Config启动类"></a>3.2.1 创建Spring Cloud Config启动类</h4><p>启动类中，多了一个<em>@EnableConfigServer</em>的注解，表明这是一个Spring Cloud Config的服务。</p><h4 id="3-2-2-通过文件系统使用配置服务器"><a href="#3-2-2-通过文件系统使用配置服务器" class="headerlink" title="3.2.2 通过文件系统使用配置服务器"></a>3.2.2 通过文件系统使用配置服务器</h4><p> 在<strong>application.yml</strong>文件中，可以通过<strong>文件系统</strong>或者<strong>基于云的Git提供商（如BitBucket或者GitHub）</strong>配置服务器。通过文件系统（本机）配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">   port: 8888</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: native</span><br><span class="line">  cloud:</span><br><span class="line">     config:</span><br><span class="line">       server:</span><br><span class="line">           native:</span><br><span class="line">              searchLocations: classpath:config/,classpath:config/licensingservice</span><br></pre></td></tr></table></figure><p><em>8888</em>指定了配置服务器运行的端口号；<em>native</em>说明了使用文件系统存储配置信息；<em>searchLocations</em>制定配置文件位置（使用相对路径）。</p><p>通过向配置服务器发送get请求：<em><a href="http://localhost:8888/licensingservice/default" target="_blank" rel="noopener">http://localhost:8888/licensingservice/default</a></em>，可以看到以JSON格式返回的位于licensingservice.yml中的配置信息。将URL最后的endpoint换成dev，则会得到dev和default两个配置。这是因为Spring Cloud实现了一个层级的读取配置的机制。它首先寻找default，然后若找到更高层级的，则会覆盖default中已有的，即如果在default和dev中同时设置了某个属性值，则使用dev中的；否则，使用default中的。</p><h3 id="3-3-将Spring-Cloud-Config集成到Spring-Cloud客户端"><a href="#3-3-将Spring-Cloud-Config集成到Spring-Cloud客户端" class="headerlink" title="3.3 将Spring Cloud Config集成到Spring Cloud客户端"></a>3.3 将Spring Cloud Config集成到Spring Cloud客户端</h3><p>上节只是将读取了硬编码的licensing service的配置，本节将通过与数据库交互来读取配置数据。</p><h4 id="3-3-1-建立依赖"><a href="#3-3-1-建立依赖" class="headerlink" title="3.3.1 建立依赖"></a>3.3.1 建立依赖</h4><p>依次添加<em>spring-boot-starter-data-jpa、postgresql、spring-cloud-config-client</em>依赖包，引入Spring Data Java持久层API、Postgres JDBC驱动。最后一个依赖包含了和Spring Cloud配置服务器交互用到的所有的类。</p><h4 id="3-3-2-配置许可证服务使用Spring-Cloud-Config"><a href="#3-3-2-配置许可证服务使用Spring-Cloud-Config" class="headerlink" title="3.3.2 配置许可证服务使用Spring Cloud Config"></a>3.3.2 配置许可证服务使用Spring Cloud Config</h4><p>添加完依赖，我们需要将写好的服务（licensing service）也做相关配置，以告诉我们的服务到哪去找配置（连接配置服务器）。对于Spring Cloud Config，配置信息可以放在以下两个文件中：<strong>bootstrap.yml和application.yml</strong>。（两个配置文件都在<em>src/main/resources</em>目录下）</p><p><em>bootstrap.yml</em>会读取应用的属性，且<strong>优先级最高</strong>。一般来说，其中包含了<strong>应用的名字、应用的profile（使用哪个配置profile）以及连接到配置服务器的URI</strong>。其它想设置的配置信息可以放在服务的外面——<em>application.yml</em>（而不是在配置服务器上）。通常，放在application.yml中的配置信息是你认为当配置服务器不可用时也能执行的。</p><p><em>bootstrap.yml</em>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: licensingservice</span><br><span class="line">  profiles:</span><br><span class="line">    active:</span><br><span class="line">      default</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      uri: http://localhost:8888</span><br></pre></td></tr></table></figure><p>其中，<em>spring.application.name</em>是应用的名字，并且必须与Spring Cloud配置服务器下的目录对应。如：若有一个服务<em>licensingservice</em>，则在配置服务器的<em>src/main/resources/config</em>下要有一个licensingservice的目录与之对应。</p><p><em>spring.profiles.active</em>指出Spring Boot要使用哪个profile来运行。每一个profile对应一份不同的配置。</p><p><em>spring.cloud.config.uri</em>指出服务应当从哪个endpoint寻找（连接）Spring Cloud配置服务器。默认使用端口8888。</p><h4 id="3-3-3-使用数据源"><a href="#3-3-3-使用数据源" class="headerlink" title="3.3.3 使用数据源"></a>3.3.3 使用数据源</h4><p>本项目使用的是Spring Data JPA（一个封装了JPA规范的框架），可以通过约定好的<strong>方法命名规则</strong>写dao接口，就可以在不写接口实现的情况下，还实现对数据库的访问。提供了出CRUD之外的功能，如分页、排序、复杂查询等。项目中LicenseRepository的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LicenseRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">License</span>,<span class="title">String</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">findByOrganizationId</span><span class="params">(String organizationId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> License <span class="title">findByOrganizationIdAndLicenseId</span><span class="params">(String organizationId,String licenseId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的命名规则形如 <em>findByXXId</em> 。通常，可以继承<strong>JpaRepository</strong>或<strong>CrudRepository</strong>。其中，JpaRepository继承自PagingAndSortingRepository，后者又继承自CrudRepository。顾名思义，Crud提供了CRUD的相关方法；PagingAndSorting提供了分页排序的方法；Jpa实现了一组Jpa规范的方法。</p><p><em>@Repository</em>注解表示这个接口作为一个repository，可以自动产生一个<strong>动态代理</strong>。</p><h4 id="3-3-4-使用-Value读取属性"><a href="#3-3-4-使用-Value读取属性" class="headerlink" title="3.3.4 使用@Value读取属性"></a>3.3.4 使用@Value读取属性</h4><p>配置类ServiceConfig类中，有一个<em>@Value</em>标记，它会自动<strong>把关于数据库的配置数据注入到数据库连接对象中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;example.property&#125;"</span>)</span><br><span class="line">  <span class="keyword">private</span> String exampleProperty;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getExampleProperty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exampleProperty;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过@Value注解，Spring会自动从Spring Cloud配置服务器寻找<em>example.property</em>属性，并把其值注入到ServiceConfig类中。</p><h4 id="3-3-5-通过Git使用Spring-Cloud配置服务器"><a href="#3-3-5-通过Git使用Spring-Cloud配置服务器" class="headerlink" title="3.3.5 通过Git使用Spring Cloud配置服务器"></a>3.3.5 通过Git使用Spring Cloud配置服务器</h4><p>使用Git来管理配置属性（property）的好处就是，你的所有配置属性的管理也在<strong>源控制（source control）</strong>下。每当你重新构建/部署应用时，配置也可以同步构建/部署。</p><p>要将Git作为我们的配置服务器的配置信息的存放地点，需要更改application.yml文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        encrypt.enabled: <span class="keyword">false</span></span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/carnellj/config-repo/</span></span><br><span class="line">          searchPaths: licensingservice,organizationservice</span><br><span class="line">          username: <span class="keyword">native</span>-cloud-apps</span><br><span class="line">          password: <span class="number">0f</span>fended</span><br></pre></td></tr></table></figure><p>如果用文件系统作为配置服务器，则server下为<strong>native，</strong>此处为git。<strong>searchPaths</strong>指明了配置文件所在的路径。</p><h4 id="3-3-6-刷新配置属性（property）"><a href="#3-3-6-刷新配置属性（property）" class="headerlink" title="3.3.6 刷新配置属性（property）"></a>3.3.6 刷新配置属性（property）</h4><p>当配置改变时，如何使应用使用最新的配置？</p><p>可以在应用的启动类前加上<strong>@RefreshSCope</strong>注解，它会重新加载你自己写的（额外的）属性配置文件，但不会刷新数据库的配置。可以输入<em>http://\&lt;yourserver>:8080/refresh</em>来执行刷新。</p><p><strong>关于刷新微服务</strong></p><p>Spring Cloud配置服务提供了一个<strong>基于push的机制——Spring Cloud Bus</strong>，每当检测到配置改变后会告诉所有使用这个服务的客户端。Spring Cloud配置需要一个额外的中间件——<strong>RabbitMQ</strong>。这是一个有效的办法，但并不是所有的Spring Cloud Configuration后端都支持这个机制（如Consul）。</p><p>下一章会介绍使用Spring服务发现和Eureka来注册一个服务的所有实例。作者常用的一个方法是，通过写脚本来查询服务发现引擎上某个服务的所有实例，然后立即调用<em>/refresh</em>端点。</p><p>或者，你可以重启服务器/容器来得到新的配置。如果使用Docker将会很方便。因为重启Docker只需要几秒钟，通过重启就可以重新读取配置数据。</p><h3 id="3-4-保护敏感配置信息"><a href="#3-4-保护敏感配置信息" class="headerlink" title="3.4 保护敏感配置信息"></a>3.4 保护敏感配置信息</h3><p>在配置文件中全部用纯文本（明文）来保存配置信息的做法不够安全，尤其是当其中含有一些敏感信息，如数据库凭据（credentials）。Spring Cloud Config允许你用<strong>对称（共享秘钥）或非对称（公钥、私钥）方式</strong>对敏感信息加密。</p><p>我们将看看如何搭建Spring Cloud配置服务器以使用对称秘钥的加密。步骤如下：</p><ol><li>下载安装Oracle JCE</li><li>创建加密秘钥</li><li>加密和解密属性</li><li>配置微服务以在客户端使用加密</li></ol><h4 id="3-4-1-下载安装Oracle-JCE依赖包"><a href="#3-4-1-下载安装Oracle-JCE依赖包" class="headerlink" title="3.4.1 下载安装Oracle JCE依赖包"></a>3.4.1 下载安装Oracle JCE依赖包</h4><p>在官网下载好后，定位到文件资源管理器的<strong>$JAVA_HOME/jre/lib/security</strong>目录，将下载好的压缩文件解压，替换对应的<em>local_policy.jar</em>和<em>US_export_policy.jar</em>文件，若害怕丢失可以先备份一下。</p><h4 id="3-4-2-创建一个秘钥"><a href="#3-4-2-创建一个秘钥" class="headerlink" title="3.4.2 创建一个秘钥"></a>3.4.2 创建一个秘钥</h4><p>在配置服务器上设置秘钥，可以在bootstrap.yml或者application.yml里。设置<strong>encrypt.key: IMSYMMETRIC</strong>。秘钥可以随便设置，但是有两点注意：</p><ol><li>秘钥应为12个字符及以上，最好是随机序列的字符</li><li>保管好你的秘钥，解密时必须用加密时用的秘钥</li></ol><h4 id="3-4-3-加密-解密（property）"><a href="#3-4-3-加密-解密（property）" class="headerlink" title="3.4.3 加密/解密（property）"></a>3.4.3 加密/解密（property）</h4><p>现在我们可以对我们希望加密的属性进行加密了。</p><p>通过向配置服务器发送POST请求：<em><a href="http://localhost:8888/encrypt" target="_blank" rel="noopener">http://localhost:8888/encrypt</a></em>，将要加密的对象放在request body中，发送POST请求就能得到加密后的结果。同理，发送/decrypt请求，就能将已加密对象解密。</p><p>我们可以将配置文件中的密码替换为我们加密完的结果。</p><p>看起来不错！但是仍然存在问题：我们还是能通过GET请求看到密码的明文！向<em><a href="http://localhost:8888/licensingservice/default" target="_blank" rel="noopener">http://localhost:8888/licensingservice/default</a></em>发送请求，可以看到密码不在原来的位置了（偷偷跑到JSON数据末尾了…）。原因就是，虽然已经将property加密，但是配置服务器会自动将其解密，因此，我们需要将其在客户端解密（客户端在服务端fetch到配置数据，然后将其在客户端解密）。</p><h4 id="3-4-4-配置微服务-在客户端解密"><a href="#3-4-4-配置微服务-在客户端解密" class="headerlink" title="3.4.4 配置微服务-在客户端解密"></a>3.4.4 配置微服务-在客户端解密</h4><ol><li>在服务端配置Spring Cloud Config不要解密</li><li>在微服务端（licensing server）设置对称秘钥</li><li>微服务端引入<em>spring-security-rsa</em>依赖</li></ol><p>第一步，在配置服务器的application.yml上配置<strong>spring.cloud.config.server.encrypt.enables: false</strong>。</p><p>第二步，在微服务的bootstrap.yml中添加与配置服务器上相同的对称秘钥：<strong>encrypt.key: IMSYMMETRIC</strong>。</p><p>第三步，添加依赖。</p><p>现在访问<em><a href="http://localhost:8888/licensingservice/default" target="_blank" rel="noopener">http://localhost:8888/licensingservice/default</a></em>，发现密码已经是加密过的了。</p><h3 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h3><ul><li><p>Spring Cloud配置服务器让你可以为不同的环境创建不同的配置</p></li><li><p>Spring使用<strong>profiles</strong>来自动根据不同环境决定使用什么配置</p></li><li><p>Spring Cloud配置服务可以使用基于文件/Git的应用来存储应用属性</p></li><li><p>Spring CLoud配置服务可以使用对称/非对称加密保护你的关键数据</p></li></ul><h2 id="4-发现服务"><a href="#4-发现服务" class="headerlink" title="4 发现服务"></a>4 发现服务</h2><p>在分布式架构中，我们需要发现一台机器的物理地址。这个概念随着云计算的出现而出现——服务发现。服务发现可以简单到只用一个配置文件来维护应用程序用到的所有远程地址（服务器），也可以复杂到诸如使用UDDI（Universal Description，Discovery，and Integration）仓库。</p><p>服务发现之所以对微服务和基于云的应用这么重要，原因有两个：</p><p><strong>第一，有利于应用的快速横向扩展/收缩（scale up/down）</strong>。服务消费者通过服务发现将服务的物理地址抽象出来了，由于消费者不知道服务的具体地址，因此可以从服务池（pool）中任意添加/移除新的服务实例。</p><p>这也改变了应用架构升级的方式——<strong>由升级硬件（垂直扩展）到增加服务器（横向扩展）</strong>。</p><p><strong>第二，增加了应用的弹性（灵活性）</strong>。当服务出现异常（不可用时），服务发现引擎能够快速将它从服务可用列表上移除并寻找可用的服务。应用failure导致的影响被降到了最低。</p><h3 id="4-1-我的服务在哪呢？"><a href="#4-1-我的服务在哪呢？" class="headerlink" title="4.1 我的服务在哪呢？"></a>4.1 我的服务在哪呢？</h3><p>当你的应用调用位于多台服务器上的资源时，就需要定位这些资源的物理位置。在普通应用（非云架构）中，通常使用<strong>DNS+负载均衡器（load balancer）</strong>的解决方式。</p><p>应用需要调用其他服务时，通过一个DNS名称以及服务所在路径来调用该服务。DNS名称会被解析到一个商用的负载均衡器（硬件，如F5）或者开源的负载均衡器（如HAProxy）。</p><p>负载均衡器负责接收请求，检查路由表中托管该服务的服务器，并选择一个服务器，将请求转发（forward）给它。每个服务的实例被部署到一个或多个服务器上，这些服务器的数量是<strong>固定的（static）</strong>，当其中某个服务器挂了（crash），它会被恢复到挂掉之前的状态（与之前有相同的IP和配置）。</p><p>为了实现高可用，通常在负载均衡器的基础上再设置一个<strong>二级负载均衡器</strong>，当负载均衡器挂掉，它会取代他的位置。</p><p>上述模型对于一些在固定的服务器上运行的小型应用是可行的，但是对于基于云的微服务应用就不太行了，因为：</p><ul><li><strong>单点故障</strong>——如果负载均衡器挂了，整个应用就完了！尽管你可以将load balancer做成高可用的（尽管你可以设置二级、三级…），但是负载均衡器往往是应用程序基础设施的集中式阻塞点（centralized checkpoints）。</li><li><p><strong>有限的横向扩展能力</strong>——在服务集中到单个负载均衡器集群的条件下，将负载均衡的基础设施扩展到多台服务器上的能力是有限的。许多商用的负载均衡器被两个因素所限制：<strong>冗余模型和许可证成本</strong>。首先，许多采用<strong>热插拔模型</strong>，即同一时刻最多有一个负载均衡器在运行。二级负载均衡器只是用来在主负载均衡器失效时才起作用。这样做实际上是被硬件限制了（只能无限提升一台负载均衡器的性能，因为不能多台同时工作）；其次，商用负载均衡器具有有限数量的许可证，<strong>它面向固定容量模型而不是可变容量模型</strong>。</p></li><li><p><strong>静态管理</strong>——大多数负载均衡器并没有快速注册/注销服务的能力。它们使用集中式数据库来存储路由规则，添加新的路由规则也只能通过供应商提供的私有API来实现。</p></li><li><strong>复杂</strong>——负载均衡器相当于微服务的代理，消费者的请求需要被映射到物理服务。这就需要定义和部署服务的映射规则（手动）。在传统方案中，新服务实例的注册是手动完成的，并不是在服务启动后立即完成。</li></ul><p>这四个原因并不是对负载均衡器的刻意指摘。负载均衡器在企业级环境中工作良好，大多数应用可以通过集中式网络基础设施来处理。此外，负载均衡器仍然可以在集中化SSL终端和管理服务端口安全方面发挥作用。负载均衡器可以锁定位于它后面的所有服务器的入站（入口）端口和出站（出口）端口访问。在满足行业要求方面，如PCI（Payment Card Industry），它仍是一个关键组成部分。</p><p>然而，在基于云的世界，你需要处理很多的<strong>事务</strong>和<strong>冗余</strong>。中心化的网络结构通常不能胜任。</p><h3 id="4-2-云中的服务发现"><a href="#4-2-云中的服务发现" class="headerlink" title="4.2 云中的服务发现"></a>4.2 云中的服务发现</h3><p><strong>服务发现</strong>机制具有以下特点：</p><ul><li><strong>高可用</strong>——服务发现支持热集群环境，在服务发现集群可以跨多个节点实现共享查找。一个节点不可用时，其他节点可以take over。</li><li><strong>P2P</strong>——点对点。每一个节点地位平等，共享服务实例的状态。</li><li><strong>负载均衡</strong>——确保将服务请求合理地分配给不同正在工作状态的服务实例。</li><li><strong>弹性/灵活性</strong>——服务发现客户端应该能够在<strong>本地缓存服务信息</strong>。本地缓存的意义在于，一旦服务发现引擎不可用，应用仍然能够function。</li><li><strong>容错性</strong>——服务发现需要检测服务实例的健康状态，并对其采取措施。</li></ul><h4 id="4-2-1-服务发现架构"><a href="#4-2-1-服务发现架构" class="headerlink" title="4.2.1 服务发现架构"></a>4.2.1 服务发现架构</h4><p>怎么实现一个服务发现系统？一般包含以下四个部分：</p><ul><li><strong>服务注册</strong>——怎样将一个服务注册到服务发现代理？</li><li><strong>客户端查找</strong>——客户端查找服务信息（地址）的方式是什么？</li><li><strong>信息共享</strong>——节点之间如何共享服务信息？</li><li><strong>健康监测</strong>——服务们（services）如何将自己的健康状况报告给服务发现代理？</li></ul><p>除了依赖<strong>服务发现服务/引擎(service discovery services)</strong>来寻找服务外，客户端也可以通过缓存的方式进行负载均衡。</p><h4 id="4-2-2-使用Spring和Netflix-Eureka进行服务发现实战"><a href="#4-2-2-使用Spring和Netflix-Eureka进行服务发现实战" class="headerlink" title="4.2.2 使用Spring和Netflix Eureka进行服务发现实战"></a>4.2.2 使用Spring和Netflix Eureka进行服务发现实战</h4><p>在下面的例子中，我们将许可证（license）服务中包含的组织（organization）相关信息抽出来，放到许可证服务中。<strong>当许可证服务被调用时，它将调用组织服务以检索与指定的组织ID相关联的组织信息</strong>。组织服务的位置的实际解析存储在服务发现注册表中。</p><p><img src="/passages/SPMIA/client-load-balance.png" alt="client-load-balance"></p><h3 id="4-3-构建Spring-Eureka服务"><a href="#4-3-构建Spring-Eureka服务" class="headerlink" title="4.3 构建Spring Eureka服务"></a>4.3 构建Spring Eureka服务</h3><p>类似于构建配置服务器（Spring Cloud Config Server）</p><p>首先，添加maven依赖：<em>spring-cloud-starter-eureka-server</em>（使用Eureka库，包含Ribbon）。然后在application.yml中添加配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">  server:</span><br><span class="line">    waitTimeInMsWhenSyncEmpty: 5</span><br><span class="line">  serviceUrl:</span><br><span class="line">    defaultZone: http://localhost:8761</span><br></pre></td></tr></table></figure><p>设置Eureka服务器在8761（默认）端口监听；<strong>registerWithEureka</strong>设为空是因为，Eureka是个用于服务发现的服务器，可以让其它服务到自己这来注册，这个值是为需要通过Eureka注册自己的服务的组件提供的，所以设为false；<strong>fetchRegistry</strong>设为false是指，不要在本地缓存注册信息，因为这个也是给调用Eureka服务的客户端使用的（从路径也可以看出：*eureka.client.**；<strong>waitTimeInMsWhenSyncEmpty</strong>是指Eureka服务器启动后不会立即宣传已注册的服务，它将等待5分钟，以便所有的服务都注册完成，在本地测试时可以注释掉这行，加快测试过程；单个服务注册Eureka需要最多30s，因为Eureka需要收到来自服务的连续三次心跳ping，每次10s。</p><p>最后，在Eureka的启动类中，添加<strong>@EnableEurekaServer</strong>注解，表示启动服务器。</p><h3 id="4-4-使用Spring-Eureka注册服务"><a href="#4-4-使用Spring-Eureka注册服务" class="headerlink" title="4.4 使用Spring Eureka注册服务"></a>4.4 使用Spring Eureka注册服务</h3><p>启动了Eureka服务，之后就需要将服务注册到Eureka服务器。</p><p>首先，添加依赖：<em>spring-cloud-starter-eureka</em>。</p><p>然后，修改需要注册到Eureka的服务的配置文件application.yml。在bootstrap.yml中配置的<em>spring.application.name</em>就作为服务的ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    preferIpAddress: true</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: true</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><p><em>eureka.instace.preferIpAddress</em>为true是指用IP来注册服务而不是主机名；registerWithEureka和fetchRegistry都为true，因为这是要注册到Eureka的服务，且开启客户端缓存（每30s，客户端会重新与Eureka通信检查是否需要修改注册服务表）；<strong>serviceUrl</strong>：客户端通过这个地址定位已注册的服务，Eureka的高可用性就是通过这个做到的。可同时配置多个地址（用逗号隔开），当某些服务不可用时，可用服务节点之间会相互通信，保证被路由到合适的服务。</p><p>本次注册的是organizationservice，所以配置好后，启动应用，访问<em><a href="http://localhost:8761/eureka/apps/\" target="_blank" rel="noopener">http://localhost:8761/eureka/apps/\</a>&lt;APPID></em>就可以看到已注册的服务的信息。返回的服务状态信息默认是xml格式的，也可以以JSON格式输出（将请求方式改为POST，并把请求头的<strong>Accept</strong>值设为<em>application/json</em>）。</p><h3 id="4-5-使用服务发现来查找服务"><a href="#4-5-使用服务发现来查找服务" class="headerlink" title="4.5 使用服务发现来查找服务"></a>4.5 使用服务发现来查找服务</h3><p>服务注册完了后，可以进行调用了。我们使用licensingservice来调用organizationservice，调用时不需要知道organizationservice的地址，使用Netflix客户端，服务消费者可以和<strong>Ribbon</strong>交互。从低到高层次（越高封装越多）的和Ribbon交互的客户端有：</p><ul><li>Spring Discovery client</li><li>Spring Discovery client enabled RestTemplate</li><li>Netflix Feign client</li></ul><h4 id="4-5-1-使用Spring-DiscoverClient查找服务实例"><a href="#4-5-1-使用Spring-DiscoverClient查找服务实例" class="headerlink" title="4.5.1 使用Spring DiscoverClient查找服务实例"></a>4.5.1 使用Spring DiscoverClient查找服务实例</h4><p><strong>DiscoveryClient与实际运用</strong>                                                                          </p><h4 id="4-5-2-使用Spring-RestTemplate（Ribbon-aware）调用服务"><a href="#4-5-2-使用Spring-RestTemplate（Ribbon-aware）调用服务" class="headerlink" title="4.5.2 使用Spring RestTemplate（Ribbon-aware）调用服务"></a>4.5.2 使用Spring RestTemplate（Ribbon-aware）调用服务</h4><h4 id="4-5-3-使用Netflix-Feign客户端调用服务"><a href="#4-5-3-使用Netflix-Feign客户端调用服务" class="headerlink" title="4.5.3 使用Netflix Feign客户端调用服务"></a>4.5.3 使用Netflix Feign客户端调用服务</h4><h2 id="5-构建客户端弹性模型——Netflix-Hystrix"><a href="#5-构建客户端弹性模型——Netflix-Hystrix" class="headerlink" title="5 构建客户端弹性模型——Netflix Hystrix"></a>5 构建客户端弹性模型——Netflix Hystrix</h2><p>在基于云的环境中，<strong>检测出系统组件crash</strong>比较容易，<strong>检测出组件running slow</strong>却很难，因为：</p><ul><li><strong>服务可能一点一点变坏</strong>——服务的崩溃可能由很小的征兆开始，即服务不是一下子就崩溃的。可能开始是一些用户发现了一点问题，直到某一刻突然线程池被耗尽并彻底崩溃。</li><li><strong>对远程服务的调用通常是同步的，不会缩短调用时间</strong>——服务的调用没有超时的概念，开发人员调用服务并等待服务返回（一直）。</li><li><strong>应用更擅长处理远程资源的彻底故障，而不是部分退化（degradation）</strong>——只要没有彻底崩溃，应用会一直调用尽管运行情况很糟糕的服务，直到资源耗尽。</li></ul><h3 id="5-1-什么是客户端弹性模型？"><a href="#5-1-什么是客户端弹性模型？" class="headerlink" title="5.1 什么是客户端弹性模型？"></a>5.1 什么是客户端弹性模型？</h3><p>客户端弹性模型的目的就是使客户端<strong>fail fast</strong>。包括：</p><ol><li>客户端负载均衡模式</li><li>断路器（circuit breaker）模式</li><li>后备（fallback）模式</li><li>舱壁（bulkhead）模式</li></ol><p>四个模式之间的配合如下图：</p><p><img src="/passages/SPMIA/client-resiliency.png" alt="client-resiliency"></p><h4 id="5-1-1-客户端负载均衡"><a href="#5-1-1-客户端负载均衡" class="headerlink" title="5.1.1 客户端负载均衡"></a>5.1.1 客户端负载均衡</h4><p>客户端负载均衡要做的事情就是，客户端从服务发现代理（如Netflix Eureka）那里查找服务实例的时候，会将实例的物理地址缓存下来。当服务的消费者（consumer）需要调用服务实例时，<strong>客户端load balancer</strong>将会从自己维护的一个地址池<strong>（service locations pool）</strong>中返回一个地址。</p><p>客户端负载均衡器是存在于服务客户端和服务消费者之间的，它可以检测服务实例的运行情况。监测到问题后，可以将对应的服务实例从可用服务地址池中移出，阻止对那个服务实例的调用。</p><p>这就是<strong>Netflix Ribbon</strong>库所做的，开箱即用。</p><h4 id="5-1-2-断路器模式"><a href="#5-1-2-断路器模式" class="headerlink" title="5.1.2 断路器模式"></a>5.1.2 断路器模式</h4><p>断路器模式是模仿电路断路器的工作方式。电路系统中，断路器如果监测到电路中电流过大，会断路，以防止下游部件被烧毁 。</p><p>类比过来，软件断路器的作用就是，若调用某个远程服务花费时间过长，断路器就会介入并中断调用。断路器将监视所有对远程资源的调用，如果调用失败次数足够多，断路器就会启动。</p><h4 id="5-1-3-后备模式"><a href="#5-1-3-后备模式" class="headerlink" title="5.1.3 后备模式"></a>5.1.3 后备模式</h4><p>通过后备模式，当服务失败时，不是立马抛出异常，而是尝试换一个路径执行。这通常涉及从另一个数据源查找数据、将请求排队等待后续处理等。</p><p>比如，你的电子商务网站需要监控用户行为并据此做出推荐。通常你可以调用微服务来分析该用户的历史购买行为（记录），并据此做出分析。如果此微服务失败了，那么后备处理可能就是查询“所有”用户的购买记录并分析，这些数据可能来自一个完全不同的服务和数据源。</p><h4 id="5-1-4-舱壁模式"><a href="#5-1-4-舱壁模式" class="headerlink" title="5.1.4 舱壁模式"></a>5.1.4 舱壁模式</h4><p>舱壁模式基于一个概念——在造船的时候，船舱的设计可以将每个隔间的“危险情况”隔离在内部。当船身破裂，每个船舱还是可以保护行人的（？？？那Titanic是怎么回事？每个船舱都挂了吗）</p><p>同样的概念运用到微服务就是当一个服务要和多个远程资源交互时，使用舱壁模式，你可以<strong>将对不同远程资源的调用分离到不同的线程池</strong>，来降低风险。某个服务响应速度变慢，处理同类型服务调用的线程池将变得饱和，不再接收请求。</p><h3 id="5-2-为什么客户端弹性很重要？"><a href="#5-2-为什么客户端弹性很重要？" class="headerlink" title="5.2 为什么客户端弹性很重要？"></a>5.2 为什么客户端弹性很重要？</h3><p>简而言之，就是当A服务调用B服务，B服务又调用C服务…很多个服务调用形成了一条链，一旦被很多服务调用的“源头”出现问题，就可能会导致后面很多服务的崩溃。</p><p>当服务B发现服务C响应缓慢时，断路器会设置一个timer来检测请求被处理的时间，若计时器超时后服务B还没有得到响应，就会收到一个error，并且断路器开始记录error的个数；如果一段时间内error次数过多，所有调用服务C的请求都会直接被拒绝（强行fail）。</p><p>当被断路器强行插手解决问题时，有三个好处：</p><ol><li>B服务知道前方有问题了，不需要再等断路器的超时通知了</li><li>B服务可以决定自己<strong>是fail还是另寻出路（后备模式）</strong></li><li>给了服务C一点时间和空间去恢复自己</li></ol><p>断路器的存在使得远程调用可以：</p><ol><li><strong>Fail fast</strong>——防止事情进一步恶化</li><li><strong>Fail gracefully</strong>——断路器使得应用开发者们可以在意外发生时另寻他法，如从其他数据源检索数据</li><li><strong>Recover seamlessly</strong>——断路器可以负责查询资源是否可用，服务是否恢复，并开发访问接口</li></ol><h3 id="5-3-使用Hystrix"><a href="#5-3-使用Hystrix" class="headerlink" title="5.3 使用Hystrix"></a>5.3 使用Hystrix</h3><p>构建和实现断路器模式、后备模式和舱壁模式，需要对线程和线程管理有很深的理解。Netflix的Hystrix库在微服务架构中久经考验，你可以使用它构建强大的客户端弹性模型。需要做的包括：</p><ul><li>在licensingservice的pom.xml中添加Spring Cloud/Hystrix依赖。</li><li>使用Spring Cloud/Hystrix标记（annotations）来将远程调用包装成断路器模式。</li><li>为每一个<strong>远程资源-断路器</strong>定制超时时间。可以设定一个断路器强行接管控制之前，failure的次数。</li><li>为服务设计后备模式策略（fallback strategy），以在断路器生效时起作用。</li><li>为每个远程调用设立单独的线程池，并使用舱壁模式将不同的远程资源隔离开，</li></ul><h3 id="5-4-配置licensing服务器"><a href="#5-4-配置licensing服务器" class="headerlink" title="5.4 配置licensing服务器"></a>5.4 配置licensing服务器</h3><p>在licensingservice的pom.xml中添加<strong>spring-cloud-starter-hystrix</strong>和<strong>hystrix-javanica</strong>，并制定hystrix-javanica的版本为1.5.9。实际上，spring-cloud-starter-hystrix中以及包含了hystrix-javanica，但是<strong>Cmamden.SR5</strong>版本的Spring Cloud包含的是1.5.6的hystrix-javanica，其中的一个问题是：如果Hystrix代码没有后备，会跑出一个<em>java.lang.reflect.UndeclaredThrowableException</em>异常而不是<em>com.netflix.<br>hystrix.exception.HystrixRuntimeException</em>，于是单独声明一下后者的版本，从maven拉取一个不同版本的包。</p><p>然后在需要使用断路器模式的服务的启动类上加上注解<strong>@EnableCircutBreaker</strong>就行了。</p><h3 id="5-5-使用Hystrix实现一个断路器"><a href="#5-5-使用Hystrix实现一个断路器" class="headerlink" title="5.5 使用Hystrix实现一个断路器"></a>5.5 使用Hystrix实现一个断路器</h3><p>我们将看到两大类的Hystrix实现：<strong>对数据库的调用</strong>和<strong>内部服务调用</strong>。如图：</p><p><img src="/passages/SPMIA/hystrix-two-cases.png" alt="hystrix-two-cases"></p><p>两种类型调用中，Hystrix的使用是类似的。</p><p>首先，看一下如何使用一个同步的Hystrix断路器来控制从licensing数据库检索licensing服务的数据。通过同步方式调用，许可证服务将会检索数据，同时它会等到SQL语句执行完成，或者断路器提示超时。</p><p>通过添加<em>@HystrixCommand</em>注解，方法被标记为一个Hystrix断路器，Spring框架会为其生成一个动态代理，将所有调用此方法的请求放到一个线程池中处理。尽管看起来没有写多少代码，但是可以实现很多功能。断路器会中断任何超过1000ms的调用。</p><p>因为我是在本地启动的数据库，所以如果数据库没问题，可能断路器一直不需要工作。因此，在方法中加入一些【人工延迟】，来模拟响应缓慢的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">randomlyRunLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> randomNum = rand.nextInt((<span class="number">3</span> - <span class="number">1</span>) + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (randomNum==<span class="number">3</span>) sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个随机数（取值【0|1|2】+1），当值为3时，线程休眠11000ms。sleep()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">11000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在访问<a href="http://localhost:8082/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a/licenses/，多刷新几次，会发现出现了超时错误，这就说明我们的断路器起作用了，由于数据库操作超时导致抛出了*com.netflix" target="_blank" rel="noopener">http://localhost:8082/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a/licenses/，多刷新几次，会发现出现了超时错误，这就说明我们的断路器起作用了，由于数据库操作超时导致抛出了*com.netflix</a>.<br>hystrix.exception.HystrixRuntimeException*异常。</p><p><img src="/passages/SPMIA/HystrixRuntimeException.png" alt="HystrixRuntimeException"></p><h4 id="5-5-1-对organizationservice的调用超时"><a href="#5-5-1-对organizationservice的调用超时" class="headerlink" title="5.5.1 对organizationservice的调用超时"></a>5.5.1 对organizationservice的调用超时</h4><p>使用方法级的标记（断路器）的好处就是，它不区分你是在访问数据库还是调用另一个微服务。</p><p><strong>注意</strong></p><p>使用<em>@HystrixCommand</em>标记尽管很容易，但是使用默认的标记可能有问题。因为默认的标记会将所有的远程调用放到同一个线程池中，下面的章节实现了舱壁模式，其中自定义了<em>@HystrixCommand</em>标记的一些参数。</p><h4 id="5-5-2-定制断路器的超时时间"><a href="#5-5-2-定制断路器的超时时间" class="headerlink" title="5.5.2 定制断路器的超时时间"></a>5.5.2 定制断路器的超时时间</h4><p>定制断路器的超时时间，只需要在<em>@HystrixCommand</em>标记上增加对应的参数<strong>timeoutInMilliseconds</strong>即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(commandProperties= &#123;<span class="meta">@HystrixProperty</span>(</span><br><span class="line">               name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value=<span class="string">"12000"</span>)&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">getLicensesByOrg</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">randomlyRunLong();</span><br><span class="line"><span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commandProperties中可以添加很多@HystrixProperty，每一个属性由一个name和一个value构成。</p><p>类似commandProperties，也可以设置threadPoolProterties的参数。</p><p><strong>关于服务超时</strong></p><blockquote><p>显然，12s的断路器超时只是我用来作为教学的例子。在分布式环境中，如果我听到开发团队反馈，说远程服务调用上的1s超时时间太少了，因为他们的服务平均需要5-6s的时间，那么我会经常感到紧张。</p><p>这些反馈通常告诉我，被调用的服务存在为解决的性能问题。开发人员应该避免在Hystrix调用上增加默认超时时间的诱惑，除非实在无法解决运行缓慢的服务调用。</p><p><strong>如果确实遇到一些比其他服务调用需要更长时间的服务调用，务必将这些服务调用隔离到单独的线程池中。</strong></p></blockquote><h3 id="5-6-后备处理（fallback）"><a href="#5-6-后备处理（fallback）" class="headerlink" title="5.6 后备处理（fallback）"></a>5.6 后备处理（fallback）</h3><p>断路器模式的【美妙之处】在于，<em>中间商是可以赚差价的</em></p><p>嗯？？其实就是，远程资源的消费者和其本身之间存在一个中介，每当有请求，中介会拦截下来，为你选择最安全、效率最高的服务；当出现异常情况，中介也可以选择一个备用方法来执行（前提是你写了备用方法，因为它只有使用fallback的机制，但没有创造fallback的机制）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod = <span class="string">"buildFallbackLicenseList"</span>)</span><br><span class="line">public List&lt;License&gt; getLicensesByOrg(<span class="built_in">String</span> organizationId) &#123;</span><br><span class="line">randomlyRunLong();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private List&lt;License&gt; buildFallbackLicenseList(<span class="built_in">String</span> organizationId) &#123;</span><br><span class="line">List&lt;License&gt; fallbackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">License license = <span class="keyword">new</span> License()</span><br><span class="line">.withId(<span class="string">"0000000-00-00000"</span>)</span><br><span class="line">.withOrganizationId(organizationId)</span><br><span class="line">.withProductName(<span class="string">"Sorry no licensing information currently available"</span>);</span><br><span class="line"></span><br><span class="line">    fallbackList.add(license);</span><br><span class="line"><span class="keyword">return</span> fallbackList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“正常工作”的方法上添加HystrixCommand标记，并设置其fallbackMethod，并在下方写上fallback方法实现，且两个方法的返回值和参数需相同。当服务无法正常工作时，会调用fallback方法处理。</p><p>现在，连续调用几次licensingservice服务，请求超时时会由fallback方法处理：</p><p><img src="/passages/SPMIA/fallbackMethod.png" alt="fallbackMethod"></p><h3 id="5-7-实现舱壁模式"><a href="#5-7-实现舱壁模式" class="headerlink" title="5.7 实现舱壁模式"></a>5.7 实现舱壁模式</h3><p>在@HystrixCommand标记中添加参数：<em>threadPoolKey、threadPoolProperties</em></p><p>threadPoolKey是说为指定的方法建立一个新的Hystrix线程池来处理。</p><p>threadPoolProperties可以配置两个参数，<code>name=&quot;coreSize&quot;, value=&quot;30&quot;</code>指定线程池大小；<code>name=&quot;maxQueueSize&quot;, value=&quot;10&quot;</code>指定队列中线程数量，即当线程池满时可以排队等待的请求数量；</p><h3 id="5-8-基础进阶——微调Hystrix"><a href="#5-8-基础进阶——微调Hystrix" class="headerlink" title="5.8 基础进阶——微调Hystrix"></a>5.8 基础进阶——微调Hystrix</h3><p>至此，我们已经学会了如何使用Hystrix实现断路器和舱壁模式。接下来我们要对断路器的行为进行定制化微调（customize）（通过修改参数，使Hystrix的工作模式更符合我们的实际情况）。记住，<strong>Hystrix能做的不只是将长时间的远程调用设为超时，Hystrix还可以监控调用失败的次数</strong>。当一个服务调用失败次数过多，Hystrix会自动阻止来自远程的调用（即请求无法到达远程资源）。</p><p>这样做<strong>（failing fast）</strong>有两个好处：<strong>1. 客户端不会一直调用并等待超时信号发出；2. 服务端不会很快挂掉，有一个恢复时间</strong>。</p><p>每当一个Hystrix命令遇到服务错误时，它会启动一个10s的计时器，来检查服务失败的频率。10s的窗口大小是可配置的。首先Hystrix会检查10s内发生了几次调用，<strong>如果调用次数少于窗口内可以发生调用次数的最小值，那么及时这些调用全部失败，Hystrix也不会fail fast</strong>（自动阻止来自远程的调用）。例如，10s内Hystrix会执行fail fast的默认调用次数为20，那么如果10s内有15个调用都失败了，Hystrix不会启动fail fast，调用仍会到达远程服务。</p><p>如果远程调用的失败次数在10s内达到最小值后，Hystrix将会查看整体故障的百分比。如果比例超过了阈值（默认50%），Hystrix将对所有远程调用触发断路器并让其失效。<strong>同时，它会在此过程中，不断试探故障是否恢复，通过<u>定时开闸</u>的方式。</strong>即，它会开启一个新的活动窗口，每5s它会让一个请求通过，如果请求成功，则Hystrix会重置断路器，放开请求通道；否则，过5s继续尝试。</p><p>因此，我们可以通过以下参数来控制我们的断路器工作效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(commandProperties = &#123;</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span>, value = <span class="string">"75"</span>),</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>, value = <span class="string">"7000"</span>),</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"metrics.rollingStats.timeInMilliseconds"</span>, value = <span class="string">"15000"</span>)，</span><br><span class="line">    <span class="meta">@HystrixProperty</span>(name = <span class="string">"metrics.rollingStats.numBuckets"</span>, value = <span class="string">"5"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>requestVolumeThreshold</strong>：Hystrix将断路器断闸之前，10s内接收到的连续的调用个数</p><p><strong>errorThresholdPercentage</strong>：整体调用失败（由于超时、抛出异常或返回HTTP 500）的百分比。超过后Hystrix会执行fail fast。</p><p><strong>sleepWindowInMilliseconds</strong>：断路器跳闸之后，Hystrix允许另一个调用通过以便查看是否恢复健康之前Hystrix的休眠时间。</p><p><strong>timeInMilliseconds</strong>：监视服务调用情况的窗口大小。</p><p><strong>numBuckets</strong>：统计窗口中失败次数的数据。Hystrix将统计数据放到bucket中，以此判断调用是否失败。timeInMilliseconds的值必须能被numBuckets整除，如timeInMilliseconds为15000（15s）的同时numBuckets为3或5。</p><p>检查失败次数的统计窗口越小且bucket数量越多，月耗费CPU和内存资源。因此，要酌情设计窗口大小和bucket数量。</p><h4 id="5-8-1-重新审视Hystrix配置"><a href="#5-8-1-重新审视Hystrix配置" class="headerlink" title="5.8.1 重新审视Hystrix配置"></a>5.8.1 重新审视Hystrix配置</h4><p>配置Hystrix时，可以设置不同的级别（level）：</p><ol><li>应用程序级别的默认值</li><li>类级别的默认值</li><li>在类中定义的线程池级别</li></ol><p>通过在类级别设置默认参数，可以是类中所有Hystrix命令享有相同的配置。类级别属性通过<strong>@DefaultProperties</strong>的类级注解设置。除非希望在某线程池上显示地覆盖，否则所有线程池都将继承应用程序级别的默认设置或类中定义的默认设置。</p><h3 id="5-9-线程上下文和Hystrix"><a href="#5-9-线程上下文和Hystrix" class="headerlink" title="5.9 线程上下文和Hystrix"></a>5.9 线程上下文和Hystrix</h3><p>当一个<em>@HystrixCommand</em>被执行时，它可以使用两种不同的隔离策略来运行：<strong>THREAD</strong>和<strong>SEMAPHORE</strong>。默认使用THREAD方式。使用线程方式隔离，Hystrix命令可以将调用格力在一个线程池中运行，不会将它的上下文和调用它的父线程共享。这样Hystrix可以随时中断线程的执行，不必担心会影响到调用它的父线程。</p><p>使用基于信号量的隔离方式，Hystrix管理由@HystrixCommand注解保护的分布式调用，不需要启动新线程，若调用超时，就会中断父线程。在同步容器服务器环境（Tomcat）中，中断父线程将会导致开发人员无法捕获异常。</p><p>要设置隔离方式，可以在commandProperties参数中添加<code>@HystrixProperty(name=&quot;execution.isolation.strategy&quot;, value=&quot;SEMAPHORE&quot;)</code>。</p><p><strong>注意：</strong></p><p>默认情况下，推荐使用<em>THREAD</em>隔离方式。这使你和父进程间保持了一个高层次的隔离。THREAD方式比SEMOPHORE方式更重，SEMOPHORE更轻量级。SEMOPHORE更适合服务量很大且使用异步I/O编程模型（如Netty）运行的情况。</p><h4 id="5-9-1-ThreadLocal和Hystrix"><a href="#5-9-1-ThreadLocal和Hystrix" class="headerlink" title="5.9.1 ThreadLocal和Hystrix"></a>5.9.1 ThreadLocal和Hystrix</h4><p>Hystrix在默认情况下不会将父级的上下文传递到由Hystrix命令管理的线程中。如，<strong>父线程中的ThreadLocal值在被此线程调用的线程（子线程，且使用@HystrixCommand标记）的方法中不能使用</strong>（默认隔离方式为THREAD情况时）。</p><p>举个例子说明。通常在一个基于REST的环境中，你想给某个服务调用传递一个上下文信息，以便于管理这个服务。比如，可以在HTTP请求头传递一个<strong>关联ID（correlationID）</strong>或者<strong>认证token</strong>，可以在下游所有的服务中调用。关联ID是唯一标识符，可用于在单个事务中跨多个服务调用进行追踪。</p><p><strong>要在所有服务调用中使用这个值，可以用一个Spring Filter类来拦截所有调用该REST服务的请求，从HTTP请求头中检索该信息，并将之存储到自定义的UserContext对象中。这样，在任何REST服务调用中要使用这个值时，可以从ThreadLocal存储变量中检索UserContext并读取其值。</strong>以下代码展示了如何在licensingservice中使用过滤器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UserContextFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">UserContextHolder</span><br><span class="line">    .getContext()</span><br><span class="line">    .setCorrelationId(httpServletRequest.getHeader(UserContext.CORRELATION_ID) );         UserContextHolder</span><br><span class="line">            .getContext()</span><br><span class="line">            .setUserId(httpServletRequest.getHeader(UserContext.USER_ID));         UserContextHolder</span><br><span class="line">            .getContext()</span><br><span class="line">            .setAuthToken(httpServletRequest.getHeader(UserContext.AUTH_TOKEN));        UserContextHolder</span><br><span class="line">            .getContext()</span><br><span class="line">            .setOrgId(httpServletRequest.getHeader(UserContext.ORG_ID));</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"UserContextFilter Correlation id: &#123;&#125;"</span>,  UserContextHolder.getContext().getCorrelationId());</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(httpServletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>UserContextHolder</strong>类用来<strong>在ThreadLocal中存储UserContext</strong>。一旦存储在ThreadLocal中，任何为请求执行的代码都会使用存储在UserContextHolder中的UserContext对象。UserContextHolder类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserContext&gt; userContext = <span class="keyword">new</span> ThreadLocal&lt;UserContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> UserContext <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserContext context = userContext.get();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = createEmptyContext();</span><br><span class="line">            userContext.set(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userContext.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(UserContext context)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(context, <span class="string">"Only non-null UserContext instances are permitted"</span>);</span><br><span class="line">        userContext.set(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> UserContext <span class="title">createEmptyContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以在许可证服务中添加一些日志了，以便测试。</p><ul><li>在/licenses/utils/UserContextFilter.java中的doFilter()方法</li><li>/licenses/controllers/LicenseServiceController.java中的getLicenses()方法</li><li>/licenses/services/LicenseService.java中的getLicenseByOrg()方法，此方法是使用@HystrixCommand标记的</li></ul><p>现在可以在调用license服务时加上一个HTTP header：</p><table><thead><tr><th>key</th><th></th></tr></thead><tbody><tr><td>tmx-correlation-id</td><td>TEST-CORRELATION-ID</td></tr></tbody></table><p>再次访问 <a href="http://localhost:8081/v1/organizations/e254f8c-c442-4ebe-a82ae2fc1d1ff78a/licenses/会发现在控制台中打印了三条日志信息：" target="_blank" rel="noopener">http://localhost:8081/v1/organizations/e254f8c-c442-4ebe-a82ae2fc1d1ff78a/licenses/会发现在控制台中打印了三条日志信息：</a></p><blockquote><p> UserContextFilter Correlation id: TEST-CORRELATION-ID</p><p>LicenseServiceController Correlation id: TEST-CORRELATION-ID</p><p>LicenseService.getLicensesByOrg  Correlation id: </p></blockquote><p>可以看到，<strong>由@HystrixCommand标记的方法<em>LicenseService.getLicensesByOrg()</em>没有打印出correlationID</strong>，这是因为它没有找到当前线程的UserContext。我们可以通过Spring Cloud和Hystrix提供的并发策略机制来实现上下文的传递。</p><h4 id="5-9-2-HystrixConcurrencyStrategy实战"><a href="#5-9-2-HystrixConcurrencyStrategy实战" class="headerlink" title="5.9.2 HystrixConcurrencyStrategy实战"></a>5.9.2 HystrixConcurrencyStrategy实战</h4><p>Hystrix允许你定义自己的并发策略来包装你的Hystrix调用，并将父线程的上下文注入到有Hystrix命令管理的子线程中。实现HystrixConcurrencyStrategy，你需要做以下三件事：</p><ol><li>定义自己的Hystrix并发策略类</li><li>定义一个Java <strong>Callable</strong>类，将UserContext注入Hystrix命令中</li><li>配置Spring Cloud来使用自定义的Hystrix并发策略</li></ol><p><strong>自定义Hystrix并发策略类</strong></p><p>Hystrix<strong>只允许</strong>你为一个应用定义一个并发策略。Spring Cloud已经定义好了一个并发策略，用来处理Spring security的信息。你可以将自己定义的并发策略和Spring Cloud提供的集成到一起，作为Hystrix并发策略。</p><p>我们通过<em>ThreadLocalAwareStrategy.java</em>来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalAwareStrategy</span> <span class="keyword">extends</span> <span class="title">HystrixConcurrencyStrategy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HystrixConcurrencyStrategy existingConcurrencyStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocalAwareStrategy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HystrixConcurrencyStrategy existingConcurrencyStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.existingConcurrencyStrategy = existingConcurrencyStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">wrapCallable</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> existingConcurrencyStrategy != <span class="keyword">null</span></span><br><span class="line">                ? existingConcurrencyStrategy</span><br><span class="line">                .wrapCallable(<span class="keyword">new</span> DelegatingUserContextCallable&lt;T&gt;(callable, UserContextHolder.getContext()))</span><br><span class="line">                : <span class="keyword">super</span>.wrapCallable(<span class="keyword">new</span> DelegatingUserContextCallable&lt;T&gt;(callable, UserContextHolder.getContext()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个并发策略类，继承HystrixConcurrencyStrategy，Spring Cloud已经有了一个并发策略类，所以构造方法中需要传入现有的currency strategy。在<strong>wrapCallable()</strong>方法中，传入一个<strong>Callable</strong>变量，<strong>DelegatingUserContextCallable</strong>方法负责将父线程（执行REST服务调用的线程）的UserContext传入Hystrix命令标记的方法中。</p><p><strong>定义一个Java Callable类来将UserContext注入Hystrix命令</strong></p><p>接下来就是实现如何将父线程的context传入Hystrix命令中。通过<strong>DelegatingUserContextCallable.java</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingUserContextCallable</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; delegate;</span><br><span class="line">    <span class="keyword">private</span> UserContext originalUserContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingUserContextCallable</span><span class="params">(Callable&lt;V&gt; delegate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             UserContext userContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="keyword">this</span>.originalUserContext = userContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserContextHolder.setContext( originalUserContext );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.call();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.originalUserContext = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">Callable&lt;V&gt; <span class="title">create</span><span class="params">(Callable&lt;V&gt; delegate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         UserContext userContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatingUserContextCallable&lt;V&gt;(delegate, userContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，DelegatingUserContextCallable类包含一个Callable对象（用来调用有<em>@HystrixCommand</em>标记的方法），一个UserContext对象（用来保存从父线程传入的UserContext）。设置好UserContext，存储UserContext的ThreadLocal变量就和有Hystrix标记的线程关联起来了。下面<code>try{}</code>中的call方法只是一个模板，实际使用时改成相应的代码（即有Hystrix标记的方法，如<strong><em>LicenseServer.getLicenseByOrg()</em></strong>）。</p><p><strong>配置Spring Cloud来使用你自己的Hystrix并发策略</strong></p><p>定义好了<strong>Hystrix并发策略</strong>和<strong>线程上下文传递方法</strong>，我们需要将它们告诉Spring Cloud和Hystrix。为此，我们新建一个配置类<strong>ThreadLocalConfiguration</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">private</span> HystrixConcurrencyStrategy existingConcurrencyStrategy;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Keeps references of existing Hystrix plugins.</span></span><br><span class="line">            HystrixEventNotifier eventNotifier = HystrixPlugins.getInstance()</span><br><span class="line">                    .getEventNotifier();</span><br><span class="line">            HystrixMetricsPublisher metricsPublisher = HystrixPlugins.getInstance()</span><br><span class="line">                    .getMetricsPublisher();</span><br><span class="line">            HystrixPropertiesStrategy propertiesStrategy = HystrixPlugins.getInstance()</span><br><span class="line">                    .getPropertiesStrategy();</span><br><span class="line">            HystrixCommandExecutionHook commandExecutionHook = HystrixPlugins.getInstance()</span><br><span class="line">                    .getCommandExecutionHook();</span><br><span class="line"></span><br><span class="line">            HystrixPlugins.reset();</span><br><span class="line"></span><br><span class="line">            HystrixPlugins.getInstance().registerConcurrencyStrategy(<span class="keyword">new</span> ThreadLocalAwareStrategy(existingConcurrencyStrategy));</span><br><span class="line">            HystrixPlugins.getInstance().registerEventNotifier(eventNotifier);</span><br><span class="line">            HystrixPlugins.getInstance().registerMetricsPublisher(metricsPublisher);</span><br><span class="line">            HystrixPlugins.getInstance().registerPropertiesStrategy(propertiesStrategy);</span><br><span class="line">            HystrixPlugins.getInstance().registerCommandExecutionHook(commandExecutionHook);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@Autowired</em>：当配置类对象被构造时，它将会autowire（自动装配）现有的HystrixConcurrencyStrategy。</p><p>注册自己的并发策略前，先拿到所有的Hystrix组件（如<strong>getEventNotifier()</strong>）；重置；然后注册自己的并发策略并将组件添加进去。最关键的一句，注册自己的并发策略——<code>HystrixPlugins.getInstance().registerConcurrencyStrategy(new ThreadLocalAwareStrategy(existingConcurrencyStrategy));</code></p><p>现在，重新构建并重启服务，通过GET请求访问 <a href="http://localhost:8081/v1/organizations/e254f8c-c442-4ebe-a82ae2fc1d1ff78a/licenses/" target="_blank" rel="noopener">http://localhost:8081/v1/organizations/e254f8c-c442-4ebe-a82ae2fc1d1ff78a/licenses/</a> ，会发现被@HystrixCommand标记的方法也成功地找到了<strong>【TEST-CORRELATION-ID】</strong> ，表明UserContext成功由父线程（调用服务的线程）传入被Hystrix标记的线程。</p><p>打印出的日志信息：</p><blockquote><p>UserContextFilter Correlation id: TEST-CORRELATION-ID</p><p>LicenseServiceController Correlation id: TEST-CORRELATION-ID</p><p>LicenseService.getLicensesByOrg  Correlation id: TEST-CORRELATION-ID</p></blockquote><h2 id="6-服务路由——Zuul"><a href="#6-服务路由——Zuul" class="headerlink" title="6 服务路由——Zuul"></a>6 服务路由——Zuul</h2><p>在分布式架构（如微服务）中，你需要确保安全（security）、日志（logging）、用户追踪（tracking of users）这样的活动在多个服务调用中能够正常发生，并且尽量在所有服务中一致的实现这些特性，而不需要每个开发团队构建自己的解决方法。尽管可以使用<strong>公共库或框架</strong>来在单个服务中构建这些功能，但这样做有三个影响：</p><p><strong>第一，在构建的每个服务中很难始终实现这些功能。</strong>开发人员专注于交付功能，在每日的快速开发工作中，他们很容易忘记实现服务日志或跟踪。尤其是对于那些在金融服务或医疗保健等严格监管的行业工作的人来说，一致且用文档来记录系统中的行为通常是符合政府法规的要求。</p><p><strong>第二，正确地发现这些功能是一个挑战。</strong>对每个正在开发的服务进行诸如<strong>微服务安全</strong>的建立与配置可能是很痛苦的。将实现cross-cutting关注点（如安全问题）的责任推给下面的开发团队将会增加开发人员忘记实现或没有正确实现这些功能的可能性。</p><p><strong>第三，这将会在所有服务中创建一个hard dependency</strong>。在所有服务中共享的公共框架中创建的功能越多，想要添加/更改功能就越困难，往往需要重写编译、部署。共享库中的核心功能的升级可能成为一个数月的迁移过程。</p><p>为了解决这个问题，将这些横切关注点（cross-cutting concerning）抽象成一个独立的且作为应用程序中<strong>所有服务调用的过滤器和路由器的服务</strong>很有必要。这种横切关注的叫做<strong>服务网关</strong>。服务客户端不再直接调用服务，而是通过服务网关（作为单个策略执行点（Policy Enforcement Point，PEP）），进行路由，到达最终目的地。</p><p>本章，使用Spring Cloud和Zuul来实现服务网关。要实现的有：</p><ul><li>把所有服务调用放到一个唯一的URL后，将调用请求做映射（通过服务发现机制）</li><li>把correlation ID注入到每个经过服务网关的服务中</li><li>把correlation ID注入到从客户端发回的响应中</li><li>构建一个动态路由机制，将具体的organizations服务（被调用服务）路由到某个不同的服务实例端点（负载均衡）</li></ul><h3 id="6-1-服务网关是什么"><a href="#6-1-服务网关是什么" class="headerlink" title="6.1 服务网关是什么"></a>6.1 服务网关是什么</h3><p>目前为止，我们已经会用两种方式调用服务了——web client或服务发现引擎（如Eureka）</p><p>服务网关存在于服务客户端与服务之间，作为调用服务时的统一中间件。</p><p>可以在服务网关中实现的<strong>横切关注点（每个/多数服务都要用的）</strong>有：</p><ul><li><strong>静态路由</strong>——通过统一URL调用服务，不必知道每个服务的具体端点（一般需要知道服务名）</li><li><strong>动态路由</strong>——根据请求/数据的不同，动态的进行路由。如，参与测试版（beta）程序的客户可能会被路由到特定服务集群的服务，与正常版不同。</li><li><strong>认证、授权</strong>——因为所有服务调用都要通过网关，所以在这里做认证/授权很方便，验证服务调用者是否经过认证，并有权限调用相应服务。</li><li><strong>度量数据收集和日志记录</strong>——网关可以收集度量数据和日志信息当服务调用经过时，还可以确保在用户请求上提供关键信息<strong>以确保日志统一</strong>。这并不意味着不需要从单个服务中收集度量数据，而是<strong>通过服务网关可以集中收集许多基本度量数据，如服务调用次数和服务响应时间</strong>。</li></ul><p><strong>且慢——服务网关不会造成单点故障吗？</strong></p><blockquote><p>前面说过，集中式负载均衡器会造成单点故障和性能瓶颈，若没有正确实现，服务网关也会有同样风险。因此要记住一下几点：</p><p><strong>在单独的服务组前面，负载均衡器仍然很有用</strong>。</p><p><strong>要保持为服务网关编写的代码是无状态的</strong>。</p><p><strong>要保持为服务网关编写的代码是轻量的</strong>。</p></blockquote><h3 id="6-2-Spring-Cloud和Netflix-Zuul"><a href="#6-2-Spring-Cloud和Netflix-Zuul" class="headerlink" title="6.2 Spring Cloud和Netflix Zuul"></a>6.2 Spring Cloud和Netflix Zuul</h3><p>要使用Zuul，首先要做一些准备工作：</p><ol><li>引入依赖</li><li>修改项目代码，将服务加上合适的标记以表明它是一个Zuul服务</li><li>配置Zuul来和Eureka通信（可选）</li></ol><p>注意：第三点中，若使用了服务发现引擎，则请求来到服务网关后，服务网关还需要“查表”（与服务发现引擎通信），才能知道具体的服务实例端点。</p><h4 id="6-2-1-构建Zuul项目"><a href="#6-2-1-构建Zuul项目" class="headerlink" title="6.2.1 构建Zuul项目"></a>6.2.1 构建Zuul项目</h4><p>即构建一个Zuul服务器，用来作服务网关。首先添加依赖<em>spring-cloud-starter-zuul</em></p><h4 id="6-2-2-为Zuul服务使用Spring-Cloud注解"><a href="#6-2-2-为Zuul服务使用Spring-Cloud注解" class="headerlink" title="6.2.2 为Zuul服务使用Spring Cloud注解"></a>6.2.2 为Zuul服务使用Spring Cloud注解</h4><p>在zuulsvr这个module中新建启动类，并增加<em>@EnableZuulProxy</em>注解，使服务成为一个服务器。</p><p><strong>注意：</strong></p><p>如果你开启了自动补全（IDE），你可能注意到还有一个注解叫<em>@EnableZuulServer</em>。两者的区别就是<em>@EnableZuulServer</em>不会加载Zuul反向代理过滤器，以及Eureka服务器用来服务发现。换句话说，<em>@EnableZuulProxy</em>预置好了更多的过滤器，如果你想用现成的，那就拿来直接用。如果你不想用Eureka来实现服务发现（如Consul），你可以选择Server。</p><h4 id="6-2-3-配置Zuul与Eureka进行通信"><a href="#6-2-3-配置Zuul与Eureka进行通信" class="headerlink" title="6.2.3 配置Zuul与Eureka进行通信"></a>6.2.3 配置Zuul与Eureka进行通信</h4><p>Zuul默认可以和Spring Cloud的相关组件进行合作。如，Zuul会自动使用Eureka来作为服务发现服务器，使用Ribbon来进行客户端请求的负载均衡。</p><p>在Zuul的<em>application.yml</em>中添加Eureka的配置即可，与Eureka中的相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    preferIpAddress: true</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: true</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    serviceUrl:</span><br><span class="line">        defaultZone: http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure><h3 id="6-3-在Zuul中配置路由"><a href="#6-3-在Zuul中配置路由" class="headerlink" title="6.3 在Zuul中配置路由"></a>6.3 在Zuul中配置路由</h3><p>Zuul核心就是一个反向代理。反向代理就是一个中间的服务器，处于客户端（想要访问某资源）和资源之间。客户端不知道它访问的是服务器还是代理。反向代理服务器就像真正的服务器那样，处理客户端请求。</p><p>关于映射路由，Zuul有多种机制：</p><ul><li>通过服务发现自动映射</li><li>通过服务发现手动映射</li><li>通过静态路由手动映射</li></ul><h4 id="6-3-1-通过服务发现自动映射路由"><a href="#6-3-1-通过服务发现自动映射路由" class="headerlink" title="6.3.1 通过服务发现自动映射路由"></a>6.3.1 通过服务发现自动映射路由</h4><p>路由映射规则可以在application.yml中定义。其实，也可以不用定义。Zuul可以根据服务ID自动进行路由（0配置！）。比如，想调用organizationservice，你可以通过调用Zuul服务实例，访问端点：<a href="http://localhost:5555/organizationservice/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a。" target="_blank" rel="noopener">http://localhost:5555/organizationservice/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a。</a></p><p>使用Zuul集成Eureka的好处是，你永远都只需要知道单一的URL端点（Zuul），你可以在不告知Zuul的情况下添加/移除服务。因为Zuul总是和Eureka通信，来获得每个服务的物理地址。</p><p>使用<strong>/routes</strong>端点可以查看由Zuul管理的路由：<a href="http://localhost:5555/routes。" target="_blank" rel="noopener">http://localhost:5555/routes。</a></p><p><img src="/passages/SPMIA/zuul-routes.png" alt="zuul-routes"></p><p>右边是服务ID（名），左边是Zuul创建的路由URL</p><h4 id="6-3-2-使用服务发现手动映射路由"><a href="#6-3-2-使用服务发现手动映射路由" class="headerlink" title="6.3.2 使用服务发现手动映射路由"></a>6.3.2 使用服务发现手动映射路由</h4><p>Zuul允许你手动的定义路由映射规则。默认情况，Zuul通过<strong>服务ID</strong>（如organizationservice）来映射，如果你想使用自己的规则，可以在Zuul服务的application.yml中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    organizationservice: /organization/**</span><br></pre></td></tr></table></figure><p>现在就可以通过<a href="http://localhost:5555/organization/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a访问到organization服务了。再次访问http://localhost:5555/routes，会发现映射到organizationservice的有两个路由：`&quot;organization/**&quot;" target="_blank" rel="noopener">http://localhost:5555/organization/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a访问到organization服务了。再次访问http://localhost:5555/routes，会发现映射到organizationservice的有两个路由：`&quot;organization/**&quot;</a>: “organizationservice”<code>；</code>“organizationservice/<strong>“: “organizationservice”`。其中，第二个是Zuul自动生成的，第一个是刚才我们配置的。如果不需要Zuul为我们自动生成，可以使用</strong>ignored-services<strong>来配置，如：<code>ignored-services: &#39;organizationservice&#39;</code>。如果想把所有Zuul生成的都忽略掉，使用***</strong>。</p><p>一个用来区分【API路由】和【内容路由】常见的方法是，所有的API路由以<strong>/api</strong>打头。对于Zuul， 可以在配置项中加上<strong>/prefix</strong>。就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  ignored-services: &apos;*&apos;</span><br><span class="line">  prefix:  /api</span><br><span class="line">  routes:</span><br><span class="line">    organizationservice: /organization/**</span><br><span class="line">    licensingservice: /licensing/**</span><br></pre></td></tr></table></figure><h4 id="6-3-3-使用静态URL手动路由"><a href="#6-3-3-使用静态URL手动路由" class="headerlink" title="6.3.3 使用静态URL手动路由"></a>6.3.3 使用静态URL手动路由</h4><p>Zuul可以用来路由一些<strong>不是由Eureka管理的服务</strong>。假如你的licensing service是由Python写的，你想用Zuul来做服务代理，可以直接在配置文件中写死：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.licensestatic.path: /licensestatic/**</span><br><span class="line">zuul.routes.licensestatic.url:  http://licenseservice-static:8081</span><br></pre></td></tr></table></figure><p>这样，对于<em>licensestatic</em>端点，Eureka不会知道，所有访问到licensestatic的请求会直接被路由到<a href="http://licenseservice-static:8081端点。这样做存在一个问题：绕过了Eureka，只有一条路径可以用来处理请求（即licensestatic.url）。幸运的是，可以手动配置Zuul来禁用Ribbon和Eureka集成，然后列出Ribbon将进行负载均衡的各个服务实例。如下面所示：" target="_blank" rel="noopener">http://licenseservice-static:8081端点。这样做存在一个问题：绕过了Eureka，只有一条路径可以用来处理请求（即licensestatic.url）。幸运的是，可以手动配置Zuul来禁用Ribbon和Eureka集成，然后列出Ribbon将进行负载均衡的各个服务实例。如下面所示：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    licensestatic:</span><br><span class="line">      path: /licensestatic/**</span><br><span class="line">      serviceId: licensestatic　　⇽---　定义一个服务ID，该服务ID将用于在Ribbon中查找服务</span><br><span class="line">ribbon:</span><br><span class="line">  eureka:</span><br><span class="line">    enabled: false　　⇽---　在Ribbon中禁用Eureka支持</span><br><span class="line">licensestatic:</span><br><span class="line">  ribbon:</span><br><span class="line">    listOfServers: http://licenseservice-static1:8081,</span><br><span class="line">      http://licenseservice-static2:8082　　⇽---　指定请求会路由到的服务器列表</span><br></pre></td></tr></table></figure><p><strong>处理非JVM服务</strong></p><blockquote><p>使用静态路由并在Ribbon中禁用Eureka的一个问题是，禁用了通过Zuul网关的素有服务的Ribbon支持。这意味着Eureka服务器的压力会更大，因为Zuul不能使用Ribbon来缓存查找服务。Ribbon做的就是客户端负载均衡，即每次查找不是直接问Eureka，它会先在本地查找缓存，并定期和Eureka通信来将最近使用到的缓存到客户端。如果不能使用Ribbon，那么每次Zuul都会直接调用Eureka来解析服务地址。</p><p>因此，我们可以使用多个服务网关，基于不同的需求。对于非JVM的应用，可以设置一个单独的服务器来处理。作者推荐，最好是使用Spring Cloud “SideCar”实例。使用SideCar你可以用一个Eureka实例注册一个非JVM服务，并通过Zuul进行代理。有兴趣可以在<a href="http://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html#spring-cloud-ribbonwithout-eureka上看看。" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html#spring-cloud-ribbonwithout-eureka上看看。</a></p></blockquote><h4 id="6-3-4-动态重新加载路由配置"><a href="#6-3-4-动态重新加载路由配置" class="headerlink" title="6.3.4 动态重新加载路由配置"></a>6.3.4 动态重新加载路由配置</h4><p>Zuul暴露了一个【基于POST】的路由：<strong>/refresh</strong>。通过访问/refresh端点，就可以刷新配置信息。</p><p><strong><em>为什么没有刷新？？在Zuul的application.yml和配置服务器上分别改都没用…</em></strong></p><h4 id="6-3-5-Zuul和服务超时"><a href="#6-3-5-Zuul和服务超时" class="headerlink" title="6.3.5 Zuul和服务超时"></a>6.3.5 Zuul和服务超时</h4><p>Zuul使用Netflix的Hystrix和Ribbon库来防止“又臭又长”的服务调用影响服务网关的性能。默认情况下，Zuul会终止并返回HTTP 500错误，对于任何超过1s的调用（这也是Hystrix的默认值）。可以在Zuul服务的配置文件中直接更改此配置值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 2500</span><br></pre></td></tr></table></figure><p>如果你想<strong>将某个服务的超时时间设置的不一样</strong>，而不是对所有服务生效，把<code>default</code>部分改成相应服务ID就好了。如，设置licensingservice的超时时间为3s：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.licensingservice.execution.isolation.thread.timeoutInMilliseconds: 3000</span><br></pre></td></tr></table></figure><p>然而，尽管我们可以设置自己的超时时间（其实设置的是Hystrix的超时时间），Ribbon也有一个超时时间，默认为5s。万一自己设计的服务有超过5s的调用请求的风险，最好还是设置一下这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.licensingservice.execution.isolation.thread.timeoutInMilliseconds: 7000</span><br><span class="line">licensingservice.ribbon.ReadTimeout: 7000</span><br></pre></td></tr></table></figure><p>即，<strong><em>若有需要配置超时时间≥5的，需要同时配置Hystrix和Ribbon</em></strong>。</p><h3 id="6-4-Zuul的强大之处——过滤器"><a href="#6-4-Zuul的强大之处——过滤器" class="headerlink" title="6.4 Zuul的强大之处——过滤器"></a>6.4 Zuul的强大之处——过滤器</h3><p>除了代理所有请求，简化服务调用，Zuul真正厉害的地方应该在于<strong>需要通过网关流经所有的服务调用的自定义逻辑</strong>。这种自定义逻辑通常用于强制执行一组一致性的应用程序策略，如安全性、日志记录和对所有服务的跟踪。</p><p>这些策略也被叫做<strong>“横切关注点（cross-cutting concerns）”</strong>，因为要将它们应用在所有服务中。这样，可以按照J2EE中的servlet过滤器或Spring Aspect类似的方式来使用。servlet过滤器或Spring Aspect被本地化为特定的服务，而使用Zuul和Zuul过滤器可以为通过Zuul路由的所有服务实现横切关注点。</p><p>Zuul允许你在Zuul网关内使用过滤器来构建自定义逻辑。Zuul支持的过滤器有：</p><ul><li><strong>前置过滤器</strong>——在Zuul<strong>将实际请求发送到目的地之前被调用</strong>。前置过滤器通常执行确保服务具有一致的消息格式（如，HTTP首部是否设置妥当）的任务；或者确保调用服务的用户已通过验证和授权（Authentication、Authorization）。</li><li><strong>后置过滤器</strong>——在<strong>目标服务被调用并将响应发送回客户端后被调用</strong>。通常用来记录从目标服务返回的响应、处理错误或审核对敏感信息的响应。</li><li><strong>路由过滤器</strong>——在<strong>调用目标服务之前拦截调用</strong>。<strong>通常用来确定是否需要进行某些级别的动态路由</strong>。例如，本章后面使用的路由级别的过滤器，将在同一服务的两个不同版本之间进行路由，以便将一小部分的服务调用路由到服务的新版本。这样就能在不让每个人都使用新服务的情况下，让少量的用户体验新功能。</li></ul><p><img src="/passages/SPMIA/3-layer-filter-principle.png" alt="3-layer-filter-principle"></p><p>上图为三层过滤器的原理。、</p><p><img src="/passages/SPMIA/3-layer-filter-application.png" alt="3-layer-filter-application"></p><p>上图为结合应用的三层过滤器实现：</p><ul><li><strong>TrackingFilter</strong>：检查请求的HTTP首部，若不存在correlationID（关联ID），则为其创建一个。</li><li><strong>SpecialRoutesFilter</strong>：确定是否需要动态路由，即是否需要将一部分满足某种条件的请求路由到同一个服务的另一个版本上。如，确定是否需要做<strong>A/B测试</strong>。A/B测试是指给用户呈现同一个服务的两个不同版本，在投放到用户群体前，可以测试版本中新的feature。</li><li><strong>ResponseFilter</strong>：确保响应中有correlationID。</li></ul><h3 id="6-5-构建前置过滤器-产生关联ID"><a href="#6-5-构建前置过滤器-产生关联ID" class="headerlink" title="6.5 构建前置过滤器 | 产生关联ID"></a>6.5 构建前置过滤器 | 产生关联ID</h3><p>创建一个类：<em>TrackingFilter</em>。它会检查所有请求，确保请求头中都有一个header：<em>tmx-correlation-id</em>。此ID可以用来在多个服务中跟踪某个用户的请求。<strong>关联ID的实现将使用ThreadLocal变量</strong>。</p><p>如果某个请求的HTTP首部没有<em>tmx-correlation-id</em>，Zuul下的TrackingFilter类会生成并设置好关联ID。<strong>关联ID代表着某次服务调用是为了执行用户的某个请求而做的一系列服务调用的一部分</strong>。</p><p>接下来分析TrackingFilter类。</p><h3 id=""><a href="#" class="headerlink" title="#"></a>#</h3><p>所有的Zuul过滤器都要继承ZuulFilter类，并重写四个方法：filterType()、filterOrder()、shouldFilter()、run()。</p><p><strong>注意</strong></p><blockquote><p>对于普通的Spring MVC或者Spring Boot服务，<strong>RequestContext</strong>是从<strong><em>org.springframework.web.servletsupport.RequestContext</em></strong>包中引入的；而在Zuul中，提供了一个额外的RequestContext，以方便进行Zuul相关的操作，即它是来自<strong><em>com.netflix.zuul.context</em></strong>包的。</p></blockquote><h4 id="6-5-1-在服务调用中使用关联ID"><a href="#6-5-1-在服务调用中使用关联ID" class="headerlink" title="6.5.1 在服务调用中使用关联ID"></a>6.5.1 在服务调用中使用关联ID</h4><p>我们将关联ID加入了流经Zuul的每个服务调用中，但是要怎么保证：</p><ul><li>关联ID可以被正在被调用的服务访问</li><li>所有调用此服务的下游服务调用仍然可以将关联ID继续往下传递</li></ul><p>实现过程入下：</p><p><img src="/passages/SPMIA/3-layer-filter.png" alt="3-layer-filter"></p><p>以上过程发生了四件事：</p><ol><li>当服务调用（licensing service）经过Zuul网关时，<em>TrackingFilter</em>将会把关联ID注入所有经过Zuul的请求头中。</li><li><em>UserContextFilter</em>类是一个自定义的HTTP ServletFilter。它将一个关联ID和一个<em>UserContext</em>类对象关联起来（根据关联ID创建一个UserContext）。UserContext对象用于将一些待会要用到的值存储到ThreadLocal中。</li><li>许可证服务的业务逻辑要执行一个对组织服务的调用。</li><li><em>RestTemplate</em>类用来调用组织服务。RestTemplate类将使用一个自定义的Spring Interceptor（UserContextInterceptor 拦截器）类，来将关联ID注入返回的响应请求的HTTP首部中。</li></ol><p><strong>重复代码与共享库对比</strong></p><blockquote><p>是否应该在微服务中使用公共库的话题时微服务设计中的一个灰色地带。微服务纯粹主义者会说，<strong>不要在服务中使用自定义框架，因为它会在服务中引入人为的依赖，业务逻辑的更改或bug修正可能对所有服务造成大规模的重构</strong>。但是，其他一些微服务实践者指出，这样是不切实际的，因为存在一些情况（如UserContextFilter），构建公共库并在服务之间共享它是有意义的。</p><p>当我们在处理一些基础设施风格的任务时（所有服务都要用的那种），很适合使用公共库；若是共享面向业务的类，那就是自找麻烦，因为这样是在打破服务之间的界限。</p><p>在本章示例代码中，作者之所以在每一个服务的utils包中都写了UserContext、UserContextFilter、UserContextInterceptor类的副本，因为这样不需要创建一个共享库并把它发布到Maven上然后引入依赖，这样会看起来更复杂。</p></blockquote><p><strong>UserContextHolder：存储UserContext</strong></p><p>UserContextHolder负责将UserContext存储到一个ThreadLocal变量中，以便于让处理当前请求的线程所调用的方法能够访问。</p><p><strong>自定义RestTemplate和UserContextInteceptor类：保证关联ID向下游传播</strong></p><p>要使用UserContextInteceptor，需要定义一个<em>RestTemplate</em>类，并把UserContextInteceptor放到里面。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestTemplate template = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    List interceptors = template.getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (interceptors == <span class="keyword">null</span>) &#123;</span><br><span class="line">        template.setInterceptors(Collections.singletonList(<span class="keyword">new</span> UserContextInterceptor()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> UserContextInterceptor());</span><br><span class="line">        template.setInterceptors(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@LoadBalanced</strong>注解表示这个RestTemplate对象要使用Ribbon；将UserContextInteceptor加入到创建好的RestTemplate中。经过这样定义，每当你使用<strong>@Autowired</strong>标记，将RestTemplate注入一个类中，创建的RestTemplate都是带有UserContextInterceptor的。</p><p><strong>日志聚合、认证…</strong></p><blockquote><p>现在有了关联ID，并可以把它传递到每个服务上，那就可以跟踪一个事务啦。可以考虑将所有服务日志放到一个中心的日志聚合处，每个条目通过关联ID来标识，第九章介绍的Spring Cloud Sleuth就是做这个的。</p></blockquote><h3 id="6-6-构建后置过滤器-接收关联ID"><a href="#6-6-构建后置过滤器-接收关联ID" class="headerlink" title="6.6 构建后置过滤器 | 接收关联ID"></a>6.6 构建后置过滤器 | 接收关联ID</h3><p>与构建前置过滤器类似，构建一个ResponseFilter，用于将关联ID”输出“到返回的响应中。</p><h3 id="6-7-构建动态路由过滤器"><a href="#6-7-构建动态路由过滤器" class="headerlink" title="6.7 构建动态路由过滤器"></a>6.7 构建动态路由过滤器</h3><p>目标：动态过滤器可以获取到所有经过Zuul的服务ID，然后调用<strong>SpecialRoutesService</strong>，<strong>SpecialRoutesFilter</strong>会产生一个随机数作为权重，通过与新版本的服务进行比较，决定是否进行特殊路由。</p><h4 id="6-7-1-构建路由过滤器的框架结构"><a href="#6-7-1-构建路由过滤器的框架结构" class="headerlink" title="6.7.1 构建路由过滤器的框架结构"></a>6.7.1 构建路由过滤器的框架结构</h4><p>还是像之前一样，继承ZuulFilter并覆盖其方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialRoutesFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> filterUtils.ROUTE_FILTER_TYPE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-7-2-实现run-方法"><a href="#6-7-2-实现run-方法" class="headerlink" title="6.7.2 实现run()方法"></a>6.7.2 实现run()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line"></span><br><span class="line">        AbTestingRoute abTestRoute = getAbRoutingInfo( filterUtils.getServiceId() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (abTestRoute!=<span class="keyword">null</span> &amp;&amp; useSpecialRoute(abTestRoute)) &#123;</span><br><span class="line">            String route = buildRouteString(ctx.getRequest().getRequestURI(),</span><br><span class="line">                    abTestRoute.getEndpoint(),</span><br><span class="line">                    ctx.get(<span class="string">"serviceId"</span>).toString());</span><br><span class="line">            forwardToSpecialRoute(route);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先，调用<strong>SpecialRoutesService</strong>服务来检查是否存在关于这个服务（如service_name=organizationservice）的一个特殊路由记录。</p></li><li><p><strong>useSpecialRoute</strong>方法会将在数据库中查到的weight值与生成的随机值的大小做比较，决定是否将请求路由到备用服务。</p></li><li>如果调用特殊路由服务找到了一条记录，则为其构建一个完整的URL。</li><li>最后，<strong>forwardToSpecialRoute</strong>方法将请求转发。</li></ul><h4 id="6-7-3-转发路由"><a href="#6-7-3-转发路由" class="headerlink" title="6.7.3 转发路由"></a>6.7.3 转发路由</h4><h4 id="6-7-4-整合"><a href="#6-7-4-整合" class="headerlink" title="6.7.4 整合"></a>6.7.4 整合</h4><h2 id="7-保护你的微服务（Securing）"><a href="#7-保护你的微服务（Securing）" class="headerlink" title="7 保护你的微服务（Securing）"></a>7 保护你的微服务（Securing）</h2><p>本章主要使用Spring Cloud security和OAuth2来保护基于Spring的服务。OAuth2是一个基于令牌（token）的安全框架，允许用户使用第三方验证服务进行验证。如果用户成功进行了验证，则会出示一个令牌，该令牌必须与每个请求一起发送。然后，验证服务可以对令牌进行确认。使用OAuth2的好处是，在调用多个服务来完成用户请求时，用户不需要在处理请求的时候为每个服务都提供自己的凭据信息就能完成验证。</p><p>一个成熟的OAuth2实现还需要一个前端Web应用程序来输入用户凭据。本章将使用REST客户端（如POSTMAN）来模拟凭据的提交。有关如何配置前端应用程序，可以参考：<a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-springsecurity-part-v。" target="_blank" rel="noopener">https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-springsecurity-part-v。</a></p><p>首先，来看一下OAuth2架构：</p><h3 id="7-1-OAuth2简介"><a href="#7-1-OAuth2简介" class="headerlink" title="7.1 OAuth2简介"></a>7.1 OAuth2简介</h3><p>OAuth2安全框架包含四个组件：</p><ol><li><strong>被保护的资源</strong>——既然要认证用户才能访问，那么资源/微服务就是被保护的。</li><li><strong>资源所有者</strong>——资源所有者定义了应用的名字，可以访问的用户，可访问用户的权限。每个通过资源所有者注册的应用都有一个<strong>应用名</strong>和<strong>应用秘钥</strong>。此两者是证书的一部分。</li><li><strong>应用</strong>——指的是调用服务的应用，即用户通过此应用来调用某个服务。</li><li><strong>OAuth2认证服务器</strong>——认证服务器是存在于应用和服务之间的中介。有了认证服务器，用户不必每次都使用证书来验证身份。</li></ol><p>工作流程如下：</p><p><img src="/passages/SPMIA/oauth2-authentication.png" alt="oauth2-authentication"></p><p> 如上图所示，每次验证身份时只需要通过token即可。</p><p>资源拥有者，可以使用OAuth2和角色来定义用户可以访问的服务端点以及可以使用的HTTP动词（GET、POST等）。</p><p>Web服务安全是一个很复杂的主题。你要明白是谁在调用你的服务：（内部用户；外部用户），怎样调用（内部基于Web的客户端；移动设备；外部的Web应用），有哪些行为。OAuth2允许你使用以下四种授权方式：</p><ul><li><strong>密码（password）</strong></li><li><strong>客户端证书（client credential）</strong></li><li><strong>授权码（authorization code）</strong></li><li><strong>隐式（implicit）</strong></li></ul><p>由于篇幅问题，本章只讨论：</p><ul><li>怎样使用密码来授权</li><li>使用JWT（JSON Web Token）来将信息编码在token中</li><li>怎样使应用更安全</li></ul><p>如果想了解OAuth2的更多细节，推荐阅读：Justin Richer和Antonio Sanso的书：<em>OAuth2 in Action (2017)</em>。</p><h3 id="7-2-一步一步来：使用Spring和OAuth2保护一个端点"><a href="#7-2-一步一步来：使用Spring和OAuth2保护一个端点" class="headerlink" title="7.2 一步一步来：使用Spring和OAuth2保护一个端点"></a>7.2 一步一步来：使用Spring和OAuth2保护一个端点</h3><p>最简单的方式：使用密码验证。需要做的有：</p><ul><li>建立一个基于Spring Cloud的OAuth2认证服务</li><li>注册一个伪UI应用程序（作为一个已授权的应用程序），可以对用户身份进行验证和授权</li><li>使用OAuth2密码授权来保护EagleEye服务。不需要写UI，而是用Postman模拟用户登录，并使用OAuth2服务来验证身份</li><li>保护licensing和organization服务，使仅认证用户能够访问</li></ul><h4 id="7-2-1-建立EagleEye-OAuth2验证服务"><a href="#7-2-1-建立EagleEye-OAuth2验证服务" class="headerlink" title="7.2.1 建立EagleEye OAuth2验证服务"></a>7.2.1 建立EagleEye OAuth2验证服务</h4><p>像其他部分一样，认证服务也是作为一个Spring Boot服务来运行的，需要首先添加需要的Maven依赖，然后为其设置一个启动类。需要的依赖有：</p><ul><li>spring-cloud-security</li><li>spring-security-oauth2</li></ul><p>认证服务启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = &#123; <span class="string">"/user"</span> &#125;, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">user</span><span class="params">(OAuth2Authentication user)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; userInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        userInfo.put(<span class="string">"user"</span>, user.getUserAuthentication().getPrincipal());</span><br><span class="line">        userInfo.put(<span class="string">"authorities"</span>, AuthorityUtils.authorityListToSet(user.getUserAuthentication().getAuthorities()));</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AuthenticationServer.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableAuthorizationServer启动认证服务器；</p><p>添加路由：/<strong>user</strong>（实际上是/auth/user，/auth在认证服务的配置文件application.yml中声明contextPath）</p><p>被保护的服务将调用此端点，来验证token并检索来调用此服务的用户所拥有的角色及权限。</p><h4 id="7-2-2-将客户端注册到OAuth2服务"><a href="#7-2-2-将客户端注册到OAuth2服务" class="headerlink" title="7.2.2 将客户端注册到OAuth2服务"></a>7.2.2 将客户端注册到OAuth2服务</h4><p>将在<em>OAuth2Config.java</em>中把需要注册的客户端注册上去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth2Config</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="string">"eagleeye"</span>)</span><br><span class="line">                .secret(<span class="string">"thisissecret"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="string">"refresh_token"</span>, <span class="string">"password"</span>, <span class="string">"client_credentials"</span>)</span><br><span class="line">                .scopes(<span class="string">"webclient"</span>, <span class="string">"mobileclient"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      endpoints</span><br><span class="line">        .authenticationManager(authenticationManager)</span><br><span class="line">        .userDetailsService(userDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OAuth2的配置类继承了<em>AuthorizationServerConfigurer</em>（<strong>AuthorizationServerConfigurerAdapter也继承自AuthorizationServerConfigurer</strong>），后者是Spring Security的一个核心类。提供了一些验证key和授权的方法。需要重写两个方法：</p><ul><li>configure()方法，定义注册到认证服务上的客户端，入参为<em>ClientDetailsServiceConfigurer</em>类型。</li><li>ada</li></ul><p>我们再深入看一下第一个configure()方法。</p><p><em>ClientDetailsServiceConfigurer</em>类支持两种不同的存储应用信息的方式：内存中和JDBC数据库中。本例使用<em>clients.inMemory()</em>方式。</p><p><em>withClient()</em>和<em>secret()</em>方法提供了注册认证服务的应用名和密码，密码在服务调用认证服务时获取访问token时用。</p><p><em>authorizedGrantTypes()</em>方法传入了一个逗号分隔的授予权限类型，本例中支持<strong>密码</strong>和<strong>客户端证书</strong>授权。</p><p><em>scopes()</em>方法定义调用认证服务的应用的类型。比如，Thoughtmechanix服务提供同一个应用的两个版本：一个web端，一个移动端。这些应用有相同的客户端名字和秘钥。当这个app向OAuth2申请key的时候，需要确定 是在哪个scope，确定了scope，才能给予适当的权限。需要注意的是，<strong>scope的定义与权限的定义不冲突，且优先级较高</strong>，即，无论一个用户有什么权限，它还要有适当的scopes才能够对某个资源有访问权限。这种限制数据访问的实践（practice）在处理敏感用户信息时极为常见（如（病人）健康记录、税务信息）。</p><p>现在已经注册了一个应用，<strong>EagleEye</strong>。既然使用密码方式来验证，接下来要对用户设置对应的账户和密码。</p><h4 id="7-2-3-配置EagleEye用户"><a href="#7-2-3-配置EagleEye用户" class="headerlink" title="7.2.3 配置EagleEye用户"></a>7.2.3 配置EagleEye用户</h4><p>已经设置好了应用级别的key和secret，可以为用户设置其单独的credentials和roles了。Spring存储/检索用户信息（用户的证书和角色）的地方有三种：内存、支持JDBC的关系型数据库、LDAP服务器。</p><p>LDAP服务器是什么？可以参考<a href="https://www.jianshu.com/p/7e4d99f6baaf" target="_blank" rel="noopener">这个</a>。</p><p>本例中，使用内存方式存储用户角色。定义两个用户账号：<em>john.carnell、william.woodward</em>；<em>john.carnell</em>拥有<code>USER</code>权限，<em>william.woodward</em>拥有<code>ADMIN</code>权限。</p><p>对每个用户的证书和角色的授予在<em>WebSecurityConfigurer.java</em>中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfigurer</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsServiceBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.userDetailsServiceBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">"john.carnell"</span>).password(<span class="string">"password1"</span>).roles(<span class="string">"USER"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="string">"william.woodward"</span>).password(<span class="string">"password2"</span>).roles(<span class="string">"USER"</span>, <span class="string">"ADMIN"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的两个bean：<em>authenticationManagerBean()、userDetailsServiceBean</em>分别用来对用户进行验证和返回用户信息。</p><h4 id="7-2-4-验证用户"><a href="#7-2-4-验证用户" class="headerlink" title="7.2.4 验证用户"></a>7.2.4 验证用户</h4><h2 id="8-事件驱动的架构——Spring-Cloud-Stream"><a href="#8-事件驱动的架构——Spring-Cloud-Stream" class="headerlink" title="8 事件驱动的架构——Spring Cloud Stream"></a>8 事件驱动的架构——Spring Cloud Stream</h2><h2 id="9-分布式跟踪——Spring-Cloud-Sleuth-amp-Zipkin"><a href="#9-分布式跟踪——Spring-Cloud-Sleuth-amp-Zipkin" class="headerlink" title="9 分布式跟踪——Spring Cloud Sleuth &amp; Zipkin"></a>9 分布式跟踪——Spring Cloud Sleuth &amp; Zipkin</h2><h2 id="10-部署微服务"><a href="#10-部署微服务" class="headerlink" title="10 部署微服务"></a>10 部署微服务</h2><h2 id="NOTES："><a href="#NOTES：" class="headerlink" title="NOTES："></a>NOTES：</h2>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/SPMIA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git使用</title>
      <link>https://gitplayb.github.io/passages/Git%E4%BD%BF%E7%94%A8/</link>
      <guid>https://gitplayb.github.io/passages/Git%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Sun, 22 Dec 2019 14:54:48 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><p>一般有两种方式：<code>git init</code>或者<code>git clone url</code> </p><p><strong>前者</strong>会在当前选定目录下创建一个<strong>.git</strong>隐藏目录（Windows上需要把隐藏文件查看勾选上才可以看到），即本目录将会作为一个本地仓库可以与远程仓库连接。打开.git目录可以看到里面含有一些此仓库的基本信息，主要是记录分支信息还有文件的更改情况等。</p><p><strong>后者</strong>可以直接从远程仓库中复制一份完全一样的代码，到你的本地目录，作为本地仓库（前提是你配置好了Git客户端如GitHub的用户名/密码或者SSH秘钥）。</p><h3 id="记录仓库中的改变"><a href="#记录仓库中的改变" class="headerlink" title="记录仓库中的改变"></a>记录仓库中的改变</h3><p><strong>版本控制系统</strong>最大的作用就是<strong>记录、跟踪文件的改变，使用户可以方便地在不同版本间切换</strong>。对于Git，基本状态有四个：<strong>Untracked、Unmodified、Modified、Staged</strong>。</p><ul><li><strong>Untracked</strong>——未被git加入跟踪，即文件怎么改变git都不管</li><li><strong>Unmodified</strong>——已跟踪、未修改，git记录其改变情况，但现在还没有改变</li><li><strong>Modified</strong>——已修改、未暂存，已经发生了改变，并且git记录了此改变</li><li><strong>Staged</strong>——已暂存，已将改变情况告诉git，加入暂存区，作为下次commit（提交）的材料</li></ul><h4 id="跟踪-记录文件"><a href="#跟踪-记录文件" class="headerlink" title="跟踪/记录文件"></a>跟踪/记录文件</h4><p>当我们想让git为我们记录一个文件的改变时，使用<code>git add</code>命令，后面跟着的是想要跟踪的文件名。这时我们查看git状态（<code>git status</code>）会发现，状态已经由<strong>untracked</strong>变成了<strong>tracked</strong>，终端会显示<em>Changes to be committed</em>。即，我们已经到达提交前的一个状态：所有改变已被记录并暂存。如果提交之前又对加入跟踪的文件作了改变，还需要再次运行<code>git add</code>命令，将改变暂存，然后提交。</p><p>由此可以看出，<code>git add</code>命令有两个作用：</p><ol><li>开始追踪/记录文件</li><li>将文件（改变）提交到暂存区</li></ol><p>#### </p><h4 id="查看状态（简版）"><a href="#查看状态（简版）" class="headerlink" title="查看状态（简版）"></a>查看状态（简版）</h4><p>查看状态有两种方式：<code>git status</code>或者<code>git status -s</code>或者<code>git status --short</code>。</p><p>前者查看较为详细的状态；后者查看简要状态。</p><p>其中后者的状态表示有两列：<strong>第一列表示暂存区的状态；第二列表示远程仓库的状态。</strong><code>??</code>表示为追踪；<code>A</code>代表已暂存；<code>M</code>代表已修改。</p><p>在git bash中操作一番发现，<strong>已修改但是没有暂存时<code>M</code>出现在右边且是红色的；修改且暂存后<code>M</code>出现在左边且是绿色的</strong>。如下：</p><p><img src="/passages/Git使用/git-status-s.png" alt="git-status-s"></p><p>显示还是挺人性化的，红色表示警告，暂存之后，就变成了绿色，表示正常状态。</p><p>如果做了改变，又没有commit，就会出现下图的情况：</p><p><img src="/passages/Git使用/1573698024559.png" alt="1573698024559"></p><p>使用<code>git diff</code>查看具体区别：</p><p><img src="/passages/Git使用/1573697956849.png" alt="1573697956849"></p><p>使用<code>git add -A</code>将所有改动文件暂存：（详细版本会说“changes to be committed”，并且会以绿色字体列出改动的文件）</p><p><img src="/passages/Git使用/1573698564785.png" alt="1573698564785"></p><p>使用commit命令提交后，再看status</p><p><img src="/passages/Git使用/1573698789058.png" alt="1573698789058"></p><p>提醒你要push代码，将改动同步到远程仓库</p><p>使用<code>git status -s</code>则会什么都不显示</p><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>通常有一些文件，你是不想让git追踪的，即你怎么改变都是在本地改变的，不需要git干预（因为默认情况下git会把<strong>.git</strong>所在目录下所有文件都当成潜在客户，即你没有add（追踪），它会缠着你让你追踪）。这时，我们就需要一个新建一个名为<strong>.gitignore</strong>的隐藏文件，告诉git，哪些文件不需要追踪。</p><p>文件的书写格式如下：</p><ul><li>空行或以<strong>#</strong>开头（注释）的行会被忽略</li><li>支持部分<strong>正则表达式</strong></li><li>开头加<strong>/</strong>避免递归</li><li>末尾加<strong>/</strong>指定一个目录</li><li>开头加<strong>!</strong>表示否定</li></ul><p>示例的.gitignore文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ignore all .a files</span><br><span class="line">*.a</span><br><span class="line"># but do track lib.a, even though you&apos;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># ignore all files in any directory named build</span><br><span class="line">build/</span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># ignore all .pdf files in the doc/ directory and any of its subdirectories</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p>以上的描述已经很清楚了，主要就是通配符<strong>*</strong>的使用。</p><h4 id="查看暂存-未暂存的文件"><a href="#查看暂存-未暂存的文件" class="headerlink" title="查看暂存/未暂存的文件"></a>查看暂存/未暂存的文件</h4><p>使用<code>git diff</code>。</p><p>如果改动了某个文件，使用diff可以查看<strong>已暂存/未暂存</strong>的文件，已暂存的文件下次commit将会被提交。</p><p>使用diff时可以加上一个参数：<code>git diff --cached</code>或者<code>git status --staged</code>，没什么区别。</p><p>还可以在其它外部工具（不是terminal）中使用git diff，使用<code>git difftool --tool-help</code>查看本机可以用的比较工具。</p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>使用<code>git commit</code>。</p><p>输入此命令会自动打开git bash配置的默认编辑器（未设置是vim），你可以写上本次提交的描述；</p><p>或者，直接<code>git commit -m &quot;message&quot;</code>加上描述；</p><p>如果不想每次commit前都要暂存（使用<code>git add</code>），可以在提交时加上<strong>-a</strong>参数，即<code>git commit -a</code>。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>在git上删除一个文件，你得首先让git不要再追踪（track）它，然后提交。使用<code>git rm</code>就可以做到，并且也会将它从电脑磁盘上删除。如果直接使用<strong>rm</strong>，会提示：changes not staged for commit</p><p>使用<code>git rm</code>，按下回车会反馈：删除了哪个文件。再查看status，会记录之前的操作–删除文件，并等待提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm <span class="string">'PROJECTS.md'</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">  </span><br><span class="line">    deleted: PROJECTS.md</span><br></pre></td></tr></table></figure><p>删除以后，下次提交git就不会管它了。如果已经修改了这个文件或者已经把它add到了暂存区，删除时要使用<strong>- f</strong>强制删除，这是为了防止意外删除，因为删除了无法恢复。</p><p>还有一种情况，你只想把文件从暂存区删除，但是保留在你的电脑磁盘上。这就好比你忘了在.gitignore中忽略这个文件。删除时添加<strong>–cached</strong>参数，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p>在命令中也可以使用通配符*，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm <span class="built_in">log</span>/\*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>上面命令将删除所有log/目录下的.log文件（好像是遇到*需要处理成转义字符）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm \*~</span><br></pre></td></tr></table></figure><p>上面命令会删除所有以~结尾的文件</p><h4 id="移动文件-重命名"><a href="#移动文件-重命名" class="headerlink" title="移动文件/重命名"></a>移动文件/重命名</h4><p>不像其他的VCS（版本控制）系统，Git不会显式地追踪移动操作，即你在磁盘目录上对文件移动不会被记录到git的状态中。【但是！】Git提供了mv命令，如果使用mv命令进行移动，则会被记录在status中。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README.md README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line">  </span><br><span class="line">    renamed: README.md -&gt; README</span><br></pre></td></tr></table></figure><p>重命名操作被Git记录了下来，此操作相当于以下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>即，如果仅仅是在磁盘上对文件进行移动，完了还要告诉Git，将暂存区的旧文件移除，新文件暂存。</p><p>这样看来，使用Git提供的移动/重命名操作，还是很方便的（<strong>或者直接在文件夹里修改名字就好了，Git不会记录</strong>）。</p><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>使用<code>git log</code>命令查看提交历史记录。</p><h1 id="廖雪峰"><a href="#廖雪峰" class="headerlink" title="###############廖雪峰"></a>###############廖雪峰</h1><p><strong>git撤销回退版本和切换分支的命令都可以是<code>git checkout</code></strong>，但切换分支还可以用<strong><code>git switch</code></strong>，所以最好用switch切换分支以区分。</p><p><strong>git合并时默认使用fast forward模式</strong></p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Git%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你好</title>
      <link>https://gitplayb.github.io/passages/Hello/</link>
      <guid>https://gitplayb.github.io/passages/Hello/</guid>
      <pubDate>Sun, 22 Dec 2019 08:19:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;遇到认识的人，你会怎么打招呼呢&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>遇到认识的人，你会怎么打招呼呢</p><hr><a id="more"></a><p>当我遇到比较熟或者关系比较好的朋友，我会说<strong>嗨~</strong>或者<strong>嘿~</strong>，不知道是不是因为看美剧，我觉得Hey/Hi是在我感觉更ease的时候才会这么说，遇到不太熟或者只是一般的关系我则会说哈喽，这样，两个字会不会比一个字显得更亲热些？</p><h2 id="明天，你好"><a href="#明天，你好" class="headerlink" title="明天，你好"></a>明天，你好</h2><p>就是突然想起了这首歌。小时候听好像没什么特别的感觉，因为不知道长大是什么样子的，听女主唱清晰的咬字总感觉她像是在对一个老朋友诉说似的。</p><p>现在听起来，歌词很真挚，情感也很到位。听着这个有一种又想哭又想笑的感觉。相比探索地理上的未知，就像下面说的你好，世界，我觉得探索时间上的未知才是更需要勇气的。因为如果我们想要，总可以踏出自己的生活圈子，往更大的世界走走，即使不能行万里路，但我们总还是拥有自由的。而时间却不同，无论我们有多大能力，回到过去或未来也只是科幻电影里老生常谈的素材而已。所以我觉得，真正的未知便是明天，而幸运的是未来和现今不是断层的，我们是可以一笔一笔的勾勒出未来理想生活的蓝图的。</p><p>对明天说声你好吧，没有什么可以惧怕的。</p><h2 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h2><blockquote><p>当那天我郑重其事地打开电脑，在电脑上输入那一行字，我就觉得，我的世界从此会变得不一样了！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello, world&quot;);</span><br></pre></td></tr></table></figure><p>可能，程序员们不太擅长和这个世界打交道，于是说你好，世界。这样外人听起来可能有些生疏，但是他们自己却觉得说哈喽显得更熟络一些。管他的，他们开心就好。</p><p>而我要说嗨，世界。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Hello/#disqus_thread</comments>
    </item>
    
    <item>
      <title>求知欲和表达欲</title>
      <link>https://gitplayb.github.io/passages/Desires/</link>
      <guid>https://gitplayb.github.io/passages/Desires/</guid>
      <pubDate>Sat, 21 Dec 2019 17:15:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;生而为人，没有欲望是不太可能的。即使是看破了红尘、不食人间烟火的得道高僧，他难道不想做一个好和尚吗？可能存在只是混口饭吃的和尚，但至少他有活下去的欲望，否则他为什么要一日三餐呢…&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>生而为人，没有欲望是不太可能的。即使是看破了红尘、不食人间烟火的得道高僧，他难道不想做一个好和尚吗？可能存在只是混口饭吃的和尚，但至少他有活下去的欲望，否则他为什么要一日三餐呢…</p><a id="more"></a><h2 id="求知欲"><a href="#求知欲" class="headerlink" title="求知欲"></a>求知欲</h2><p>人和动物的区别，从刻板上说，是<em>会制造和使用工具</em>。但是我认为，语言的创造与使用使人类的思想得到了传播并发展，这才是我们作为一种比较特别的生物存在于这星球的立足点。没有语言，我们可能无异于皮皮虾。</p><h3 id="生而为人"><a href="#生而为人" class="headerlink" title="生而为人"></a>生而为人</h3><p>我们从出生开始，只是一个脑袋里充满着很强烈的探索欲望的生命体，经过父母、老师、和身边同龄人或者比我们经历的更多的伙伴们的相处，我们见到的越来越多，了解的越来越多。我们逐渐学到了这个世界的运转规则（<em>How the world runs</em>），学到了我们应该如何与他人相处（<em>How to get along</em>），以及我们在世界上觉得最重要的东西（人生观、世界观、价值观），学会了思考（<em>What matters</em>）等等。就像一台需要不断更新新的内容并删除旧的没有价值的内容的计算机，我们小脑袋的容量也是有限的，可不是花点钱就能升级更大RAM的。于是，我们从0，到呈指数型爆炸的知识增长阶段（求学阶段），到高速接收信息的稳定阶段（工作前期），到生活稳定下来转换人生角色感受生活另一面的日常阶段，我们的一生似乎已经要转完一个圈。然而在转圈的过程中，求知一直伴随我们左右，无论主动或是被动。</p><h3 id="工具制造"><a href="#工具制造" class="headerlink" title="工具制造"></a>工具制造</h3><p>人类不断发展，有一部分原因是人类善于思考。人类在想方设法地让自己的生活变得更加美好，无论是出于什么理由。</p><p>人类想制造工具的想法让我们积累了越来越多的知识，也让我们越来越乐于探索新的知识。每个人出生时都是好奇宝宝，不过随着时间的流逝，一些人专注于一些方面，随之对其他的不太感兴趣，也没有探索欲了。</p><h3 id="现代社会"><a href="#现代社会" class="headerlink" title="现代社会"></a>现代社会</h3><p>第三次工业革命——信息技术革命的到来与发展，使得人类社会像是坐上了一列加速度在不断增长的高速列车上。信息技术革命带来了信息爆炸，或者说是知识爆炸，这对于我们来说既是个好事情，又是个不那么好的事情（说什么话都两面说，这样比较有哲学家的范）。</p><p>好的方面，人类社会可以快速发展，就像近些年逐渐攀升的高铁速度一样，人们也觉得自己所处的时代是最好的时代，似乎想干什么就能干什么；不太好的一面，就是人类让自己处于一个不停运转的传送带上，想想吧，你是一个手无缚鸡之力的婴儿，被人放到传送带上后一走了之，你不担心自己的目的地是万丈深渊吗？因此我们需要不断学习，即使我们没有很理想的学习速度，但是至少要有危机意识。就像篮球场上的，即使你没有姚明的身高，但你的意识到了，一个后卫也可以让对方中锋无力反击。</p><h2 id="表达欲"><a href="#表达欲" class="headerlink" title="表达欲"></a>表达欲</h2><p>每个人都有表达自己的欲望。这里说的表达自己，是指希望自己的观点能够被他人听到，无论是否被理解。归根到底，人类是社会性动物，人不可能离开社会的群体而独自生活。</p><p>就像那个实验中体现的（好像是把一个人关进监狱，给他很多钱，但是让他待在一个小黑屋里，给他提供充足的食物和生活下去的必需品，但是不让他离开房间半步，同时不能和任何人接触，到最后好像疯了？？），虽然也有反例（比如<em>鲁滨逊漂流记</em>，<em>月亮与六便士</em>），鲁滨逊是因为意外，思特里克兰德则是因为想要追寻理想，喜欢画画过了头。他们并不是由于讨厌和这个社会相处而逃离。</p><p>那些小说中的人物在现实社会中出现的机率还是蛮小的，现实社会中类似的有<em>卢梭</em>，还有中国古代一些喜欢隐居的文人墨客如<em>陶渊明</em>等。但是他们实际上只是想逃离现实生活中的不满部分（如卢梭是因为喜欢自然，而且他虽然住在一栋无人光临的小屋中，但他有时候还是会回到岸上和人接触的，比如建造房子时需要购买材料；陶渊明隐居则是因为看够了官场争斗，并且自己喜欢田园生活），而且，这些人也都是有朋友的，他们只是觉得在复杂的社会里生活，不如追寻自己的内心，并不是讨厌和人相处。</p><h3 id="表达OR倾听？"><a href="#表达OR倾听？" class="headerlink" title="表达OR倾听？"></a>表达OR倾听？</h3><p>人类喜欢表达胜于喜欢倾听。</p><p>所以说，能遇到一个好好听你说话的人，就好好对待ta吧。就像那首歌里唱的<em>全世界谁倾听你</em>，正所谓知音难寻。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Desires/#disqus_thread</comments>
    </item>
    
    <item>
      <title>梦幻岛</title>
      <link>https://gitplayb.github.io/passages/Dreamland/</link>
      <guid>https://gitplayb.github.io/passages/Dreamland/</guid>
      <pubDate>Sun, 15 Dec 2019 16:07:09 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;每个人心中都有一座梦幻岛。&lt;/p&gt;
&lt;p&gt;希望有一天，你能带我到你家的小岛上去踏青。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>每个人心中都有一座梦幻岛。</p><p>希望有一天，你能带我到你家的小岛上去踏青。</p></blockquote><a id="more"></a><p>分享一首歌，大学校园里走在长桥上听到第一秒就爱不释👂的一首歌。</p><p>歌曲名叫<em>Island in the sun</em>，由美国独立摇滚乐队<a href="https://baike.baidu.com/item/weezer/3589565?fr=aladdin" target="_blank" rel="noopener">Weezer</a>演唱。</p>    <div id="aplayer-DElgcgEI" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="20705824" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><p>歌词大意就是，我们可以在一个小岛上放空自己什么也不想，只有快乐在我们左右。</p><blockquote><p>When you’re on a holiday,</p><p>You can’t find the words to say.</p><p>All the things that come to you,</p><p>And I wanna feel it too.</p><p>On an island in the sun,</p><p>We’ll be playing and having fun.</p><p>And it makes me feel so fine</p><p>I can’t control my brain</p><hr><p>When you’re on a golden sea,</p><p>You don’t need no memory.</p><p>Just a place to call your own,</p><p>As we drift into the zone.</p><p>On an island in the sun,</p><p>We’ll be playing and having fun.</p><p>And it makes me feel so fine</p><p>I can’t control my brain</p><hr><p>We’ll run away together</p><p>We’ll spend some time forever</p><p>We’ll never feel bad anymore</p><p>Hip hip</p><p>Hip hip</p><p>Hip hip</p></blockquote><p>简陋地翻译一下：</p><blockquote><p>当你在度假的时候，你什么话也不想说</p><p>你经历的所有事情，我也想与你一起感受</p><p>在一个阳光下的小岛上，我们将开心地玩乐</p><p>这让我觉得如此美妙以至于无法控制我的大脑</p><p>当你在金色的大海上，什么事情都不需要记起</p><p>只需要找回真正的自己，在我们漂入大海的地方</p><p>我们将一起逃离无论什么鬼地方</p><p>我们将一起度过一段美好时光</p><p>我们再也不会感到很糟糕</p><p>嘿 嘿</p><p>嘿 嘿</p></blockquote>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Dreamland/#disqus_thread</comments>
    </item>
    
    <item>
      <title>那年今日</title>
      <link>https://gitplayb.github.io/passages/%E9%82%A3%E5%B9%B4%E4%BB%8A%E6%97%A5/</link>
      <guid>https://gitplayb.github.io/passages/%E9%82%A3%E5%B9%B4%E4%BB%8A%E6%97%A5/</guid>
      <pubDate>Fri, 15 Nov 2019 15:52:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;写在父亲生日&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>写在父亲生日<br><a id="more"></a></p><h2 id="第一堂课"><a href="#第一堂课" class="headerlink" title="第一堂课"></a>第一堂课</h2><p>我们的缘分，从许多年前我对你哭而你对我笑那一刻开始。不知道什么原因，我降临在一块你也不怎么熟悉的土地上，开始了和你的相爱相杀之旅。</p><p>我的记忆最早开始于上学之前的那段时间。当我看到和我差不多大的小朋友都蹦蹦跳跳地去学校的时候，我说：<em>”我也要上学！“</em>。你说，<em>你和别的小朋友不同，你得再等一等</em>。当时还不知道为什么下半年出生就要比别人上学晚。于是我每天背着心爱的小书包走来走去，想象我在学校里上课的样子。直到后来，我终于如愿以偿，在学校的第一堂课我永远也不会忘记。第一节课上，老师带我们玩了丢手绢，我还依稀记得：</p><blockquote><p>丢啊丢啊丢手绢</p><p>轻轻地放在小朋友的后面</p><p>大家不要告诉他</p><p>快点快点抓住他</p><p>快点快点抓住他</p></blockquote><p>当时觉得上学真好呀，还能做游戏。第一节课下了，我把书包收拾好，准备到和你约定好的地方，等你来接我。结果，左等右等没有等到你，我非常诧异。于是在附近转了转，好像也没什么人，心想<em>怎么放学了大家都不回家吗</em>。我又走回班里才发现，原来一上午要上四节课的啊。于是心有不甘地回了教室，感叹一句<em>”还好刚才没有在那里傻傻等半天“</em>。</p><h2 id="自行车"><a href="#自行车" class="headerlink" title="自行车"></a>自行车</h2><p>上学路程比较远，所以你说，给你买辆自行车吧。于是，在某个炎炎的下午，在摔过了无数次（也没几次）跤之后，终于算是勉强学会了。当时学会了，我以为我就要骑着练习的那辆车去上学呢。结果，某个下午你又给我一个惊喜–<em>”看看，新买的自行车怎么样“</em>。后来长大以后，看到这辆车真的觉得好小好可爱啊。不难想象当时我激动的心情，简直要跳起来了。熟能生巧，于是没过几天，经过了在漫长通勤路上的锤炼，我骑车的技术变得非常熟练：单手、空手、站起来、自己带自己…小孩的胆子你真的无法揣测。</p><h2 id="辅导书"><a href="#辅导书" class="headerlink" title="辅导书"></a>辅导书</h2><p>从小到大，我基本没有用过辅导书，因为我觉得，课本上的内容已经足够了，成绩也证明了一切。然而，小时候的那本礼物，我还是记忆尤其深刻。</p><p>你从外地回来，给我带了一本数学的辅导资料。我也不知道你是怎么知道我需要这些辅导材料的，当时上课学的内容也没有和你说过。可能是在书店里看到，然后问的店员吧（我猜）。于是，当你把这本书拿回来说是给我的时候，我非常惊讶，当然也很开心，因为买到的刚好是我们当时学的那一本。但是，由于我实在是没有看辅导书的习惯（直到高中才有），所以那本书荒废了很久。想到这，还是觉得有些遗憾（看了说不定我高中的数学就不用这么挣扎了）。</p><h2 id="第一个🏀"><a href="#第一个🏀" class="headerlink" title="第一个🏀"></a>第一个🏀</h2><p>初中时，因为一场篮球比赛的临时替补（当时算是班里高的），我爱上了打篮球。在那个处处散发着荷尔蒙的年纪，我这一爱还一发不可收。于是我开始了攻心战术，<em>”爸，我想要买个篮球，行吗，行不行嘛…“</em>。因为成绩还不错，而且也不算太贵吧（虽然和小时候的自行车差不多了），于是你答应了。和你一起去店里挑篮球的那个下午，阳光明媚。当拿着气打的足足的篮球出来的时候，你对我说，<em>”高兴吧“</em>，我也嘿嘿一笑。</p><p>后来你说，你年轻时也爱打篮球，还会三步上篮呢。于是我看你在我面前表演三步上篮，虽然动作没有那么敏捷了，但还是很有范儿呢！</p><h2 id="颁奖典礼"><a href="#颁奖典礼" class="headerlink" title="颁奖典礼"></a>颁奖典礼</h2><p>即使不说，每个父母还是有<em>望子成龙，望女成凤</em>的期盼的。每当我因为一些小事情需要被表扬时，站在台上或台下的你总是洋溢出喜不自禁的笑容。</p><p>多年以后，不知道我能做出天大的好事情，才能看到当年你脸上那，自豪而又温暖的笑容呢。</p><h2 id="写作文"><a href="#写作文" class="headerlink" title="写作文"></a>写作文</h2><p>很小的时候，因为读书少，所以不怎么会写作文。还记得第一篇作文被老师写了很多评语，然而并不是表扬我的，而是指出哪些地方应该怎么写。</p><p>我知道你喜欢文字，于是后来问你，作文应该怎么写。你却笑着说，<em>写作文有什么难的，你就把你心里想的写出来不就得了</em>。可是，我心里没有什么想法啊-_-。然后你又给我指了条路，多看看书，要写的有条理而且充满感情。于是，我后来写的作文还是不知道写什么。</p><h2 id="一周一次📞"><a href="#一周一次📞" class="headerlink" title="一周一次📞"></a>一周一次📞</h2><p>后来我去了更远的地方上学，你说要来送我，可是阴差阳错没有来到。某一段时间，可能由于心情不好，很少给家里打电话，直到某一次你们打了半天电话也没通，很担心我发生了什么事。等到我发现然后打过去，你们也没有怪我。于是我说，<em>以后要每周给你们打一次电话</em>。记得开始打电话时还是可以说很多话，但是后来就不知道说些什么，感觉每天都是那些重复的简单的问候。有时可能因为事情多拖到了很晚或者后一天才打，匆匆说几句话就挂掉。现在想想，其实你们也没有想说多少话，只是想告诉我家里很好不用担心，然后知道我在这边也过得很好，就够了。</p><h2 id="你的梦"><a href="#你的梦" class="headerlink" title="你的梦"></a>你的梦</h2><blockquote><p>曾梦想仗剑走天涯，看一看世间的繁华</p><p>年少的心总有些轻狂，如今你四海为家</p></blockquote><p>你曾经梦想着，穿上抖擞的迷彩服，在共和国的土地守卫疆土；</p><p>你曾经也梦想着，在方寸讲台上，将自己的知识与见地，传递领悟。</p><p>只是你早早地担上了生活的担子，在奔波与疲累间逐渐忘却你的梦。</p><p>其实并没有忘记，你只是把它放在了心中的那块柔软的角落，珍藏。</p><h2 id="老小孩"><a href="#老小孩" class="headerlink" title="老小孩"></a>老小孩</h2><p>你在我眼中，一直是个长不大的老小孩。你很爱笑，你也总能用你的笑容感染我。</p><p>然而今天，电话里听到你的声音，变得又沙哑厚实了一些，我不知道是该高兴还是心酸。但是无论如何，我还是很高兴，你还是那个尽管有时和我聊天会尴尬（主要是我的原因），但还是没话找话说的我记忆中的父亲。</p><h2 id="还有呢"><a href="#还有呢" class="headerlink" title="还有呢"></a>还有呢</h2><p>今晚本是个寻常的夜晚，只是耳机里播放到了刀郎的西海情歌，我听到的却没有情歌，只有西海。刀郎的声音总能让我想到家乡，想起那个等着妈妈做好饭，电视机上播放着<em>喀什噶尔胡杨</em>的画面的，美丽的下午。</p><hr><p>魏则西事件已经发生了很久但只是听说没有细看，今天看到了他父母为他发的最后一条知乎，还有他生前痛苦挣扎之际发的感谢帮助他的网友的话，再一次对生命感到敬畏了，生命的脆弱经不起我们折腾，每一个健康活着的人都应该感到荣幸。</p><hr><blockquote><p>好好活，就是做很多很多有意义的事儿</p></blockquote><p><em>士兵突击</em>，是第一部让我看哭的电视剧，忘不了三多的这句话。</p><hr><p>以上。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E9%82%A3%E5%B9%B4%E4%BB%8A%E6%97%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git多账号配置</title>
      <link>https://gitplayb.github.io/passages/Git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</link>
      <guid>https://gitplayb.github.io/passages/Git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Sat, 28 Sep 2019 06:26:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;有时候我们需要在一台电脑上配置多个Git账号（如公司一个、自己一个），道理还是一样，只是稍微麻烦一点。在这里记录一下操作过程。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有时候我们需要在一台电脑上配置多个Git账号（如公司一个、自己一个），道理还是一样，只是稍微麻烦一点。在这里记录一下操作过程。</p><a id="more"></a><h2 id="单账号"><a href="#单账号" class="headerlink" title="单账号"></a>单账号</h2><h3 id="SSH-Git的原理"><a href="#SSH-Git的原理" class="headerlink" title="SSH/Git的原理"></a>SSH/Git的原理</h3><p>Git使用HTTPS/SSH协议，如果使用https，则每次提交代码时需要输入用户名和密码；如果用ssh，则每次无需输入验证，由Git服务器进行验证。其中，公钥由Git服务器保存，自己本地保存的是私钥，验证时，服务器将公钥与你本地的私钥进行匹配。SSH是非对称加密的一个典型例子。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p><strong>生成一对公/私钥</strong></p><p>在本地Git客户端输入命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"邮箱地址"</span></span><br></pre></td></tr></table></figure></li></ol><p>​        ssh-keygen命令生成一对公/私钥，-t指定秘钥类型为rsa方式，-C为comment（注释）</p><ol start="2"><li><p><strong>将公钥保存到服务器</strong></p><p>将本地生成的公钥（<strong>.pub</strong>）复制下来，粘贴到Git服务器（如GitHub）<strong>New SSH key</strong>的地方，保存为一个可以区分的名字就好了</p></li><li><p><strong>测试连接</strong></p><p>在Git客户端测试是否能连接上Git服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>若看到这样的内容，代表连接成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Hi yourname! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>安装过程中会提示你输入<strong>passphrase</strong>，即口令。正常情况下（为了方便）可以不用输入，直接回车；输入的话就是为了防止别人操作你的电脑，也可以登录你的Git。输入过程中字符是不显示的（类似于web表单页面输入密码），出于安全考虑。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>来到公司后，由于公司这边用的是GitLab，于是配置了GitLab的SSH。配置了公钥和私钥后可以免密登录，很方便。但是，想要自己新建项目练习的时候发现，公司给的账号是<strong>LDAP账号</strong>，即<strong>域账号</strong>。由于域账号有权限的限制，所以自己什么也做不了，只能新建snippet（代码片段）。所以，想用GitHub来做项目练习。</p><p>之前自己有一个GitHub账号，也在自己的电脑上配置了SSH秘钥，即自己电脑可以和GitHub的服务器连上，进行本地代码库的一些操作。于是想在公司电脑上也配置一下秘钥就行了。</p><p>但是问题来了——</p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>第一次进行SSH配置时的配置文件在目录<strong><em>$USER/Administrator/.ssh</em></strong>下，包括<strong>id_rsa（私钥）和id_rsa.pub（公钥）</strong>。我如果再配置一个SSH连接，秘钥怎么命名呢？</p><p>很自然地想到，可以命名为：<strong>id_rsa_github和id_rsa_github.pub</strong>。但是Git要怎么识别呢？</p><p>于是在网上搜索一番，发现Git是可以配置多个账号的。</p><h3 id="1-分别生成公-私钥"><a href="#1-分别生成公-私钥" class="headerlink" title="1. 分别生成公/私钥"></a>1. 分别生成公/私钥</h3><p>生成公/私钥的过程和配置一个SSH连接的过程是一样的，同样的步骤✖2就好啦。</p><p>需要把不同的连接的公/私钥的名字区分开，并与<em>config</em>里的名字对应，这样Git服务器才知道到哪去找对应的秘钥。</p><h3 id="2-新建config"><a href="#2-新建config" class="headerlink" title="2. 新建config"></a>2. 新建config</h3><p>在<strong>.ssh</strong>目录下，新建一个配置文件<strong>config（无后缀）</strong>，用于对不同账号的主机进行配置。假如我们想同时配置一个GitLab的账号，一个GitHub的账号，那么我们需要做的就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host gitlab.com</span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    User yourname@yourhost.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile $USER/Administrator/.ssh/id_rsa_gitlab</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User yourname@yourhost.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile $USER/Administrator/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><p>可以看到，我们指定了验证身份时用到的是publickey（存放在Git服务器的公钥），并且匹配它的私钥文件是<strong>id_rsa_name</strong>，只要可以通过<strong>name</strong>来区分不同的账号即可。</p><p><strong>User</strong>是你的账号邮箱，也可以与你注册Git平台的邮箱不一致，只是你每次提交代码时的一个身份标记。</p><h3 id="3-将私钥添加到ssh-agent"><a href="#3-将私钥添加到ssh-agent" class="headerlink" title="3. 将私钥添加到ssh-agent"></a>3. 将私钥添加到ssh-agent</h3><p>有时，在本地配置好后还是无法克隆项目（<code>permission denied</code>）怎么办？这时候，还需要把自己的私钥添加到<strong>ssh-agent</strong></p><ol><li><p>在Git中输入<code>eval $(ssh-agent -s)</code>首先寻找一个ssh代理；</p></li><li><p>将自己的私钥告诉代理：<code>ssh-add ~/.ssh/id_rsa</code>。表示将主目录下的私钥<em>id_rsa</em>加入ssh连接。</p></li></ol><p>之后再打开Git，就不需要输入密码啦！Git的操作（clone等等）也都可以在本地进行了。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>爵士俱乐部一人游</title>
      <link>https://gitplayb.github.io/passages/%E7%88%B5%E5%A3%AB%E4%BF%B1%E4%B9%90%E9%83%A8%E4%B8%80%E4%BA%BA%E6%B8%B8/</link>
      <guid>https://gitplayb.github.io/passages/%E7%88%B5%E5%A3%AB%E4%BF%B1%E4%B9%90%E9%83%A8%E4%B8%80%E4%BA%BA%E6%B8%B8/</guid>
      <pubDate>Sun, 15 Sep 2019 16:59:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;万万没想到，自己竟然会在中秋节去听一场爵士乐的现场。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>万万没想到，自己竟然会在中秋节去听一场爵士乐的现场。</p><a id="more"></a><h2 id="阴差阳错"><a href="#阴差阳错" class="headerlink" title="阴差阳错"></a>阴差阳错</h2><p>原本计划和朋友去<strong>深圳湾公园</strong>散散步的，结果天公不作美，刚吃完饭出来，天就开始阴沉沉地哭诉了起来。就在我们还纠结是要冒着小雨去那里还是原路返回时，雨似乎帮我们做了决定——从小雨瞬间变成了大雨。于是我们只好找个商场躲了起来。</p><p>就在商场闲得无聊的时候，我想在美团上看看有没有好点的清吧，想去坐坐。看了一些，也有一些合适的，想叫小伙伴一起去，他说算了吧，我想自己去可能也比较无聊，就打算放弃。可是浏览的过程中，发现有些是音乐主题的，突然来了兴趣，于是直接搜索<em>live house</em>，没想到附近还真有一个。然后赶紧点开看了看评论，还不错，关键是有人拍了视频，8月30日的现场表演嘉宾竟然有<code>顾忠山</code>！他可是我知道的为数不多的本土爵士音乐家。而且还有朋友听过他的现场，并给我推荐过。这让我一时心潮澎湃啊，顿时觉得这家店还是蛮有逼格的哈哈哈。评论中有的说蛇口的这家是深圳唯一的一家Jazz Club，心里不敢相信，觉得深圳这么大的城市应该挺多这样的<code>吧</code>。不过，就我看来也不是没有可能的。深圳可能忙着发展经济和技术去了，像上海那样的城市可能多点（主要是国内欣赏这个的比较少，而且专门玩这个的音乐家也很稀缺，没有环境和氛围）。</p><p>于是，打了下电话咨询了一下，waiter帮我预约了吧台的座位，就开开心心地过去了。</p><h2 id="首个Live-house"><a href="#首个Live-house" class="headerlink" title="首个Live house"></a>首个Live house</h2><p>我原本打算坐公交过去，查了下路线发现，公交站离我那里有大概总路线的1/3，就直接散步走过去了。当我走到那家俱乐部所在的小巷时，隐约已经传出了一些音乐声。门口摆放着一个double bass（爵士乐的经典四大件之一），从门口瞧了一眼，店面不大，是那种比较cozy的小清吧。</p><p>刚到那坐下，还没到表演时间，里面的人们在喝酒聊天，表演场地已经收拾好了，房子内的音乐声是从音箱里传出来的，waiter在忙着为客人调酒。进去以后看到了菜单，第一页写着一条<em>“每一位客人至少点一杯饮料“</em>，我觉得这也很正常，毕竟有乐队现场演出。点了一杯威士忌，因为上面有很多种类，每一类下面又有很多不同的”代号“，所以看了一下大概价格，就随便点了一个。等waiter端上来我喝了第一口，有点后悔。忘了威士忌是烈酒，赶紧问了下度数，他说是40°，这才安心了一点。不过刚好我要的是加冰的，随着冰块的融化，酒变得越来越淡，也容易入口多了。</p><h2 id="爵士乐队"><a href="#爵士乐队" class="headerlink" title="爵士乐队"></a>爵士乐队</h2><p>当晚的爵士乐队好像是常驻在那里表演的，主要的键盘、吉他、贝斯手都没换，鼓手倒是换了好几个。从刚开始表演，到后面的<code>jam session</code>，一共有三个鼓手。每个乐手演奏的都挺投入，但是我还是最喜欢吉他手，因为f孔空心吉他的<strong>Sweet tone</strong>（甜美的音色）是最让我无法抗拒的！幸运的是，我的手机还坚持下来（不时清一下内存）拍了很多照片，也录了一些视频，当然最后的jam session因为太长就只录了音。</p><h2 id="日本朋友"><a href="#日本朋友" class="headerlink" title="日本朋友"></a>日本朋友</h2><p>原本没想到会有这么多日本的朋友来这里。一进去就看到了几个金发碧眼的欧美白人，后来发现坐在吧台的，我旁边一串日本友人。当晚去的人还是比较多的，还有几个是站在门口附近听的，开始就看到他们随着音乐的律动晃动身体，觉得大家还真是挺享受音乐的（抖就完事了）。</p><h2 id="一些图片"><a href="#一些图片" class="headerlink" title="一些图片"></a>一些图片</h2><p><img src="/passages/爵士俱乐部一人游/Meeting-Jazz.jpg" alt="Meeting-Jazz" title="Meeting-Jazz"><br><img src="/passages/爵士俱乐部一人游/drinks.jpg" alt="吧台" title="吧台"><br><img src="/passages/爵士俱乐部一人游/band.jpg" alt="乐队" title="乐队"></p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E7%88%B5%E5%A3%AB%E4%BF%B1%E4%B9%90%E9%83%A8%E4%B8%80%E4%BA%BA%E6%B8%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>新生活二三事</title>
      <link>https://gitplayb.github.io/passages/%E6%96%B0%E7%94%9F%E6%B4%BB%E4%BA%8C%E4%B8%89%E4%BA%8B/</link>
      <guid>https://gitplayb.github.io/passages/%E6%96%B0%E7%94%9F%E6%B4%BB%E4%BA%8C%E4%B8%89%E4%BA%8B/</guid>
      <pubDate>Sun, 08 Sep 2019 12:32:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;入职已经将近一个月了，原本打算一周写一次总结之类的东西，到现在才算是挤出来了第一篇。以后会做到一周一更的🤔&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>入职已经将近一个月了，原本打算一周写一次总结之类的东西，到现在才算是挤出来了第一篇。以后会做到一周一更的🤔<br><a id="more"></a></p><h2 id="初入职场"><a href="#初入职场" class="headerlink" title="初入职场"></a>初入职场</h2><blockquote><p>该来的总会来的，你不可能永远是一个学生</p></blockquote><p>当然，你可以选择<strong>做</strong>一个学生（有句话怎么说的来着，终生学习对吧），毕竟有这么多东西需要学习，无论是专业方面还是你的兴趣方面，或者生活中的方方面面。</p><p>从来时火车上的不确定感，到进入公寓后行李落地的那一刻，我意识到我的新生活就要开始了。</p><p>在培训基地培训的日子过得很漫长，或许是因为每天的生活<em>被安排的满满当当（<del>明明白白</del>）</em>，所以我们每天什么也不想，再加上网络问题，我们唯一的乐趣就是在宿舍里和新同事们聊聊天。小伙伴儿们都是来自各个学校的，大家都挺友好、挺可爱的，因为住在一起的都是一个部门的，所以聊起来也有比较多的话题。在培训基地为我们培训的领导们也都是来自集团各个部门的前辈，而且有很多是“校招大学生”。听了一些领导的极富感染力的演讲后，确实让人心头燃起了一些热火。这期间还做了很多新奇的小（大）游戏，见识到了来自各个学校的伙伴们的聪明才智，也让我们学到了团队合作等。</p><h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><p>第一天到工位以后，发现自己将要待着敲代码的地方环境还是不错的，新配的电脑，舒适的椅子，以及窗外不错的view。了解了自己部门以及小组做的主要业务后，导师说我们要先熟悉一下Spring Boot的使用，以及微服务方面的知识。因此之后的几周一直在看相关的资料与demo项目。</p><p>开始的一天半基本是在安装软件和配置环境中度过的。大部分都可以安装成功，还有一些需要管理员权限。之前用自己的电脑倒没发现管理员权限竟然这么关键，公司这块还是挺严格的。如果安装一些电脑上没有预置的，需要权限的，就需要给help center打电话，请他们来安装。</p><p>和自己在一块办公的还有两个小伙伴，我们上班时间也都一起学习，遇到问题也可以讨论。</p><h2 id="学习成果"><a href="#学习成果" class="headerlink" title="学习成果"></a>学习成果</h2><p>在网上找了一些Spring Boot的学习资料，大略看了其中的内容后，选择了几个比较感兴趣的。目前脑子里留下最多的印象就是<em>Spring Boot为什么好，它怎么做到的自动配置，你可以用它来做微服务开发等等</em>。看了几个简单的小项目后，也对一些常见的注解有了了解。因为没有一本权威的书籍，所以自己在同时看几个相关的，里面也有配套的不同的项目，希望这样自己可以对用Spring Boot开发有一个更全面的认识，在项目的相同处和不同处之中找到一些key point。</p><h2 id="哦，生活"><a href="#哦，生活" class="headerlink" title="哦，生活"></a>哦，生活</h2><p>某天晚上，睡觉前听到了雨声，就突然没了困意，于是想把这“烦人的雨”记录下来，咳咳。</p><blockquote><p><em>夜，</em></p><p><em>像个冒失鬼一样将我包围</em></p><p><em>窗外偷偷飘来一阵雨水</em></p><p><em>速度快到还没被我的耳机捕捉</em></p><p><em>就已经了无踪影</em></p><p><em>你，</em></p><p><em>像个偷心贼一般将我劝退</em></p><p><em>眼前匆匆回放（闪过）的一段影像（倒影）</em></p><p><em>画面模糊到我想要伸手触摸</em></p><p><em>却发现无足重轻</em></p></blockquote>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E6%96%B0%E7%94%9F%E6%B4%BB%E4%BA%8C%E4%B8%89%E4%BA%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>毕业小记</title>
      <link>https://gitplayb.github.io/passages/Graduation/</link>
      <guid>https://gitplayb.github.io/passages/Graduation/</guid>
      <pubDate>Tue, 28 May 2019 08:44:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;[GAME OVER]&lt;/strong&gt;. &lt;em&gt;Do you wanna restart?&lt;/em&gt;————————&lt;code&gt;y or n&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>[GAME OVER]</strong>. <em>Do you wanna restart?</em>————————<code>y or n</code><br><a id="more"></a></p><h2 id="毕业视频"><a href="#毕业视频" class="headerlink" title="毕业视频"></a>毕业视频</h2><video src="videos/graduation.mp4" type="video/mp4" controls="controls" width="100%" height="100%"><br></video>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Graduation/#disqus_thread</comments>
    </item>
    
    <item>
      <title>月亮🌙 or 六便士💴</title>
      <link>https://gitplayb.github.io/passages/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/</link>
      <guid>https://gitplayb.github.io/passages/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/</guid>
      <pubDate>Fri, 24 May 2019 16:11:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;书名颠覆了我的想象，读过后发现，这竟然是一本揭露人性的书。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>书名颠覆了我的想象，读过后发现，这竟然是一本揭露人性的书。</p><a id="more"></a><h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p>月亮和六便士，月亮就像那高高在上遥不可及的理想，六便士便是踩在脚下触手可及的现实生活。现实生活中当然不存在思特里克兰德这样的人，因为他太纯粹了，不通人情世故，不食人间烟火。真正的艺术家往往比普通人更纯粹一些，因为只有心灵足够纯粹，才能将自己的才华完全施展到艺术创作当中。</p><h2 id="喜欢的句子"><a href="#喜欢的句子" class="headerlink" title="喜欢的句子"></a>喜欢的句子</h2><blockquote><p>我不记得是谁曾经建议过，为了使灵魂宁静，一个人每天要做两件他不喜欢的事。说这句话的人是个聪明人，我也一直在一丝不苟地按照这条格言行事：因为我每天早上都起床，每天也都上床睡觉</p></blockquote><blockquote><p>“为什么讨人喜欢的女人总是嫁给蠢物啊？”</p><p>“因为有脑子的男人是不娶讨人喜欢的女人的。”</p></blockquote><blockquote><p>这种安详宁静的快乐好像有一种叫我惊惧不安的东西。我的心渴望一种更加惊险的生活。只要在我的生活中能有变迁——变迁和无法预见的刺激，我是准备踏上怪石嶙峋的山崖，奔赴暗礁满布的海滩的。</p></blockquote><blockquote><p>我告诉你我必须画画儿。我由不了我自己。一个人要是跌进水里，他游泳游得好不好是无关紧要的，反正他得挣扎出去，不然就得淹死。</p></blockquote><blockquote><p>只有诗人同圣徒才能坚信，在沥青路面上辛勤浇水会培植出百合花来。</p></blockquote><p>一个是极强的浪漫幻想力，一个是虔诚的态度。</p><blockquote><p>为什么你认为美——世界上最宝贵的财富——会同沙滩上的石头一样，一个漫不经心的过路人随随便便地就能够捡起来？美是一种美妙、奇异的东西，艺术家只有通过灵魂的痛苦折磨才能从宇宙的混沌中塑造出来。在美被创造出以后，它也不是为了叫每个人都能认出来的。要想认识它，一个人必须重复艺术家经历过的一番冒险。他唱给你的是一个美的旋律，要是想在自己心里重新听一遍就必须有知识、有敏锐的感觉和想象力。</p></blockquote><blockquote><p>大多数女人都把这种反应当作爱情了。这是一种对任何一个人都可能产生的被动的感情，正像藤曼可以攀附在随便哪株树上一样。因为这种感情可以叫一个女孩子嫁给任何一个需要她的男人，相信日久天长便会对这个人产生爱情，所以世俗的见解便断定了它的力量。但是说到底，这种感情是什么呢？它只不过是对有保障的生活的满足，对拥有家资的骄傲，对有人需要自己沾沾自喜，和对建立起自己的家庭洋洋得意而已；女人们禀性善良、喜爱虚荣，因此便认为这种感情极富于精神价值。</p></blockquote><blockquote><p>估量大家都知道，一旦感情激动起来，一个人会很自然地玩弄起文学辞藻来的。</p></blockquote><blockquote><p>尽管也有很少数男人把爱情当作世界上的头等大事，但这些人常常是一些索然寡味的人；即便对爱情感到无限兴趣的女人，对这类男子也不太看得起。女人会被这样的男人吸引，会被他们奉承得心花怒放，但是心里却免不了有一种不安的感觉——这些人是一种可怜的生物。</p></blockquote><blockquote><p>我那时还不了解人性多么矛盾，我不知道真挚中含有多少做作，高尚中蕴藏着多少卑鄙，或者，即使在邪恶里也找的着美德。</p></blockquote><blockquote><p>最后，也许我有些罗曼蒂克，我想象出一个解释来，尽管这个解释有些牵强，却是唯一能使我感到满意的。那就是：我怀疑是否在他的灵魂中深深埋藏着某种<strong>创作的欲望</strong>，这种欲望尽管为他的生活环境掩盖着，却一直在毫不留情地膨胀壮大，正像肿瘤在有机组织中不断长大一样，直到最后完全把他控制住，逼得他必须采取行动，毫无反抗能力。</p></blockquote><blockquote><p>感情有理智所根本不能理解的理由</p></blockquote><blockquote><p>在爱这种感情中主要成分是温柔</p></blockquote><blockquote><p>一件衣服，一只狗，一篇布道词，什么东西人们都用“美”来形容。当他们面对面地遇到真正的美时，反而认不出它来了。他们用以遮饰自己毫无价值的思想的虚假夸大使他们的感受力变得迟钝不堪。正如一个假内行有时也会感觉到自己是在无中生有地伪造某件器物的精神价值一样，人们已经失掉了他们用之过滥的赏识能力。</p></blockquote>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【译】Google搜索引擎原理</title>
      <link>https://gitplayb.github.io/passages/Google/</link>
      <guid>https://gitplayb.github.io/passages/Google/</guid>
      <pubDate>Wed, 22 May 2019 17:22:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://www.nonchaos.space/img/google-logo.png&quot; alt=&quot;Google&quot; title=&quot;Google&quot;&gt;&lt;br&gt;试着翻译一篇学术型的&lt;strong&gt;论文&lt;/strong&gt;，学习一下&lt;strong&gt;搜索引擎&lt;/strong&gt;的基本原理。&lt;br&gt;原文在很多平台都有，被引量也是无出其右的了。题目：&lt;a href=&quot;http://xueshu.baidu.com/usercenter/paper/show?paperid=8853f4da478a483cb1827d87b97ee30a&amp;amp;site=xueshu_se&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Anatomy of a Large-Scale Hypertextual Web Search Engine&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="http://www.nonchaos.space/img/google-logo.png" alt="Google" title="Google"><br>试着翻译一篇学术型的<strong>论文</strong>，学习一下<strong>搜索引擎</strong>的基本原理。<br>原文在很多平台都有，被引量也是无出其右的了。题目：<a href="http://xueshu.baidu.com/usercenter/paper/show?paperid=8853f4da478a483cb1827d87b97ee30a&amp;site=xueshu_se" target="_blank" rel="noopener">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a><br><a id="more"></a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文中，我们介绍了<a href="https://www.google.com" target="_blank" rel="noopener">Google</a> ，一个大规模搜索引擎的原型，充分利用了网络中以超文本形式呈现的文档结构。Google的设计目标是能够更高效地爬取并索引网络上的内容，并且搜索结果比现有的系统更好（<em>satisfying</em>）。此搜索引擎原型可以在<a href="https://google.stanford.edu" target="_blank" rel="noopener">斯坦福大学官网</a>  找到（现在已经没有了），其中数据库包含至少2400万个网页的全部文本和链接。在工程上实现这样一个搜索引擎是一项艰巨的任务。搜索引擎需要为成千上万的网页建立索引，而每个页面都包含相当多的条目。搜索引擎每天需要对上千万的查询给出结果。尽管互联网上非常需要有这样大规模的搜索引擎，这方面的学术研究却少之又少。此外，由于技术的发展和网页数量的飞速增加，在今天构建一个网络搜索引擎已经远远不同于三年前了。这篇文章对我们的大型搜索引擎进行了一个深入的描述–是我们目前已知的最详细的描述。除了将传统的搜索技术应用到如此大规模的数据带来的困难外，还涉及到一些新的技术上的挑战，即如何使用超文本中附带的额外信息来产生更好的搜索结果。本文将阐述以下问题的解决方法：如何构建一个实用的、能够充分利用超文本中附加信息的大型系统。同时，我们也关注以下问题：如何高效地处理不可控的超文本内容（即任何人可以发布任何信息）的集合？</p><p><strong>关键词</strong>：万维网；搜索引擎；信息检索；网页排名；Google</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>互联网给信息检索带来了新的挑战。网络上的信息呈爆炸式地增长，在网络研究领域没有经验的用户数量也是与日俱增。人们喜欢使用链接起来的一个个网站（<em>link graph</em>）来进行网上冲浪，通常从一些比较好的由人工维护的索引或者搜索引擎（如<a href="https://www.yahoo.com" target="_blank" rel="noopener">Yahoo！</a> ）开始。人工维护的网站列表清单能够很好的覆盖一些流行的主题，但是从另一方面来说其选定的内容也很主观，且很难构建和维护，想要改善速度也很慢，并且不能覆盖全部的（包括一些圈内人[esoteric]的）主题。使用关键字匹配的自动化搜索引擎的搜索结果的相关程度又不能让人满意。更糟糕的是，一些广告商为了吸引用户的注意，常常采取一些措施来误导自动化的搜索引擎。我们构建的大型搜索引擎解决了现存系统的这些问题。它充分利用了超文本文档结构的附加信息，以此来提供更加高质量的搜索结果。我们将系统命名为<strong>Google</strong>，因为它是一个天文数字，即10<sup>100</sup>的另一种写法，与我们构建<strong>大规模搜索引擎</strong>的想法一致。</p><h3 id="1-1-网络搜索引擎-–-规模增长：1994-2000"><a href="#1-1-网络搜索引擎-–-规模增长：1994-2000" class="headerlink" title="1.1 网络搜索引擎 – 规模增长：1994-2000"></a>1.1 网络搜索引擎 – 规模增长：1994-2000</h3><p>搜索引擎技术不得不随着网络规模的增长而出现引人注目的增长。1994年，世界上最早的搜索引擎之一，World Wide Web Worm【参考<a href="http://info.cern.ch/" target="_blank" rel="noopener">WWW</a> 】，拥有110,000网络上可访问的文档和网页的索引。到了1997年的十一月，顶级的搜索引擎声称能够索引200万（WebCrawler）到1亿（Search Engine Watch）个网络文件不等。可以预见到2000年，互联网上一个复杂（搜索引擎）的索引将会包含超过10亿个文件。</p><h3 id="1-2-Google：随着网络的增长而增长"><a href="#1-2-Google：随着网络的增长而增长" class="headerlink" title="1.2 Google：随着网络的增长而增长"></a>1.2 Google：随着网络的增长而增长</h3><h3 id="1-3-设计目标"><a href="#1-3-设计目标" class="headerlink" title="1.3 设计目标"></a>1.3 设计目标</h3><h4 id="1-3-1-改善搜索质量"><a href="#1-3-1-改善搜索质量" class="headerlink" title="1.3.1 改善搜索质量"></a>1.3.1 改善搜索质量</h4><p>我们的主要目标是改善WEB搜索引擎的质量。在1994年，一些人认为通过一个完整的搜索索引可以很容易地找到任何东西。由The Best of the Web 1994–Navigators，<em>“最好的导航器应该可以让人们轻松地找到任何东西（一旦所有的数据都被放到了互联网上）”</em>（那时候搜索引擎的主要作用就是<strong>导航器navigator</strong>，即通过搜索引擎搜索到其他网站）。然而到了1997年，互联网有了很大的不同。任何用过搜索引擎的人都知道，决定搜索质量的因素不只是搜索结果的完整性了。<strong>Junk Results</strong>可能把所有用户感兴趣的结果都冲掉了。事实上，到1997年11月时，最好的四个商用搜索引擎中只有一个可以搜索到它自己（在搜索框中搜索自己的品牌名，如在百度一下百度，Google一下Google，取前十条结果）。造成这个现象的主要原因是，索引中文件的数量呈几何级数增加，但是用户看文件的能力没有增长。人们还是只会看前几条（页）。</p><p>因此，随着数量级的增长，我们需要一个拥有很高准确性的工具（<strong>返回高相关性的结果</strong>，比如前几十条）。事实上，我们希望只搜索到最相关的结果，因为与之有一点关系的结果可能有上万条。精确性是很重要的即使重复寻找系统中的所有文件。最近的一些研究表明更加<strong>hypertextual（超文本结构化）</strong>的信息有助于改善搜索结果。尤其引人注目的是，<strong>链接结构</strong>和<strong>链接文本</strong>为相关性判断和过滤掉不好的结果方面提供了有用的信息。Google同时使用了链接结构和锚（anchor）文本。 </p><h4 id="1-3-2-学术上搜索引擎的研究"><a href="#1-3-2-学术上搜索引擎的研究" class="headerlink" title="1.3.2 学术上搜索引擎的研究"></a>1.3.2 学术上搜索引擎的研究</h4><h2 id="2-系统特性"><a href="#2-系统特性" class="headerlink" title="2. 系统特性"></a>2. 系统特性</h2><h3 id="2-1-网页排名：给网络世界带来秩序"><a href="#2-1-网页排名：给网络世界带来秩序" class="headerlink" title="2.1 网页排名：给网络世界带来秩序"></a>2.1 网页排名：给网络世界带来秩序</h3><h4 id="2-1-1-网页排名算法描述"><a href="#2-1-1-网页排名算法描述" class="headerlink" title="2.1.1 网页排名算法描述"></a>2.1.1 网页排名算法描述</h4><h4 id="2-1-2-直观的论证"><a href="#2-1-2-直观的论证" class="headerlink" title="2.1.2 直观的论证"></a>2.1.2 直观的论证</h4><h3 id="2-2-定位文本"><a href="#2-2-定位文本" class="headerlink" title="2.2 定位文本"></a>2.2 定位文本</h3><h3 id="2-3-其它特性"><a href="#2-3-其它特性" class="headerlink" title="2.3 其它特性"></a>2.3 其它特性</h3><h2 id="3-相关工作"><a href="#3-相关工作" class="headerlink" title="3. 相关工作"></a>3. 相关工作</h2><h3 id="3-1-信息检索"><a href="#3-1-信息检索" class="headerlink" title="3.1 信息检索"></a>3.1 信息检索</h3><h3 id="3-2-网络和良好组织结构集合的区别"><a href="#3-2-网络和良好组织结构集合的区别" class="headerlink" title="3.2 网络和良好组织结构集合的区别"></a>3.2 网络和良好组织结构集合的区别</h3><h2 id="4-系统详细分析"><a href="#4-系统详细分析" class="headerlink" title="4. 系统详细分析"></a>4. 系统详细分析</h2><p>首先，我们对架构做一个高层次的讨论。其次，对一些重要的数据结构做一些深度的描述。最后，主要的应用：<strong>爬取、索引、搜索</strong>数据的性能将会被测试。</p><h3 id="4-1-Google架构概览"><a href="#4-1-Google架构概览" class="headerlink" title="4.1 Google架构概览"></a>4.1 Google架构概览</h3><p>本节，我们将对整个系统的工作流程做一个概要性的描述。接下来的几节我们会讨论具体的应用和数据结构。Google搜索引擎主要是用C/C++实现的（处于效率考虑），可以运行在Linux或Solaris上。</p><p>Google搜索引擎的网页爬取工作由多个分布式的爬虫完成。有一个包含需要被爬取的URL列表的<strong>URL server</strong>，被爬取的网页之后被送到存储服务器上。存储服务器把网页压缩并存储到仓库（repository）中。每一个网页都有一个相关联的ID（<strong>docID</strong>），每当网页中解析出一个新的URL时被赋值。索引函数被<strong>索引器（indexer）</strong>和<strong>分类器（sorter）</strong>执行。索引器执行一系列函数，包括读取repository，解压文件，解析文件内容。每个文件被转换成一个被称作<strong>hits</strong>的数据结构，根据不同单词的出现频率  。<strong>hits</strong>记录了单词、在文件中出现的位置、字体大小（字母个数？）的估计值、大小写。索引器把这些hits分成一系列<strong>barrels</strong>，产生一个部分分类的前序索引。索引器接着执行另一个功能。它将每个网页中所有的链接解析出来，在<strong>anchor files（锚文件）</strong>中存储关于它们的重要信息。这些文件包含了足够的信息来确定这些链接的走向（from-&gt;to）以及链接文字。</p><p><strong>URL解析器</strong>读取<strong>anchor files</strong>，把相对URL转换成绝对URL，进而转换成<strong>docID</strong>。它将锚文本放入前序索引，以及与之相关的<strong>docID</strong>（anchor指向的文件）。它同时产生一个链接数据库，存储了成对的docID。这个链接数据库用来为所有文件计算<strong>PageRank</strong>。</p><h3 id="4-2-主要的数据结构"><a href="#4-2-主要的数据结构" class="headerlink" title="4.2 主要的数据结构"></a>4.2 主要的数据结构</h3><h4 id="4-2-1-大文件"><a href="#4-2-1-大文件" class="headerlink" title="4.2.1 大文件"></a>4.2.1 大文件</h4><h4 id="4-2-2-仓库"><a href="#4-2-2-仓库" class="headerlink" title="4.2.2 仓库"></a>4.2.2 仓库</h4><h4 id="4-2-3-文件索引"><a href="#4-2-3-文件索引" class="headerlink" title="4.2.3 文件索引"></a>4.2.3 文件索引</h4><h4 id="4-2-4-专门词汇-lexicon"><a href="#4-2-4-专门词汇-lexicon" class="headerlink" title="4.2.4 专门词汇[lexicon]"></a>4.2.4 专门词汇[<em>lexicon</em>]</h4><h4 id="4-2-5-点击次数列表"><a href="#4-2-5-点击次数列表" class="headerlink" title="4.2.5 点击次数列表"></a>4.2.5 点击次数列表</h4><h4 id="4-2-6-前向索引"><a href="#4-2-6-前向索引" class="headerlink" title="4.2.6 前向索引"></a>4.2.6 前向索引</h4><h4 id="4-2-7-反向索引"><a href="#4-2-7-反向索引" class="headerlink" title="4.2.7 反向索引"></a>4.2.7 反向索引</h4><h3 id="4-3-爬取网络数据"><a href="#4-3-爬取网络数据" class="headerlink" title="4.3 爬取网络数据"></a>4.3 爬取网络数据</h3><h3 id="4-4-为网页建立索引"><a href="#4-4-为网页建立索引" class="headerlink" title="4.4 为网页建立索引"></a>4.4 为网页建立索引</h3><h3 id="4-5-搜索"><a href="#4-5-搜索" class="headerlink" title="4.5 搜索"></a>4.5 搜索</h3><h4 id="4-5-1-排名系统"><a href="#4-5-1-排名系统" class="headerlink" title="4.5.1 排名系统"></a>4.5.1 排名系统</h4><h4 id="4-5-2-反馈"><a href="#4-5-2-反馈" class="headerlink" title="4.5.2 反馈"></a>4.5.2 反馈</h4><h2 id="5-结果和性能分析"><a href="#5-结果和性能分析" class="headerlink" title="5. 结果和性能分析"></a>5. 结果和性能分析</h2><h3 id="5-1-存储需求"><a href="#5-1-存储需求" class="headerlink" title="5.1 存储需求"></a>5.1 存储需求</h3><h3 id="5-2-系统性能分析"><a href="#5-2-系统性能分析" class="headerlink" title="5.2 系统性能分析"></a>5.2 系统性能分析</h3><h3 id="5-3-搜索性能分析"><a href="#5-3-搜索性能分析" class="headerlink" title="5.3 搜索性能分析"></a>5.3 搜索性能分析</h3><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><h3 id="6-1-未来的工作"><a href="#6-1-未来的工作" class="headerlink" title="6.1 未来的工作"></a>6.1 未来的工作</h3><h3 id="6-2-高质量的搜索结果"><a href="#6-2-高质量的搜索结果" class="headerlink" title="6.2 高质量的搜索结果"></a>6.2 高质量的搜索结果</h3><h3 id="6-3-可扩展的系统架构"><a href="#6-3-可扩展的系统架构" class="headerlink" title="6.3 可扩展的系统架构"></a>6.3 可扩展的系统架构</h3><h3 id="6-4-用来研究的工具"><a href="#6-4-用来研究的工具" class="headerlink" title="6.4 用来研究的工具"></a>6.4 用来研究的工具</h3><h2 id="7-致谢"><a href="#7-致谢" class="headerlink" title="7. 致谢"></a>7. 致谢</h2><h2 id="8-附录A：广告和其它"><a href="#8-附录A：广告和其它" class="headerlink" title="8. 附录A：广告和其它"></a>8. 附录A：广告和其它</h2><h2 id="9-附录B：可扩展性"><a href="#9-附录B：可扩展性" class="headerlink" title="9. 附录B：可扩展性"></a>9. 附录B：可扩展性</h2><h3 id="9-1-Google的可扩展性"><a href="#9-1-Google的可扩展性" class="headerlink" title="9.1 Google的可扩展性"></a>9.1 Google的可扩展性</h3><h3 id="9-2-集中式索引结构的可扩展性"><a href="#9-2-集中式索引结构的可扩展性" class="headerlink" title="9.2 集中式索引结构的可扩展性"></a>9.2 集中式索引结构的可扩展性</h3>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Google/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Thinking-in-Java</title>
      <link>https://gitplayb.github.io/passages/TIJ4/</link>
      <guid>https://gitplayb.github.io/passages/TIJ4/</guid>
      <pubDate>Mon, 20 May 2019 02:36:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;Thinking in Java&lt;/strong&gt;的读书笔记，记下来作为自己的参考&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>Thinking in Java</strong>的读书笔记，记下来作为自己的参考<br><a id="more"></a></p><p><img src="/passages/TIJ4/1576056340655.png" alt="目录"></p><p>本书的目录如上。</p><h2 id="对象介绍"><a href="#对象介绍" class="headerlink" title="对象介绍"></a>对象介绍</h2><blockquote><p>我们将自然界的东西拆分、识别并分类，把它们组织成概念，并赋予其意义（<em>有点机器学习的感觉</em>），这一切都是因为我们（作为人类）共同遵守一个协议——即语言，通过语言来描述一切我们所知道的事物，并互相交流。</p></blockquote><p>上面这段话说明了几个问题：</p><ul><li>语言是表达用的，正如编程语言（如Java）也是用来表达的——首先将待解决的问题表达（描述），然后将解决方案用编程语言表达出来。正如<strong>乔布斯</strong>说的，<em>Computers are bicycles for the mind</em></li><li>我们能够对话（或者语言能够被理解）的前提是，我们共同遵守一个协议，或者说语言有一定的规则，就像任何编程语言都有特定的语法规则一样。</li></ul><h3 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h3><p>程序员所做的事情，其实就是在<strong>问题空间</strong>和<strong>解空间</strong>找到一个合适的映射。将现实世界中的问题抽象为程序语言设计的发展过程，经历了很多变化。<strong>LISP</strong>认为所有的问题都是lists（就像to do list，可以被一件一件勾选掉的那种）；<strong>APL</strong>认为所有问题都是有规则的（algorithmic）；<strong>Prolog</strong>认为所有的问题都是一系列的决定（decisions）。这些语言可以解决特定领域的问题，但是都有比较大的局限性。相对来说，像Java一样的面向对象程序设计语言就更具有普遍意义（general），可以将几乎任何类型的问题转化为程序设计。</p><p><strong>SmallTalk</strong>，作为第一个成功的面向对象语言，也是Java设计时的参照语言，具有五大特点（据Alan Kay说）：</p><ol><li><strong>万物皆对象</strong></li><li><strong>程序就是一堆对象互相通信，告诉对方该做什么</strong></li><li><strong>对象中可以包含其他对象——以实现复杂对象的构建</strong></li><li><strong>每个对象都有一个类型</strong>（因为每个object一定属于某个class，而class可以说是类型（type）的程序术语。</li><li><strong>同一类型的所有对象能接收相同的消息</strong></li></ol><p>用一句更简洁的话来说，</p><blockquote><p>一个对象拥有状态、行为和身份</p></blockquote><p>状态即其包含的字段（property）；行为即其方法（methods）；身份即在内存（或存储）中的地址。</p><h3 id="代码重用——组合和继承"><a href="#代码重用——组合和继承" class="headerlink" title="代码重用——组合和继承"></a>代码重用——组合和继承</h3><p>组合（composition），即一个对象中包含其他的对象（如果是动态的composition，也可以叫做<em>aggregation</em>，区分不大）；继承，即子类继承父类，扩展父类功能。</p><h3 id="多态——运行时绑定"><a href="#多态——运行时绑定" class="headerlink" title="多态——运行时绑定"></a>多态——运行时绑定</h3><p>你也许定义了一个父类和很多子类，但是在程序中调用方法时还不确定需要调用哪一个子类的方法，需要根据运行时的状态决定。这时候，多态的好处就体现出来了——你可以在使用时用父类的对象调用子类对应的方法，然后让编译器在运行时决定使用的是哪个类的方法，并进行类型检查等。</p><p>C++中也有类似的功能（晚绑定/运行时绑定），不过需要显式声明——即声明为虚函数。C++中默认是以<strong>早绑定</strong>（即编译时绑定）来实现的，而Java中的默认实现方式就是运行时绑定，方便了开发人员并使程序更易扩展。</p><p>举个例子，Shape基类和其各种形状的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> Triangle();</span><br><span class="line">Line line= <span class="keyword">new</span> Line();</span><br><span class="line">doSomething(circle);</span><br><span class="line">doSomething(triangle);</span><br><span class="line">doSomething(line);</span><br></pre></td></tr></table></figure><p>这个运行时绑定的行为也叫<strong>upcasting（向上投掷）</strong>，实际上<strong>cast</strong>可以理解为映射，即根据调用时的子类型，判断它是哪个父类的子类。</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>C++相对于Java可以多继承，有一点考虑是为了向后兼容C，单继承相对于多继承有几个好处（多数是方便做一些公共的操作）：</p><ul><li>所有对象有个基础的父类：<strong>Object</strong>，可以对所有类进行一些基础的操作如<em>toString</em>。</li><li><strong>垃圾回收</strong>——回收垃圾时不会存在<strong><em>无法确定要回收的垃圾是什么类型的情况</em></strong></li><li>一些系统级的操作，如异常处理。</li></ul><h3 id="容器集合"><a href="#容器集合" class="headerlink" title="容器集合"></a>容器集合</h3><p>为了方便运行时动态确定所要创建对象的数量，Java提供了容器集合工具（类似C++的STL）。如<strong>List、Map、Set</strong>类，还有队列、树、栈等等。之所以有这么多种基本的容器类，是因为不同的类有不同的功能，且有不同的执行效率。如<strong>ArrayList</strong>和<strong>LinkedList</strong>，前者擅长随机访问元素，后者擅长插入删除。</p><h3 id="泛型——参数化类型"><a href="#泛型——参数化类型" class="headerlink" title="泛型——参数化类型"></a>泛型——参数化类型</h3><p>泛型的存在就是为了方便检查类型，避免向下映射时出错。如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shape&gt; shapes = <span class="keyword">new</span> ArrayList&lt;Shape&gt; ();</span><br></pre></td></tr></table></figure><h3 id="对象创建-amp-生存时间"><a href="#对象创建-amp-生存时间" class="headerlink" title="对象创建&amp;生存时间"></a>对象创建&amp;生存时间</h3><p>对比C++，Java有garbage collector可以自动判断对象何时该被销毁。尽管在栈上创建对象可以节省资源（控制对象回收时间），但是对于一些普遍的问题，无法确定其需要的存储空间以及生存时间（在运行时才能确定），使用Java在堆上来创建对象（new）并让垃圾收集器来处理对象回收效率会更高。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常处理相当于程序执行时的<strong>另一条路线</strong>，或者说小路。这使得异常部分的代码与正常执行的代码不会冲突。<strong>被抛出的异常</strong>与<strong>程序中出错时的返回值</strong>是不同的。  被抛出的异常是一定要被处理的，并且异常处理提供了一个可以从异常情况恢复的方法。不只是退出程序，你还可以使程序恢复执行，增加程序的鲁棒性。</p><p>Java中如果没有正确处理异常，将会在<strong>编译时报错</strong>，因此你不得不在写代码时就检查可能会出现的错误，而不是到运行时异常退出。</p><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>并发编程的一个应用就是用户界面（user interface）。通过使用子任务（多线程），用户按了按钮会立即响应而不是要等到程序完成了当前的任务再响应。并且，如果有硬件支持（多处理器），多个线程不仅能并发，还能并行。</p><h3 id="Java和互联网"><a href="#Java和互联网" class="headerlink" title="Java和互联网"></a>Java和互联网</h3><h4 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h4><h4 id="客户端编程"><a href="#客户端编程" class="headerlink" title="客户端编程"></a>客户端编程</h4><h4 id="服务端编程"><a href="#服务端编程" class="headerlink" title="服务端编程"></a>服务端编程</h4><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发（多线程）之所以这么重要是因为你可以在很多地方看到它，甚至使用它。如在Java web开发中，最基本的库Servlet就被设计为多线程的，因为web服务器往往拥有多核处理器，使用多线程能够最大限度地利用硬件的能力（就算没有多处理器，想想web应用使用单线程来处理是多么可怕）。再如GUI编程，用户的交互体验可不能被单线程的程序一直等待给毁了！（类似JavaScript中的异步处理）。不只Java支持多线程，很多语言都支持。只不过Java中并发编程使用的较广泛而已。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><h5 id="执行更快"><a href="#执行更快" class="headerlink" title="执行更快"></a>执行更快</h5><p>对于多处理器而言，多线程编程显然能更快（如，一个任务放在一个处理器执行）；对于单处理器而言，多线程也能使程序更快，且程序中遇到一些外部事件（如I/O）而阻塞时更能体现出多线程的优势（只阻塞某线程，其它线程正常运行）。</p><p><strong>如果没有多线程</strong>，想象这样一个场景（在单处理器上进行事件驱动型编程）：</p><p>在一个GUI程序中，有一个“退出”按钮。要实现响应式设计（用户按了后立马退出），你就必须在自己的代码中的每个任务块中加上一个判断（是否检测到退出按钮被按到），不然用户按了按钮也要等到当前任务执行完才能退出。如果使用多线程的方式，单独开一个线程检测用户输入，尽管这个线程可能多数时候会被阻塞，但是程序保证了及时响应。</p><p>实现并发的另一种方式就是从操作系统层面来做，使用<strong>进程</strong>。每个进程拥有独立的地址空间，多任务操作系统可以一次运行多个进程，通过算法将CPU分配给每个进程使用，看起来好像每个进程都有自己的CPU。使用多进程的好处是操作系统将进程隔离开了，每个进程有独立的资源。而使用多线程时则要考虑资源的管理，如对互斥资源加锁等。</p><p>一些编程语言把并发的任务完全隔离开来，如<strong>Erlang</strong>。而Java则是把多个任务分成一个进程中的多个线程，且此操作对于操作系统是透明的（即操作系统也不知道你的程序在捣鼓些什么，开了多少个线程）。</p><h5 id="改善代码设计"><a href="#改善代码设计" class="headerlink" title="改善代码设计"></a>改善代码设计</h5><p>协作多线程（cooperative multithreading）。</p><h4 id="简单的线程"><a href="#简单的线程" class="headerlink" title="简单的线程"></a>简单的线程</h4><p><strong>定义任务 —— 放入线程 —— 创建多个线程</strong></p><h4 id="使用Executors"><a href="#使用Executors" class="headerlink" title="使用Executors"></a>使用Executors</h4>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/TIJ4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的音乐流亡录</title>
      <link>https://gitplayb.github.io/passages/%E6%88%91%E7%9A%84%E9%9F%B3%E4%B9%90%E6%B5%81%E4%BA%A1%E5%BD%95/</link>
      <guid>https://gitplayb.github.io/passages/%E6%88%91%E7%9A%84%E9%9F%B3%E4%B9%90%E6%B5%81%E4%BA%A1%E5%BD%95/</guid>
      <pubDate>Wed, 24 Apr 2019 04:13:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;以时间线的形式，记录一下音乐与我的&lt;strong&gt;不解之缘&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>以时间线的形式，记录一下音乐与我的<strong>不解之缘</strong><br><a id="more"></a></p><h2 id="初生-邂逅"><a href="#初生-邂逅" class="headerlink" title="初生 - 邂逅"></a>初生 - 邂逅</h2><p>最初关于音乐的记忆，大概就是母亲为了哄我，轻声哼唱的那一句句极简短又令人印象深刻的<strong>nursery rhymes(童谣)</strong>吧。由于发生在很小的时候，很多记不得了。尚能回想起来的，还是母亲在我长大一些后，偶尔给我讲述<code>历史</code>的时候哼出来的。</p><blockquote><p>摇篮摇摇，宝宝睡觉</p></blockquote><p>然后唱词中，押韵的部分用重音强调出来，听起来很有节奏感的。 很少有暴躁的小男孩听到这么温柔的哼唱还不能安定下来的时候吧</p><p>还有一个类似的</p><blockquote><p>乖宝宝，睡觉觉，老虎来了我打它</p></blockquote><p>这个虽然不是很押韵，可是就像有些歌词一样，不必为了刻意追求押韵而押韵，只要情感（绪）表达到位就好了。</p><p>能记得的只有这么多….这大概在我年幼心中播下了爱音乐的种子，一旦触土，再难根除</p><h2 id="小学-启蒙"><a href="#小学-启蒙" class="headerlink" title="小学 - 启蒙"></a>小学 - 启蒙</h2><h3 id="音乐课"><a href="#音乐课" class="headerlink" title="音乐课"></a>音乐课</h3><p>小学，算是一个比较好的启蒙时期。首先，有了每周一次（还是两次）让人十分期待（或许并不）的<strong>音乐课</strong>。现在想想，小学课堂上学过的歌曲还真不少哩！</p><p>那时候的音乐老师，印象中是一个非常年轻、非常有活力（可以说是活力四射了）、声音非常洪亮（看来是比较专业的）的女老师，用一个词来形容她的话，我觉得是<code>百灵鸟</code>。记得有一次期末考试（话说音乐课这种“可有可无”的课还会有期末考试吗）还有实践环节。每个人（如果被点到）把自己熟悉的一首歌的一小段唱出来，当着全班同学的面….天呐！这对于当时还懵懂的我，连上课都不怎么说话的，需要多大勇气，才能不紧张的唱完啊。不过，不知是由于我那时已经对音乐产生了极大兴趣还是什么原因，我站了起来，一点没有怯场地唱完了。<em>音准还不错</em>，当时唱完得到了这么一句。虽然现在听起来，好像就和“你是个好人”一样，敷衍而流于表面，但是在那时候，对于一个小孩子，已经是极大的鼓励了好吗，确实是这样。</p><h3 id="鼓号队"><a href="#鼓号队" class="headerlink" title="鼓号队"></a>鼓号队</h3><p>小学时最难忘最深刻的记忆可能来自于学校组织的<strong>鼓号队</strong>了，用专业的话讲好像叫<strong>军乐团</strong>。当时因为机缘巧合（好像是好朋友在里面，然后把我拉进去了）加入了这个，随后一发不可收拾，成了我小学生活记忆中最难忘的一部分。当时加入好像也不是很难，应该没有考核什么的，不过加入以后的训练就是让人很头疼的了。我担任的角色是<code>小号手</code>，直到长大以后才知道，原来小时候吹的那个叫<code>青年号</code>，是小号中的<strong>异类</strong>，专门用于中小学鼓号队演奏的。中国历史上战争中常见的冲锋号，好像也是同一种。青年号不同于一般的小号，最大的特（缺）点就是<strong>没有按键</strong>。所以，这样的小号要怎么吹呢？没错，是通过嘴型的变化改变气流，然后发出不同的声音。（当时为了发出某个音，和老师同学学了很久的很奇怪的嘴型）。而且，一般只能吹奏低音5，中音1、3、5🙁。当时拿到这个小号，随口一吹就是一种冲锋号的感觉，顿时觉得自己棒极了，现在看来真的好蠢啊。不过，那段时间的练习，确实让我感受到了小号的魅力，作为铜管乐器中音域最高的乐器之一，它的音色还是很吸引我的。有一次路过电子科大，旁边的一个小学传出了零零散散的音乐声，过了一阵，一段极为熟悉的旋律飘入二中，顿时想到了自己的鼓号队时光（毕竟吹的调子都是一样的，<code>55513151315，33135355351</code>）。</p><p>每到六一儿童节，印象最深的不是爸妈给了多少零花钱，而是我们作为表演嘉宾绕场经过了几条街。就整个鼓号队来说，最难的可以说就是小号了。指挥主要节奏感好，比较有leader气场；大鼓差不多是最轻松的，只要在点上“咚咚咚”就好；镲也类似；小鼓累一点，得掌握节奏的同时敲下密密麻麻的鼓点；而小号，除了要用把嘴巴吹肿的力气把音吹出来之外，还要有音准，尤其是高音不太好吹，非常不好吹，确切地说。但是每到六一，穿着一身极其亮眼的制服，拿着一手亮眼的“武器”，比吃到了几颗最甜的糖果，要甜不少。</p><p><img src="/passages/我的音乐流亡录/images/black-boy-trumpet.jpg" alt="trumpet-boy" title="trumpet-boy"></p><h3 id="磁带机"><a href="#磁带机" class="headerlink" title="磁带机"></a>磁带机</h3><p>小学时家里有了复读机，因为bro和sis已经上了初中，that’s why I got this fortune. 我猜想当时bro和sis收集到这些唱片磁带时的喜悦也许不亚于我过年得到心仪的礼物。最常听的就是<strong>周杰伦、林俊杰、王力宏、孙燕姿</strong>等等这些当时在港台以及亚洲红透了的流行天王天后们，A面B面翻来覆去的听。当时最有趣的就是，开始听周杰伦的歌发现歌词很难听懂啊，听半天愣是不知道在唱什么（只是觉得调调还不错，而且节奏很有feel，可能那时候创作的R&amp;B含量较高）。幸运的是，和磁带一起的有一张cheatsheet😀上面有部分歌的歌词。于是，当谜底揭开的时候，大都会感叹一句<strong>啊！原来这句是这样的，我一直听成了!@#^hhhh</strong>。还是蛮好玩的。</p><p>还有一个比较印象深刻的事情是，那时候bro上了初中，开始学英语（早先小学是没有英语课的），然后开始听一些英文流行歌曲。其中有<strong>Michael Learns to Rock的Take me to your heart，U make me wanna (Blue) </strong>。有一段时间，bro常会听U make me wanna，好奇的问了一句，然后bro要和我打赌，看我能不能学会副歌那尤其押韵的几句（当时我可能才开始上英语课，单词都不认识几个），可还是接受了。于是在接下来的几十分钟内，bro一句一句（并不是一词一词），因为里面的单词都不认识。最后，完全通过模仿发音的方式（还是很难的好嘛），完全学会了那几句….</p><blockquote><p>U make me wanna call you in the middle of the night, U make me wanna hold you till the morning light</p><p>U make me wanna love, U make me wanna fall, U make me wanna surrender my soul</p><p>I know this is a feeling that I just can’t fight, you’re the first and last thing on my mind</p><p>U make me wanna love, U make me wanna fall, U make me wanna surrender my soul</p></blockquote><h2 id="初中-非主流"><a href="#初中-非主流" class="headerlink" title="初中 - 非主流"></a>初中 - 非主流</h2><p>初中时记得印象比较深刻的歌手就是<strong>周杰伦、许嵩、Westlife、Justin Bieber、Taylor Swift</strong>。</p><p><code>周杰伦</code>的歌感觉听的挺多的，但其实最疯狂的那段时间是在初中那会。现在还能记得那时候去上生物竞赛的补习课，和好基友坐在后排，拿着珍贵而又储量丰富的mp3<br>，趁老师不注意，偷偷地把超喜欢的那几首听了一遍又一遍。那时候最喜欢听的好像是<strong>反方向的钟、断了的弦、彩虹、星晴给我一首歌的时间、爷爷泡的茶</strong>。这些旋律真的超级抓耳啊！那时候真的觉得周杰伦的歌是让人听着最舒服的！</p><p><code>许嵩</code>那时候好像嵩哥正火，开始我也没怎么听他的，后来也是在好朋友的推荐下开始了这段非主流之旅。从城府开始，到有何不可、素颜（每天中午广播站必放之一）、清明雨上、断桥残雪、玫瑰花的葬礼、半城烟沙、多余的解释、我想牵着你的手（觉得这首超级R&amp;B！）、情侣装、粉色信笺、白马非马….突然发现一写停不下来:( 听他的歌觉得很舒服，因为他的歌真的太适合初中生听了（没有别的意思…）因为曲风比较轻松，而且歌词还脑洞大、有点小文艺。</p><p><code>Westlife</code>西城男孩也是初中开始熟悉起来的。最开始听了他们的My love、I lay my love on you，到后来的Seasons in the sun、If I let you go、Uptown girl、More than words以及后来才知道他们也唱过的Nothing’s gonna change my love for you（最初就是听方大同的），当时对他们的最大印象应该是节奏（鼓）不错，和声好听（当时可能还不知道和声是什么，就是觉得四个人唱歌比一个人唱好听），然后因为他们，开始喜欢听英文歌了。</p><p><code>Justin Bieber</code>更是承载了满满的中学回忆啊…从他刚开始在YouTuBe上传视频，到因为Baby红遍全球，刚好是我在初中的那几年。最开始就是被baby里小男孩的声音吸引了（其实一直觉得是个小女孩来着），还有里面的吉他（在我真正了解吉他之前一直以为里面的吉他部分很难）和最后的rap。我发现那时候喜欢的歌都是混杂着各种风格，不光要旋律好听，还要歌词写得好，然后节奏也要又，最好有一段说唱…那时候要求还真是蛮高的</p><p><code>Taylor Swift</code>的歌初中虽然听过的不多，但是就是因为某两首，立刻就被圈粉了。我还记得那个下午，当第一次听到You belong with me的时候真的是一秒爱上。因为这首歌的编曲就是混杂一点乡村和流行，旋律也很优美。另外一首，Our song，这首也前奏秒。这首的乡村风味相对更浓，并且有一部分类似说唱的part。因为之前没有接触过乡村风格，或者说美国的歌手（除了Michael Jackson的部分歌曲），再加上Taylor那时候创作才能正爆发，所以刚好幸运地听到了这些。</p><p>除了这些，还有一首要特别说一下，Linkin Park的<code>In the end</code>。这首歌的前奏、说唱部分、副歌主唱的爆发以及副歌旋律是我最喜欢的部分。可能当时英语也算不差，所以当听到主歌超有感染力的rap的时候就想我能不能学会。经过一段时间的努力，好像可以勉强唱下来了，但是里面句子的意思还不理解（尤其是有很多生词）。但是成就感还是有的。</p><p>除此之外，还有一些充满了美好回忆的歌，到现在也很喜欢。看了以下自己的歌单，发现包含初中美好回忆的有这么几首：<strong>未填词-邓福如，五分熟-Yummy，I just wanna run-The Downtown Fiction，Rock DJ-Robbie Williams，Booty music-Deep Side和Tu Vivi Nell’Aira-M2/Miani</strong>。这些歌当时真的是喜欢的不得了。</p><blockquote><p><strong>未填词-邓福如</strong>这首，觉得声音处理的很特别，感觉很空灵，歌手的嗓音也很舒服<br><strong>五分熟-Yummy</strong>。这首又是满满的rap风，后来才知道是翻唱韩国一女团的歌。不过觉得她们唱的很好，歌词很狗血，虽然是女生的歌，但男生唱起来也很爽！<br><strong>I just wanna run-The Downtown Fiction</strong>。这首动感十足，比较电音<br><strong>Rock DJ-Robbie Williams</strong>。这首歌后来才知道是Robbie Williams唱的，应该说后来才知道罗比威廉姆斯竟然还唱过这样的歌。第一次听的时候觉得好像是在用英语的方言在唱，感觉调子很奇怪，可能是太DJ了<br><strong>Booty music-Deep Side</strong>可以称得上是小黄歌了。但是被黑人的乐感征服的不要不要的，很rap<br><strong>Tu Vivi Nell’Aira-M2/Miani</strong>。这首歌是当时觉得很神奇的一首歌，痴迷于它贯穿全曲的重低音，虽然没有音响，但一个差不多的耳机也可以感受个大概；以及这首歌的<em>方言</em>，应该不能叫做方言了，这本身就不是英语。很久没听到这首歌，关键是不知道这个歌名。突然某天朋友从QQ上发来消息说，在锻炼的时候随机播放到了这首，发给我一听，哇！当时的感觉就像失散多年的亲人重逢了一般，超级感动。</p></blockquote><h2 id="高中-英文世界"><a href="#高中-英文世界" class="headerlink" title="高中 - 英文世界"></a>高中 - 英文世界</h2><p>高中，随着单词量的增多，发现听的中文歌越来越少了。不过也不能这么说，毕竟听的英文歌里单词量也没有多少。可能中文歌当时没有找到喜欢的，主要是当时也没有经常可以使用的手机，手机上也没有可以发现新歌的app，反正就是这样。</p><p>高中喜欢的歌手记不得多少了，现在想想，那时候要是有写日记的习惯多好。因为那时候听的歌好像多数都是从网上下载，然后用酷狗听的。当时没有在音乐app里听歌的习惯。依稀记得的，有<strong>One Direction、One Republic、Bruno Mars、The Vamps、Cody Simpson</strong>。</p><p><code>One Direction</code>就是一群会唱歌的阳光美少年啊。他们的pop风格就是很多小女生的最爱吧，可是我也很喜欢。最开始就是被What makes you beautiful 和Live while we are young的mv里的一帮年轻人的活力感染了。但是后来发现，他们的很多歌都很难唱….据说高音部分很多都是<a href="https://wikipedia.org/wiki/Harry_Styles" target="_blank" rel="noopener">Harry Styles</a> 喊出来的。从后期他们解散了之后卷哈的风格也可以看出来，他比较擅长唱高音，而且高音是比较有力量的那种。</p><p><code>One Republic</code>的Counting stars不知道算不算他们的成名作，反正是我高中里的<br><code>Bruno Mars</code>火星哥是我高中时期非常迷恋的一个歌手。<br><code>The Vamps</code>的第一首听到的歌，Wild heart。这个乐队的主唱的声音可以说更<em>青春</em>，<br><code>Cody Simpson</code>澳洲沙滩阳光小帅哥。小时候因为翻唱了Jason Mraz的I’m yours而走红，而后和唱片公司签约，开始出的一些歌都是比较符合他（或者说公司）给他的定位的风格，很多充满了阳光、海滩的元素，歌曲也大多是青春期的爱情，比较小清新了。后来，随着自己变成熟，听过的不同音乐的影响，自己也逐渐发现了真正想要的风格，这时候就比较偏Blues、R&amp;B一些了。他的一张专辑<strong>free</strong>体现了他在音乐上的新的探索，充满了牛仔风。</p><h2 id="大学-发现自我"><a href="#大学-发现自我" class="headerlink" title="大学 - 发现自我"></a>大学 - 发现自我</h2><p>大学给我带来的最大的改变，就是把我的音乐品味往前倒推了几十年。</p><p>其实我不是一个容易怀旧的人，但是当现有的歌曲满足不了我的耳朵的时候，我会在经典中寻找答案。</p><p>首先，大二邂逅合唱团，这是一个幸运的不能再幸运的故事。大学里没有能加入篮球队算是一个小遗憾了，但是当我发现大学的社团没有一个让人满意时，心里还是蛮失落的。幸运的是，我在大二加入了校合唱团，这是一个充满活力的组织，在这里我认识了很多好朋友，并且有机会在专业老师的指导下，系统地学习（虽然仅仅了解了一点）专业的合唱知识，甚至还赶上了几年一度的大学生艺术节….这些带给我的不只是荣誉上的一些东西，更重要的是让我对音乐有了新的认识，让我学会了欣赏好的音乐。</p><h3 id="阿卡贝拉、蓝调与生活"><a href="#阿卡贝拉、蓝调与生活" class="headerlink" title="阿卡贝拉、蓝调与生活"></a>阿卡贝拉、蓝调与生活</h3><h4 id="A-Capella"><a href="#A-Capella" class="headerlink" title="A Capella"></a>A Capella</h4><p>A Capella，也叫阿卡贝拉，一种无伴奏人声合唱形式，是进入合唱团后遇见的第一个惊喜。从来没有想过会组建或者加入一个乐队什么的，因为毕竟太酷了，有点不可想象。（<del>我不会承认是因为太穷而且没时间</del>）加入这个阿卡贝拉组合也真的是纯属意外，就在我知道他们要组一个团，搞阿卡贝拉的时候，虽然那时候正在召集人员，但我也是最后才知道的，恰好里面有一个朋友在，所以赶紧让他把我拉进去了。</p><p>和组合里的朋友们在一起，是大学里最难忘的一段时光了。</p><h3 id="Blues"><a href="#Blues" class="headerlink" title="Blues"></a>Blues</h3><p>我从挺小的时候就接触吉他了，至少是知道有这么一个乐器的。可能是早期没有培养出对吉他的兴趣，所以也一直没有学。不知道从什么时候开始，我似乎在寻找一种音乐，但是不知道这种音乐形式是什么，可能在哪里听过，只是隐隐觉得，我会非常喜欢这种音乐。直到大二的某段时间，我发现这种音乐和吉他有关系，后来知道了，我想要的这种音乐就是蓝调，<a href="https://wikipedia.org/wiki/Blues" target="_blank" rel="noopener">Blues</a>。 小时候就听说过Jazz，但并不知道是个什么东西，似乎和舞蹈有关系。当我后来了解了布鲁斯音乐以及其发展历程时，才发现Jazz竟然也是从其衍生出来，收到它的很大的影响的一个音乐流派。于是我对这个起源于美国黑人的民间音乐有了更大的兴趣。</p><blockquote><p>放一张共鸣器吉他【Resonator Guitar】的图</p></blockquote><p><img src="/passages/我的音乐流亡录/images/blues-guitar.jpg" alt="blues-guitar" title="blues-guitar"></p><h3 id="口琴和吉他"><a href="#口琴和吉他" class="headerlink" title="口琴和吉他"></a>口琴和吉他</h3><p>开始想要有很强的练习吉他的欲望是因为Blues，后来随着深入了解了布鲁斯，对Blues口琴（十孔）产生了很大的兴趣，于是又转投（也不算）口琴阵营。在被Blues迷得五迷三道的时候，<em>网易云音乐</em>算是一个给人很多安慰的平台了。因为身边的朋友听蓝调的很少，所以除了开始在贴吧（这也是我为什么开始用贴吧的原因！）寻找一些帮助之外，后来在网易云上发现了不少喜欢这个的人。随着听的布鲁斯风格音乐越来越多，歌曲的评论也越来越少。偶尔自己写的评论被人回复了或者点赞了还有一种惊喜的感觉:-) </p><h3 id="超超超喜欢的几个歌手"><a href="#超超超喜欢的几个歌手" class="headerlink" title="超超超喜欢的几个歌手"></a>超超超喜欢的几个歌手</h3><h4 id="陶喆"><a href="#陶喆" class="headerlink" title="陶喆"></a>陶喆</h4><h4 id="The-Beatles"><a href="#The-Beatles" class="headerlink" title="The Beatles"></a>The Beatles</h4><p><img src="/passages/我的音乐流亡录/images/the-beatles.jpg" alt="The Beatles" title="The Beatles"></p><h4 id="Simon-amp-Garfunkel"><a href="#Simon-amp-Garfunkel" class="headerlink" title="Simon&amp;Garfunkel"></a>Simon&amp;Garfunkel</h4><h4 id="Weezer"><a href="#Weezer" class="headerlink" title="Weezer"></a>Weezer</h4><h4 id="Jimi-Hendrix"><a href="#Jimi-Hendrix" class="headerlink" title="Jimi Hendrix"></a>Jimi Hendrix</h4><h4 id="John-Mayer"><a href="#John-Mayer" class="headerlink" title="John Mayer"></a>John Mayer</h4><h4 id="CCR-Creedence-Clearwater-Revival"><a href="#CCR-Creedence-Clearwater-Revival" class="headerlink" title="CCR[Creedence Clearwater Revival]"></a>CCR[Creedence Clearwater Revival]</h4><h4 id="Paul-Butterfield"><a href="#Paul-Butterfield" class="headerlink" title="Paul Butterfield"></a>Paul Butterfield</h4><h4 id="Jean-Jacques-Milteau"><a href="#Jean-Jacques-Milteau" class="headerlink" title="Jean-Jacques Milteau"></a>Jean-Jacques Milteau</h4><h4 id="Louis-Armstrong-amp-Chet-Baker"><a href="#Louis-Armstrong-amp-Chet-Baker" class="headerlink" title="Louis Armstrong&amp;Chet Baker"></a>Louis Armstrong&amp;Chet Baker</h4><blockquote><p>很多爵士乐队中小号手的姿势</p></blockquote><p><img src="/passages/我的音乐流亡录/images/black-suit-trumpet.jpg" alt="black-suit-trumpet" title="black-suit-trumpet"></p><blockquote><p>（Cool Jazz）小号王子Chet Baker</p></blockquote><p><img src="/passages/我的音乐流亡录/images/chet-baker.jpg" alt="Chet Baker" title="Chet Baker"></p><hr><blockquote><p>Trumpet_Medley（DAW里拼接的第一个作品）</p></blockquote>        <div id="aplayer-rLoPdTDZ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-rLoPdTDZ"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Trumpet Medley",              author: "Anonymous",              url: "audios/Trumpet_Medley.mp3",              pic: "https://gitplayb.github.io/passages/%E6%88%91%E7%9A%84%E9%9F%B3%E4%B9%90%E6%B5%81%E4%BA%A1%E5%BD%95/images/black-suit-trumpet.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p><br></p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E6%88%91%E7%9A%84%E9%9F%B3%E4%B9%90%E6%B5%81%E4%BA%A1%E5%BD%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>字节跳动笔试题</title>
      <link>https://gitplayb.github.io/passages/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%AC%94%E8%AF%95%E9%A2%98/</link>
      <guid>https://gitplayb.github.io/passages/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%AC%94%E8%AF%95%E9%A2%98/</guid>
      <pubDate>Mon, 15 Apr 2019 05:05:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://bytedance.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字节跳动&lt;/a&gt; 的笔试题，说多了都是泪&lt;strong&gt;:(  &lt;/strong&gt;&lt;br&gt;好像对于ACM的同学不算什么，但是对于普通菜鸟来说真的很难了。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://bytedance.com" target="_blank" rel="noopener">字节跳动</a> 的笔试题，说多了都是泪<strong>:(  </strong><br>好像对于ACM的同学不算什么，但是对于普通菜鸟来说真的很难了。</p><a id="more"></a><h2 id="1-变身程序员"><a href="#1-变身程序员" class="headerlink" title="1. 变身程序员"></a>1. 变身程序员</h2><h4 id="题目描述（思路：BFS）"><a href="#题目描述（思路：BFS）" class="headerlink" title="题目描述（思路：BFS）"></a>题目描述（思路：BFS）</h4><p>公司的程序员不够用了，决定把产品经理都转变为程序员以解决开发时间长的问题。</p><p>在给定的矩形网格中，每个单元格可以有以下三个值之一：</p><ul><li><strong>0</strong>代表空单元格</li><li><strong>1</strong>代表产品经理</li><li><strong>2</strong>代表程序员</li></ul><p>每分钟，任何与程序员（在4个正方向上）相邻的产品经理都会变成程序员。</p><p>返回直到单元格中没有产品经理为止所必须经过的最小分钟数。若不可能，返回-1。</p><p>如：</p><p><img src="/passages/字节跳动笔试题/images/pm-coder.png" alt="pm-coder" title="pm-coder"></p><p>注：输入只要是“矩形”即可，不一定是n*n的，可以是m*n的</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><ul><li>不固定多行（行数&lt;=10），每行是按照空格分割的数字（不固定，每行数字个数&lt;=10）</li><li>每个数组项取值只能是0、1、2</li><li>读取时可以按行读取，直到读取到空行为止，再对读取的所有行做转换处理</li></ul><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><ul><li>如果能够将所有产品经理变成程序员，则输出最小的分钟数</li><li>如果不能，则输出-1</li></ul><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 1</span><br><span class="line">1 1 0</span><br><span class="line">0 1 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="2-特征提取"><a href="#2-特征提取" class="headerlink" title="2. 特征提取"></a>2. 特征提取</h2><h4 id="题目描述（思路：map）"><a href="#题目描述（思路：map）" class="headerlink" title="题目描述（思路：map）"></a>题目描述（思路：map）</h4><p>小明是一名算法工程师，同时也是一名铲屎官。某天，他突发奇想，想从猫咪的视频里挖掘一些猫咪的运动信息。为了提取运动信息，他需要从视频的每一帧提取“猫咪特征”。一个猫咪特征是一个二维的vector&lt;x, y&gt;。如果x_1=x_2 &amp;&amp; y_1=y_2，那么这俩是同一个特征。</p><p>因此，如果猫咪特征连续一致，可以认为猫咪在运动。也就是说，如果特征&lt;a, b&gt;在持续帧里出现，那么它将构成特征运动。比如，特征&lt;a, b&gt;在第2/3/4/7/8帧出现，那么该特征将形成两个特征运动2-3-4和7-8。</p><p>现在，给定每一帧的特征，特征的数量可能不一样。小明期望能找到最长的特征运动。</p><h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><ul><li>第一行包含一个正整数N，代表测试用例的个数</li><li>每个测试用例的第一行包含一个正整数M，代表视频的帧数。</li><li>接下来的M行，每行代表一帧。其中，第一个数字是该帧的特征个数，接下来的数字是特征的取值。比如样例输入第三行，2代表该帧有两个猫咪特征，&lt;1, 1&gt;和&lt;2, 2&gt;，所有用例输入特征总和&lt;100000</li><li>满足1&lt;=N&lt;=100000, 1&lt;=M&lt;=10000, 一帧的特征个数满足&lt;=10000。特征取值均为非负整数。</li><li>如果没有长度大于2的特征运动，返回1</li></ul><h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h4><p>对每一个测试用例，输出特征运动的长度作为一行</p><p><strong>示例1</strong></p><blockquote><p>输入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br><span class="line">2 1 1 2 2</span><br><span class="line">2 1 1 1 4</span><br><span class="line">2 1 1 2 2</span><br><span class="line">2 2 2 1 4</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><blockquote><p>输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><blockquote><p>说明</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特征&lt;1, 1&gt;在连续的帧中连续出现3次，相比其他特征连续出现的次数大，所以输出3</span><br></pre></td></tr></table></figure><h2 id="3-机器人跳跃问题"><a href="#3-机器人跳跃问题" class="headerlink" title="3. 机器人跳跃问题"></a>3. 机器人跳跃问题</h2><h4 id="题目描述（思路：二分）"><a href="#题目描述（思路：二分）" class="headerlink" title="题目描述（思路：二分）"></a>题目描述（思路：二分）</h4><p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑–从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。</p><p>起初，机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E，下一步它将跳到第k+1个建筑。它将会得到或者失去正比于H(k+1)与E之差的能量。如果H(k+1)  &gt; E，那么机器人就会失去H(k+1) - E的能量，否则它将得到E - H(k+1)的能量值。</p><p>游戏目标是到达第N个建筑，在此过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h4><ul><li>第一行输入，表示有N组数据</li><li>第二行是N个空格分隔的整数，H1, H2, H3, …, Hn，代表建筑物的高度</li><li>数据范围：N与H(i)均在1-10^5之间</li></ul><h4 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h4><ul><li>输出一个单独的数表示完成游戏所需的最少单位的初始能量</li></ul><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 3 2 4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 6 4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="4-毕业旅行问题"><a href="#4-毕业旅行问题" class="headerlink" title="4. 毕业旅行问题"></a>4. 毕业旅行问题</h2><h4 id="题目描述（思路：dp动态规划）"><a href="#题目描述（思路：dp动态规划）" class="headerlink" title="题目描述（思路：dp动态规划）"></a>题目描述（思路：dp动态规划）</h4><p>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能地省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><h4 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h4><ul><li>城市个数 n（1&lt;=n&lt;=20，包括北京）</li><li>城市间的车票价钱 n行n列的矩阵 m[n][n]</li></ul><h4 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h4><ul><li>最小车费花销 s</li></ul><p><strong>示例1</strong></p><blockquote><p>输入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 2 6 5</span><br><span class="line">2 0 4 4</span><br><span class="line">6 4 0 2</span><br><span class="line">5 4 2 0</span><br></pre></td></tr></table></figure><blockquote><p>输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><blockquote><p>说明</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共4个城市，城市1和城市1的车费为0，城市1和城市2的车费为2，城市1和城市3的车费为6，城市1和城市4的车费为5，依此类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况</span><br></pre></td></tr></table></figure><h2 id="5-过河"><a href="#5-过河" class="headerlink" title="5. 过河"></a>5. 过河</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有n个人要过河，但是河边只有一艘船；</p><p>船每次最多坐三个人，每个人单独坐船过河的时间为a[i]，两个人或者三个人一起坐船时，过河时间为他们所有人中的最长过河时间；</p><p>为了安全起见，要求每次至少有两个人才能过河；</p><p>问最短需要多少时间，才能把所有人送过河。</p><h4 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h4><ul><li><p>第一行是整数n，表示测试样例个数</p></li><li><p>每个测试用例的第一行是一个正整数m，表示参加过河的人数（2&lt;=m&lt;100000）</p></li><li>第二行是m个正整数a[i]（0&lt;a[i]&lt;100000），表示n个人的单独过河的时间</li></ul><h4 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h4><ul><li>对每个测试用例，输出应该准备的最少的过河时间</li></ul><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">4</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%AC%94%E8%AF%95%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读【约翰·克利斯朵夫】</title>
      <link>https://gitplayb.github.io/passages/Reviews-on-Jean-Christophe/</link>
      <guid>https://gitplayb.github.io/passages/Reviews-on-Jean-Christophe/</guid>
      <pubDate>Fri, 28 Sep 2018 15:40:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;心&lt;/strong&gt;是无论如何必须有所依恋的，&lt;strong&gt;如果一无依傍，它就活不了&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>心</strong>是无论如何必须有所依恋的，<strong>如果一无依傍，它就活不了</strong><br><a id="more"></a></p><h3 id="为什么读这个？"><a href="#为什么读这个？" class="headerlink" title="为什么读这个？"></a>为什么读这个？</h3><p>完全是因为某一次在图书馆二楼闲逛的时候（想找两本好书看看来着），当时其实也不知道什么书好看，就凭两点：我听说过的名著（最好是外国的，中国的感觉古代的读不懂，现当代的又不知道有谁）；名字或者封面或者包装比较好听（看）的书…. <strong>《约翰·克利斯朵夫》</strong>这本书其实中学时候就听说过，但是当时只知道它是名著，是一个写过<strong>《名人传》</strong>的人写的，具体的我就不知道了，当时在图书馆看到突然觉得这本书以一个人名字作为书名挺有意思的，就想拿来看看。<br>没想到，读过了第一章，便爱不释手。</p><hr><h4 id="附上主人公肖像"><a href="#附上主人公肖像" class="headerlink" title="附上主人公肖像"></a>附上主人公肖像</h4><p><img src="http://www.nonchaos.space/img/Christophe.png" alt="Jean Christophe" title="Jean Christophe"></p><h4 id="里面印象深刻的句子"><a href="#里面印象深刻的句子" class="headerlink" title="里面印象深刻的句子"></a>里面印象深刻的句子</h4><p><strong>《约翰·克利斯朵夫》</strong> <em>（Jean Christophe)</em>    </p><blockquote><p><em>心是无论如何必须有所依恋的，如果一无依傍，它就活不了</em>    </p></blockquote><p>每个人不一定有信仰，这里的信仰指的是侠义的信仰，即宗教之类的，或者共产主义等等，但是一定要有一个相信的东西，比如说相信<code>努力不一定成功，但放弃一定失败</code>等等。这让我想起<em>《岁月神偷》</em>里吴君如扮演的母亲总爱说的一句话：“做人呐，总要信！”。大概这里说的是同一个意思。人之所以可以称作为高级动物，不仅仅是因为会制造和使用工具（好像是哪门课里的定义来着…），更重要的是人类会思考，同时知道自己在思考，并且善于思考。有了思维，就有了精神世界。精神世界中好的一方面把我们引向充满希望的一边，让我们即使遇到困难也会不屈不挠，即使胜过对手也不跋扈自傲。可以说，人类丰富的精神世界，使人类从浩瀚星球中的无名小卒，变成了能够“主宰”地球的银河系斗士。很喜欢陶喆的一首歌《找自己》，唱的也是关于寻找内心的自己的事情，生活中只有多多思考，才能不让自己迷失在一刻也不肯停止的时钟嘀嗒声里。   </p><blockquote><p><em>唯有跟别人息息相通的艺术才是有生命的艺术</em>   </p></blockquote><p>是啊。艺术之所以产生，不就是为了以一种<code>象征</code>手法来表现现实的世界的种种吗？如果只是为了追求某种艺术形式而使艺术的表达变成了空洞而无意义的show off，那么此艺术，不要也罢。</p><blockquote><p><em>我的心简直想不起你了，因为你在的时候，时间是不存在的</em>   </p></blockquote><p>幸福的时光总是过得太快。就像我们和一个相处起来很舒服的人在一起，不知不觉就度过了很久一样。</p><blockquote><p><em>她不知道结婚是对天性的挑战</em>  </p></blockquote><p>个人理解，<strong>恋爱</strong>中我们一般都能更多的收获快乐，我们的自由也不会得到限制；而<strong>结婚</strong>，之所以说是对天性的挑战，是因为我们原本是<strong>自由之身</strong>（幸运的话也是自由之心），然而在长时间的与我们的counterpart磨合的过程中，我们只有渐渐掌握了婚姻的真谛，才能更好地挑战天性，打磨我们个性中不完整的地方。</p><blockquote><p><em>越是那些无话可说的人越喜欢写诗   –歌德</em>  </p></blockquote><p>这句话从某种程度上来讲，是有一点道理的。比如有些时候，不知道用平常的语言该怎么表达，就会去寻找一种隐含的、诗意的表达方式。</p><blockquote><p><em>圆满的爱情消磨你的意志，不圆满的爱情伤害你的心</em>  </p></blockquote><p>所以说，让你不快乐的爱情不如不要。</p><blockquote><p><em>幸福是灵魂的一种香味，是一颗歌唱的心的和声。而灵魂的最美的音乐是慈悲。</em>  </p></blockquote><blockquote><p><em>一朝被患难接触到了，人世的美就显得非常空洞了</em>  </p></blockquote><p>每当你遇到困难，你可以先想想世界上比你遭受更大磨难的人还在好好的生活，你就会将注意力从这个困难有多大上转移开了。比如，海伦凯勒从很小的时候成了聋盲患者，然而她却已坚毅的态度与自己的命运作斗争，最终战胜了脆弱版的自己。</p><blockquote><p><em>在寂静的夜里，她（洛莎）的尖嗓子给克利斯朵夫的感觉好像是个弹错的音（可见他对她有多讨厌，主要是他此时迷上了萨皮纳</em>   </p></blockquote><blockquote><p><em>可怜一个人对于幸福太容易上瘾了！等到自私的幸福变成了人生唯一的目标之后，不久人生就变得没有目标。幸福成为一种习惯，一种麻醉品，少不掉了。然而老是抓住幸福究竟是不可能的……宇宙之间的节奏不知有多少种，幸福只是其中的一个节拍而已；人生的钟摆永远在两极中摇晃，幸福只是其中的一极；要是钟摆停止在一极上，只能把钟摆折断……</em>   </p></blockquote><p>知足常乐，知足是福，然而我们不能一直满足于沉浸在这种幸福中而止步不前。生活要学会预判，你生命中发生的每件事都不是没来由的，当然，由你主观可以控制的只是一部分，还有部分外界因素。我们能做的就是<strong>Change what we can</strong>，这样才有可能以<strong>平常心</strong>看待生活。</p><blockquote><p><em>因为每个人心里有一颗隐秘的灵魂，有些盲目的力，有些妖魔鬼怪，平时都被封锁起来的。自有人类以来，所有努力都是用理性与宗教铸成一条堤岸，防御这个内心的海洋。但暴风雨来的时候，（内心越充实的人，越容易受暴风雨控制，）堤岸崩溃了，妖魔猖獗了，跟那些被同类的妖魔掀动起来的别的灵魂相击相撞……它们投入彼此的怀抱，紧紧的搂着。我们也说不出那是恨是爱，还是互相毁灭的疯狂……——总而言之，所谓情欲是灵魂做了俘虏。</em>   </p></blockquote><p>每个人都是<code>天使与魔鬼</code>的化身，到了某个决定性的时刻，脑袋边上的两个小人便要一决雌雄，决定对你的统治权。</p><blockquote><p><em>克利斯朵夫这才懂得海顿老人的明哲，——他每天早上执笔之前先要跪着……战战兢兢的提防，诚惶诚恐的祈祷。所以你得祈祷上帝，求他和你同在。你得抱着虔诚与热爱的心和生命之神沟通。</em>  </p></blockquote><p><code>生命之神</code>，这是一个大的有些恐怖的词。我们以一种虔敬的态度对待生命，才能在生活中感悟到生命存在的意义；想做好任何一件事情，首先要做到就是<strong>敬畏</strong>，换句话说，<em>Consider something as AWESOME</em>，<strong>awesome</strong>的英文释义是：<em>1. impressive and frightening &amp; 2. excellent</em>，也就是，一个事物好到让你感到害怕，当然这个害怕我认为并不是感到恐惧的害怕，而是让人惊叹的害怕，当你认为某个东西more than amazing时，有什么理由不去追寻呢？</p><blockquote><p><em>生命是连续不断的死亡与复活  –罗曼罗兰</em></p></blockquote><p>物理世界的生命只是一条单行道，而精神世界的生命确是一个循环往复的赛道，周而复始，没有尽头。</p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/Reviews-on-Jean-Christophe/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://gitplayb.github.io/passages/hello-world/</link>
      <guid>https://gitplayb.github.io/passages/hello-world/</guid>
      <pubDate>Thu, 28 Jun 2018 11:13:51 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content:encoded>
      
      <comments>https://gitplayb.github.io/passages/hello-world/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
